{"id": 1, "name": "zero_add", "statement": "theorem zero_add (n : MyNat) : .zero + n = n := by", "proof": "  induction n with\n  | zero =>\n    rw [add_zero]\n  | succ d ih =>\n    rw [add_succ,ih]", "known_theorems": []}
{"id": 2, "name": "succ_add", "statement": "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "proof": "  induction b with\n  | zero =>\n    rw [add_zero,add_zero]\n  | succ d ih =>\n    rw [add_succ,ih,add_succ]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by"]}
{"id": 3, "name": "add_comm", "statement": "theorem add_comm (a b : MyNat) : a + b = b + a := by", "proof": "  induction b with\n  | zero =>\n    rw [add_zero, zero_add]\n  | succ d ih =>\n    rw [add_succ, ih, succ_add]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by"]}
{"id": 4, "name": "add_assoc", "statement": "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "proof": "  induction c with\n  | zero =>\n    rw [add_zero, add_zero]\n  | succ d ih =>\n    rw [add_succ, add_succ, ih, add_succ]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by"]}
{"id": 5, "name": "add_right_comm", "statement": "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "proof": "  rw [add_assoc]\n  rw [add_comm b, add_assoc]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by"]}
{"id": 6, "name": "add_left_comm", "statement": "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "proof": "  rw [← add_assoc]\n  rw [add_comm a b]\n  rw [add_assoc]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by"]}
{"id": 7, "name": "succ_eq_add_one", "statement": "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "proof": "  rw [one_eq_succ_zero]\n  rw [add_succ, add_zero]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by"]}
{"id": 8, "name": "implication_one", "statement": "theorem implication_one (x y z : MyNat) (h1 : x + y = four) (h2 : three * x + z = two) : x + y = four := by", "proof": "  exact h1", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by"]}
{"id": 9, "name": "implication_two", "statement": "theorem implication_two (x y : MyNat) (h : zero + x = zero + y + two) : x = y + two := by", "proof": "  rw [zero_add] at h\n  rw [zero_add] at h\n  exact h", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem implication_one (x y z : MyNat) (h1 : x + y = four) (h2 : three * x + z = two) : x + y = four := by"]}
{"id": 10, "name": "implication_three", "statement": "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "proof": "  apply h2 at h1\n  exact h1", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem implication_one (x y z : MyNat) (h1 : x + y = four) (h2 : three * x + z = two) : x + y = four := by", "theorem implication_two (x y : MyNat) (h : zero + x = zero + y + two) : x = y + two := by"]}
{"id": 11, "name": "implication_four", "statement": "theorem implication_four (x : MyNat) (h : x + one = four) : x = three := by", "proof": "  rw [one_eq_succ_zero] at h\n  rw [four_eq_succ_three] at h\n  rw [add_succ] at h\n  apply succ_inj at h\n  rw [add_zero] at h\n  exact h", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem implication_one (x y z : MyNat) (h1 : x + y = four) (h2 : three * x + z = two) : x + y = four := by", "theorem implication_two (x y : MyNat) (h : zero + x = zero + y + two) : x = y + two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by"]}
{"id": 12, "name": "implication_five", "statement": "theorem implication_five (x : MyNat) : x = four → x = four := by", "proof": "  intro h\n  exact h", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem implication_one (x y z : MyNat) (h1 : x + y = four) (h2 : three * x + z = two) : x + y = four := by", "theorem implication_two (x y : MyNat) (h : zero + x = zero + y + two) : x = y + two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : x + one = four) : x = three := by"]}
{"id": 13, "name": "implication_six", "statement": "theorem implication_six (x y : MyNat) : x + one = y + one → x = y := by", "proof": "  intro h\n  rw[one_eq_succ_zero] at h\n  rw[add_succ,add_succ] at h\n  apply succ_inj at h\n  rw[add_zero,add_zero] at h\n  exact h", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem implication_one (x y z : MyNat) (h1 : x + y = four) (h2 : three * x + z = two) : x + y = four := by", "theorem implication_two (x y : MyNat) (h : zero + x = zero + y + two) : x = y + two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : x + one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by"]}
{"id": 14, "name": "implication_seven", "statement": "theorem implication_seven (x y : MyNat) (h1 : x = y) (h2 : x ≠ y) : False := by", "proof": "  apply h2 at h1\n  exact h1", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem implication_one (x y z : MyNat) (h1 : x + y = four) (h2 : three * x + z = two) : x + y = four := by", "theorem implication_two (x y : MyNat) (h : zero + x = zero + y + two) : x = y + two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : x + one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by", "theorem implication_six (x y : MyNat) : x + one = y + one → x = y := by"]}
{"id": 15, "name": "zero_ne_one", "statement": "theorem zero_ne_one : (zero : MyNat) ≠ one := by", "proof": "  intro h\n  rw [one_eq_succ_zero] at h\n  apply zero_ne_succ at h\n  exact h", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem implication_one (x y z : MyNat) (h1 : x + y = four) (h2 : three * x + z = two) : x + y = four := by", "theorem implication_two (x y : MyNat) (h : zero + x = zero + y + two) : x = y + two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : x + one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by", "theorem implication_six (x y : MyNat) : x + one = y + one → x = y := by", "theorem implication_seven (x y : MyNat) (h1 : x = y) (h2 : x ≠ y) : False := by"]}
{"id": 16, "name": "one_ne_zero", "statement": "theorem one_ne_zero : (one : MyNat) ≠ zero := by", "proof": "  symm\n  exact zero_ne_one", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem implication_one (x y z : MyNat) (h1 : x + y = four) (h2 : three * x + z = two) : x + y = four := by", "theorem implication_two (x y : MyNat) (h : zero + x = zero + y + two) : x = y + two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : x + one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by", "theorem implication_six (x y : MyNat) : x + one = y + one → x = y := by", "theorem implication_seven (x y : MyNat) (h1 : x = y) (h2 : x ≠ y) : False := by", "theorem zero_ne_one : (zero : MyNat) ≠ one := by"]}
{"id": 17, "name": "two_plus_two_ne_five", "statement": "theorem two_plus_two_ne_five : succ (succ zero) + succ (succ zero) ≠ succ (succ (succ (succ (succ zero)))) := by", "proof": "  intro h\n  rw [add_succ, add_succ, add_zero] at h\n  repeat apply succ_inj at h\n  apply zero_ne_succ at h\n  exact h", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem implication_one (x y z : MyNat) (h1 : x + y = four) (h2 : three * x + z = two) : x + y = four := by", "theorem implication_two (x y : MyNat) (h : zero + x = zero + y + two) : x = y + two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : x + one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by", "theorem implication_six (x y : MyNat) : x + one = y + one → x = y := by", "theorem implication_seven (x y : MyNat) (h1 : x = y) (h2 : x ≠ y) : False := by", "theorem zero_ne_one : (zero : MyNat) ≠ one := by", "theorem one_ne_zero : (one : MyNat) ≠ zero := by"]}
{"id": 18, "name": "add_algo_1", "statement": "theorem add_algo_1 (a b c d : MyNat) : a + b + (c + d) = a + c + d + b := by", "proof": "  repeat rw [add_assoc]\n  rw [add_left_comm b c]\n  rw [add_comm b d]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by"]}
{"id": 19, "name": "add_algo_2", "statement": "theorem add_algo_2 (a b c d e f g h : MyNat) : (d + f) + (h + (a + c)) + (g + e + b) = a + b + c + d + e + f + g + h := by", "proof": "  simp only [add_left_comm, add_comm]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_algo_1 (a b c d : MyNat) : a + b + (c + d) = a + c + d + b := by"]}
{"id": 20, "name": "succ_ne_zero", "statement": "theorem succ_ne_zero (a : MyNat) : succ a ≠ zero := by", "proof": "  intro h\n  rw [← is_zero_succ a]\n  rw [h]\n  rw [is_zero_zero]\n  trivial", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_algo_1 (a b c d : MyNat) : a + b + (c + d) = a + c + d + b := by", "theorem add_algo_2 (a b c d e f g h : MyNat) : (d + f) + (h + (a + c)) + (g + e + b) = a + b + c + d + e + f + g + h := by"]}
{"id": 21, "name": "succ_ne_succ", "statement": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := by", "proof": "  contrapose! h\n  apply succ_inj at h\n  exact h", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_algo_1 (a b c d : MyNat) : a + b + (c + d) = a + c + d + b := by", "theorem add_algo_2 (a b c d e f g h : MyNat) : (d + f) + (h + (a + c)) + (g + e + b) = a + b + c + d + e + f + g + h := by", "theorem succ_ne_zero (a : MyNat) : succ a ≠ zero := by"]}
{"id": 22, "name": "mul_one", "statement": "theorem mul_one (m : MyNat) : m * one = m := by", "proof": "  rw [one_eq_succ_zero]\n  rw [mul_succ]\n  rw [mul_zero]\n  rw [zero_add]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by"]}
{"id": 23, "name": "zero_mul", "statement": "theorem zero_mul (m : MyNat) : zero * m = zero := by", "proof": "  induction m with\n  | zero =>\n    rw [mul_zero]\n  | succ d ih =>\n    rw [mul_succ, ih, zero_add]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem mul_one (m : MyNat) : m * one = m := by"]}
{"id": 24, "name": "succ_mul", "statement": "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "proof": "  induction b with\n  | zero =>\n    rw [mul_zero, mul_zero, add_zero]\n  | succ d hd =>\n    rw [mul_succ, mul_succ, hd, add_succ, add_succ, add_right_comm]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by"]}
{"id": 25, "name": "mul_comm", "statement": "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "proof": "  induction b with\n  | zero =>\n    rw [zero_mul]\n    rw [mul_zero]\n  | succ d hd =>\n    rw [succ_mul]\n    rw [← hd]\n    rw [mul_succ]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by"]}
{"id": 26, "name": "one_mul", "statement": "theorem one_mul (m : MyNat) : one * m = m := by", "proof": "  rw [mul_comm, mul_one]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by"]}
{"id": 27, "name": "two_mul", "statement": "theorem two_mul (m : MyNat) : two * m = m + m := by", "proof": "  rw [two_eq_succ_one, succ_mul, one_mul]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by"]}
{"id": 28, "name": "mul_add", "statement": "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by", "proof": "  induction c with\n  | zero =>\n    rw [add_zero, mul_zero, add_zero]\n  | succ d hd =>\n    rw [add_succ, mul_succ, hd, mul_succ, add_assoc]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by"]}
{"id": 29, "name": "add_mul", "statement": "theorem add_mul (a b c : MyNat) : (a + b) * c = a * c + b * c := by", "proof": "  rw [mul_comm, mul_add]\n  repeat rw [mul_comm c]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by", "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by"]}
{"id": 30, "name": "mul_assoc", "statement": "theorem mul_assoc (a b c : MyNat) : (a * b) * c = a * (b * c)  := by", "proof": "  induction c with\n  | zero =>\n    rw [mul_zero, mul_zero, mul_zero]\n  | succ d ih =>\n    rw [mul_succ, mul_succ, ih, mul_add]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by", "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by", "theorem add_mul (a b c : MyNat) : (a + b) * c = a * c + b * c := by"]}
{"id": 31, "name": "zero_pow_zero", "statement": "theorem zero_pow_zero : (zero : MyNat) ^ zero = one := by", "proof": "  rw [pow_zero]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by", "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by", "theorem add_mul (a b c : MyNat) : (a + b) * c = a * c + b * c := by", "theorem mul_assoc (a b c : MyNat) : (a * b) * c = a * (b * c)  := by"]}
{"id": 32, "name": "zero_pow_succ", "statement": "theorem zero_pow_succ (m : MyNat) : (zero : MyNat) ^ (succ m) = zero := by", "proof": "  rw [pow_succ]\n  rw [mul_zero]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by", "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by", "theorem add_mul (a b c : MyNat) : (a + b) * c = a * c + b * c := by", "theorem mul_assoc (a b c : MyNat) : (a * b) * c = a * (b * c)  := by", "theorem zero_pow_zero : (zero : MyNat) ^ zero = one := by"]}
{"id": 33, "name": "pow_one", "statement": "theorem pow_one (a : MyNat) : a ^ one = a  := by", "proof": "  rw [one_eq_succ_zero]\n  rw [pow_succ]\n  rw [pow_zero]\n  rw [one_mul]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by", "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by", "theorem add_mul (a b c : MyNat) : (a + b) * c = a * c + b * c := by", "theorem mul_assoc (a b c : MyNat) : (a * b) * c = a * (b * c)  := by", "theorem zero_pow_zero : (zero : MyNat) ^ zero = one := by", "theorem zero_pow_succ (m : MyNat) : (zero : MyNat) ^ (succ m) = zero := by"]}
{"id": 34, "name": "one_pow", "statement": "theorem one_pow (m : MyNat) : (one : MyNat) ^ m = one := by", "proof": "  induction m with\n  | zero =>\n    rw [pow_zero]\n  | succ t ht =>\n    rw [pow_succ]\n    rw [ht]\n    rw [one_mul]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by", "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by", "theorem add_mul (a b c : MyNat) : (a + b) * c = a * c + b * c := by", "theorem mul_assoc (a b c : MyNat) : (a * b) * c = a * (b * c)  := by", "theorem zero_pow_zero : (zero : MyNat) ^ zero = one := by", "theorem zero_pow_succ (m : MyNat) : (zero : MyNat) ^ (succ m) = zero := by", "theorem pow_one (a : MyNat) : a ^ one = a  := by"]}
{"id": 35, "name": "pow_two", "statement": "theorem pow_two (a : MyNat) : a ^ two = a * a := by", "proof": "  rw [two_eq_succ_one]\n  rw [pow_succ]\n  rw [pow_one]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by", "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by", "theorem add_mul (a b c : MyNat) : (a + b) * c = a * c + b * c := by", "theorem mul_assoc (a b c : MyNat) : (a * b) * c = a * (b * c)  := by", "theorem zero_pow_zero : (zero : MyNat) ^ zero = one := by", "theorem zero_pow_succ (m : MyNat) : (zero : MyNat) ^ (succ m) = zero := by", "theorem pow_one (a : MyNat) : a ^ one = a  := by", "theorem one_pow (m : MyNat) : (one : MyNat) ^ m = one := by"]}
{"id": 36, "name": "pow_add", "statement": "theorem pow_add (a m n : MyNat) : a ^ (m + n) = a ^ m * a ^ n := by", "proof": "  induction n with\n  | zero =>\n    rw [add_zero]\n    rw [pow_zero]\n    rw [mul_one]\n  | succ t ht =>\n    rw [add_succ]\n    rw [pow_succ]\n    rw [pow_succ]\n    rw [ht]\n    rw [mul_assoc]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by", "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by", "theorem add_mul (a b c : MyNat) : (a + b) * c = a * c + b * c := by", "theorem mul_assoc (a b c : MyNat) : (a * b) * c = a * (b * c)  := by", "theorem zero_pow_zero : (zero : MyNat) ^ zero = one := by", "theorem zero_pow_succ (m : MyNat) : (zero : MyNat) ^ (succ m) = zero := by", "theorem pow_one (a : MyNat) : a ^ one = a  := by", "theorem one_pow (m : MyNat) : (one : MyNat) ^ m = one := by", "theorem pow_two (a : MyNat) : a ^ two = a * a := by"]}
{"id": 37, "name": "mul_pow", "statement": "theorem mul_pow (a b n : MyNat) : (a * b) ^ n = a ^ n * b ^ n := by", "proof": "  induction n with\n  | zero =>\n    repeat rw [pow_zero]\n    rw [one_mul]\n  | succ t ht =>\n    repeat rw [pow_succ]\n    rw [ht]\n    rw [mul_assoc]\n    rw [mul_comm (b ^ t) (a * b)]\n    rw [mul_comm (b ^ t) b]\n    repeat rw [← mul_assoc]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by", "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by", "theorem add_mul (a b c : MyNat) : (a + b) * c = a * c + b * c := by", "theorem mul_assoc (a b c : MyNat) : (a * b) * c = a * (b * c)  := by", "theorem zero_pow_zero : (zero : MyNat) ^ zero = one := by", "theorem zero_pow_succ (m : MyNat) : (zero : MyNat) ^ (succ m) = zero := by", "theorem pow_one (a : MyNat) : a ^ one = a  := by", "theorem one_pow (m : MyNat) : (one : MyNat) ^ m = one := by", "theorem pow_two (a : MyNat) : a ^ two = a * a := by", "theorem pow_add (a m n : MyNat) : a ^ (m + n) = a ^ m * a ^ n := by"]}
{"id": 38, "name": "pow_pow", "statement": "theorem pow_pow (a m n : MyNat) : (a ^ m) ^ n = a ^ (m * n) := by", "proof": "  induction n with\n  | zero =>\n    rw [mul_zero]\n    rw [pow_zero]\n    rw [pow_zero]\n  | succ t ht =>\n    rw [pow_succ]\n    rw [ht]\n    rw [mul_succ]\n    rw [pow_add]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by", "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by", "theorem add_mul (a b c : MyNat) : (a + b) * c = a * c + b * c := by", "theorem mul_assoc (a b c : MyNat) : (a * b) * c = a * (b * c)  := by", "theorem zero_pow_zero : (zero : MyNat) ^ zero = one := by", "theorem zero_pow_succ (m : MyNat) : (zero : MyNat) ^ (succ m) = zero := by", "theorem pow_one (a : MyNat) : a ^ one = a  := by", "theorem one_pow (m : MyNat) : (one : MyNat) ^ m = one := by", "theorem pow_two (a : MyNat) : a ^ two = a * a := by", "theorem pow_add (a m n : MyNat) : a ^ (m + n) = a ^ m * a ^ n := by", "theorem mul_pow (a b n : MyNat) : (a * b) ^ n = a ^ n * b ^ n := by"]}
{"id": 39, "name": "add_sq", "statement": "theorem add_sq (a b : MyNat) : (a + b) ^ two = a ^ two + b ^ two + two * a * b := by", "proof": "  rw [pow_two, pow_two, pow_two]\n  rw [add_right_comm]\n  rw [mul_add, add_mul, add_mul]\n  rw [two_mul, add_mul]\n  rw [mul_comm b a]\n  rw [← add_assoc, ← add_assoc]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by", "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by", "theorem add_mul (a b c : MyNat) : (a + b) * c = a * c + b * c := by", "theorem mul_assoc (a b c : MyNat) : (a * b) * c = a * (b * c)  := by", "theorem zero_pow_zero : (zero : MyNat) ^ zero = one := by", "theorem zero_pow_succ (m : MyNat) : (zero : MyNat) ^ (succ m) = zero := by", "theorem pow_one (a : MyNat) : a ^ one = a  := by", "theorem one_pow (m : MyNat) : (one : MyNat) ^ m = one := by", "theorem pow_two (a : MyNat) : a ^ two = a * a := by", "theorem pow_add (a m n : MyNat) : a ^ (m + n) = a ^ m * a ^ n := by", "theorem mul_pow (a b n : MyNat) : (a * b) ^ n = a ^ n * b ^ n := by", "theorem pow_pow (a m n : MyNat) : (a ^ m) ^ n = a ^ (m * n) := by"]}
{"id": 40, "name": "add_right_cancel", "statement": "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "proof": "  induction n with\n  | zero =>\n    intro h\n    rw [add_zero, add_zero] at h\n    exact h\n  | succ d ih =>\n    intro h\n    rw [add_succ, add_succ] at h\n    apply succ_inj at h\n    apply ih\n    exact h", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by"]}
{"id": 41, "name": "add_left_cancel", "statement": "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "proof": "  repeat rw [add_comm n]\n  intro h\n  apply add_right_cancel at h\n  exact h", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by"]}
{"id": 42, "name": "add_left_eq_self", "statement": "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "proof": "  intro h\n  nth_rewrite 2 [← zero_add y] at h\n  apply add_right_cancel at h\n  exact h", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by"]}
{"id": 43, "name": "add_right_eq_self", "statement": "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "proof": "  intro h\n  nth_rewrite 2 [← zero_add x] at h\n  nth_rewrite 2 [add_comm] at h\n  apply add_left_cancel at h\n  exact h", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by"]}
{"id": 44, "name": "add_right_eq_zero", "statement": "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "proof": "  induction b with\n  | zero =>\n    intro h\n    rw [add_zero] at h\n    exact h\n  | succ d ih =>\n    intro h\n    rw [add_succ] at h\n    symm at h\n    apply zero_ne_succ at h\n    cases h", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by"]}
{"id": 45, "name": "add_left_eq_zero", "statement": "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "proof": "  rw [add_comm]\n  exact add_right_eq_zero b a", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by"]}
{"id": 46, "name": "le_refl", "statement": "theorem le_refl (x : MyNat) : x ≤ x := by", "proof": "  use zero\n  rw [add_zero]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by"]}
{"id": 47, "name": "zero_le", "statement": "theorem zero_le (x : MyNat) : zero ≤ x := by", "proof": "  use x\n  rw [zero_add]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by"]}
{"id": 48, "name": "le_succ_self", "statement": "theorem le_succ_self (x : MyNat) : x ≤ succ x := by", "proof": "  use one\n  rw [one_eq_succ_zero]\n  rw [add_succ]\n  rw [add_zero]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by"]}
{"id": 49, "name": "le_trans", "statement": "theorem le_trans (x y z : MyNat) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by", "proof": "  cases hxy with\n  | intro a ha =>\n    cases hyz with\n    | intro b hb =>\n      apply Exists.intro (a + b)\n      rw [hb, ha]\n      rw [add_assoc]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by", "theorem le_succ_self (x : MyNat) : x ≤ succ x := by"]}
{"id": 50, "name": "le_zero", "statement": "theorem le_zero (x : MyNat) (hx : x ≤ zero) : x = zero := by", "proof": "  cases hx with\n  | intro a ha =>\n    symm at ha\n    apply add_right_eq_zero at ha\n    exact ha", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by", "theorem le_succ_self (x : MyNat) : x ≤ succ x := by", "theorem le_trans (x y z : MyNat) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by"]}
{"id": 51, "name": "le_antisymm", "statement": "theorem le_antisymm (x y : MyNat) (hxy : x ≤ y) (hyx : y ≤ x) : x = y := by", "proof": "  cases hxy with\n  | intro a ha =>\n    cases hyx with\n    | intro b hb =>\n      rw [ha]\n      rw [ha, add_assoc] at hb\n      symm at hb\n      apply add_right_eq_self at hb\n      apply add_right_eq_zero at hb\n      rw [hb, add_zero]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by", "theorem le_succ_self (x : MyNat) : x ≤ succ x := by", "theorem le_trans (x y z : MyNat) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by", "theorem le_zero (x : MyNat) (hx : x ≤ zero) : x = zero := by"]}
{"id": 52, "name": "or_symm", "statement": "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "proof": "  cases h with\n  | inl hx =>\n    right\n    rw [hx]\n  | inr hy =>\n    left\n    rw [hy]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by", "theorem le_succ_self (x : MyNat) : x ≤ succ x := by", "theorem le_trans (x y z : MyNat) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by", "theorem le_zero (x : MyNat) (hx : x ≤ zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : x ≤ y) (hyx : y ≤ x) : x = y := by"]}
{"id": 53, "name": "le_total", "statement": "theorem le_total (x y : MyNat) : x ≤ y ∨ y ≤ x := by", "proof": "  induction y with\n  | zero =>\n    right\n    exact zero_le x\n  | succ d hd =>\n    cases hd with\n    | inl h1 =>\n      left\n      cases h1 with\n      | intro e h1 =>\n        rw [h1]\n        use e + one\n        rw [succ_eq_add_one, add_assoc]\n    | inr h2 =>\n      cases h2 with\n      | intro e he =>\n        cases e with\n        | zero =>\n          rw [he]\n          left\n          rw [add_zero]\n          use one\n          exact succ_eq_add_one d\n        | succ a =>\n          right\n          use a\n          rw [add_succ] at he\n          rw [succ_add]\n          exact he", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by", "theorem le_succ_self (x : MyNat) : x ≤ succ x := by", "theorem le_trans (x y z : MyNat) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by", "theorem le_zero (x : MyNat) (hx : x ≤ zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : x ≤ y) (hyx : y ≤ x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by"]}
{"id": 54, "name": "succ_le_succ", "statement": "theorem succ_le_succ (x y : MyNat) (hx : succ x ≤ succ y) : x ≤ y := by", "proof": "  cases hx with\n  | intro d hd =>\n    use d\n    rw [succ_add] at hd\n    apply succ_inj at hd\n    exact hd", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by", "theorem le_succ_self (x : MyNat) : x ≤ succ x := by", "theorem le_trans (x y z : MyNat) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by", "theorem le_zero (x : MyNat) (hx : x ≤ zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : x ≤ y) (hyx : y ≤ x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : x ≤ y ∨ y ≤ x := by"]}
{"id": 55, "name": "le_one", "statement": "theorem le_one (x : MyNat) (hx : x ≤ one) : x = zero ∨ x = one := by", "proof": "  induction x with\n  | zero =>\n    left\n    rfl\n  | succ d hd =>\n    right\n    rw[one_eq_succ_zero] at hx\n    apply succ_le_succ at hx\n    apply le_zero at hx\n    rw [hx]\n    rfl", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by", "theorem le_succ_self (x : MyNat) : x ≤ succ x := by", "theorem le_trans (x y z : MyNat) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by", "theorem le_zero (x : MyNat) (hx : x ≤ zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : x ≤ y) (hyx : y ≤ x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : x ≤ y ∨ y ≤ x := by", "theorem succ_le_succ (x y : MyNat) (hx : succ x ≤ succ y) : x ≤ y := by"]}
{"id": 56, "name": "le_two", "statement": "theorem le_two (x : MyNat) (hx : x ≤ two) : x = zero ∨ x = one ∨ x = two := by", "proof": "  cases x with\n  | zero =>\n    left\n    rfl\n  | succ y =>\n    cases y with\n    | zero =>\n      right\n      left\n      rw [one_eq_succ_zero]\n    | succ z =>\n      rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢\n      apply succ_le_succ at hx\n      apply succ_le_succ at hx\n      apply le_zero at hx\n      rw [hx]\n      right\n      right\n      rfl", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by", "theorem le_succ_self (x : MyNat) : x ≤ succ x := by", "theorem le_trans (x y z : MyNat) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by", "theorem le_zero (x : MyNat) (hx : x ≤ zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : x ≤ y) (hyx : y ≤ x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : x ≤ y ∨ y ≤ x := by", "theorem succ_le_succ (x y : MyNat) (hx : succ x ≤ succ y) : x ≤ y := by", "theorem le_one (x : MyNat) (hx : x ≤ one) : x = zero ∨ x = one := by"]}
{"id": 57, "name": "one_add_le_self", "statement": "theorem one_add_le_self (x : MyNat) : x ≤ one + x := by", "proof": "  use one\n  rw [add_comm]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by", "theorem le_succ_self (x : MyNat) : x ≤ succ x := by", "theorem le_trans (x y z : MyNat) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by", "theorem le_zero (x : MyNat) (hx : x ≤ zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : x ≤ y) (hyx : y ≤ x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : x ≤ y ∨ y ≤ x := by", "theorem succ_le_succ (x y : MyNat) (hx : succ x ≤ succ y) : x ≤ y := by", "theorem le_one (x : MyNat) (hx : x ≤ one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : x ≤ two) : x = zero ∨ x = one ∨ x = two := by"]}
{"id": 58, "name": "reflexive", "statement": "theorem reflexive (x : MyNat) : x ≤  x := by", "proof": "  use zero\n  rw [add_zero]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by", "theorem le_succ_self (x : MyNat) : x ≤ succ x := by", "theorem le_trans (x y z : MyNat) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by", "theorem le_zero (x : MyNat) (hx : x ≤ zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : x ≤ y) (hyx : y ≤ x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : x ≤ y ∨ y ≤ x := by", "theorem succ_le_succ (x y : MyNat) (hx : succ x ≤ succ y) : x ≤ y := by", "theorem le_one (x : MyNat) (hx : x ≤ one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : x ≤ two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : x ≤ one + x := by"]}
{"id": 59, "name": "le_succ", "statement": "theorem le_succ (a b : MyNat) : a ≤ b → a ≤ (succ b) := by", "proof": "  intro h\n  cases h with\n  | intro c hc =>\n    use succ c\n    rw [hc]\n    rw [add_succ]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by", "theorem le_succ_self (x : MyNat) : x ≤ succ x := by", "theorem le_trans (x y z : MyNat) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by", "theorem le_zero (x : MyNat) (hx : x ≤ zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : x ≤ y) (hyx : y ≤ x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : x ≤ y ∨ y ≤ x := by", "theorem succ_le_succ (x y : MyNat) (hx : succ x ≤ succ y) : x ≤ y := by", "theorem le_one (x : MyNat) (hx : x ≤ one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : x ≤ two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : x ≤ one + x := by", "theorem reflexive (x : MyNat) : x ≤  x := by"]}
{"id": 60, "name": "mul_le_mul_right", "statement": "theorem mul_le_mul_right (a b t : MyNat) (h : a ≤ b) : a * t ≤ b * t := by", "proof": "  cases h with\n  |intro d hd =>\n    use d * t\n    rw [hd, add_mul]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by", "theorem le_succ_self (x : MyNat) : x ≤ succ x := by", "theorem le_trans (x y z : MyNat) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by", "theorem le_zero (x : MyNat) (hx : x ≤ zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : x ≤ y) (hyx : y ≤ x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : x ≤ y ∨ y ≤ x := by", "theorem succ_le_succ (x y : MyNat) (hx : succ x ≤ succ y) : x ≤ y := by", "theorem le_one (x : MyNat) (hx : x ≤ one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : x ≤ two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : x ≤ one + x := by", "theorem reflexive (x : MyNat) : x ≤  x := by", "theorem le_succ (a b : MyNat) : a ≤ b → a ≤ (succ b) := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by", "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by", "theorem add_mul (a b c : MyNat) : (a + b) * c = a * c + b * c := by", "theorem mul_assoc (a b c : MyNat) : (a * b) * c = a * (b * c)  := by"]}
{"id": 61, "name": "mul_left_ne_zero", "statement": "theorem mul_left_ne_zero (a b : MyNat) (h : a * b ≠ zero) : b ≠ zero := by", "proof": "  intro hb\n  apply h\n  rw [hb, mul_zero]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by", "theorem le_succ_self (x : MyNat) : x ≤ succ x := by", "theorem le_trans (x y z : MyNat) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by", "theorem le_zero (x : MyNat) (hx : x ≤ zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : x ≤ y) (hyx : y ≤ x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : x ≤ y ∨ y ≤ x := by", "theorem succ_le_succ (x y : MyNat) (hx : succ x ≤ succ y) : x ≤ y := by", "theorem le_one (x : MyNat) (hx : x ≤ one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : x ≤ two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : x ≤ one + x := by", "theorem reflexive (x : MyNat) : x ≤  x := by", "theorem le_succ (a b : MyNat) : a ≤ b → a ≤ (succ b) := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by", "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by", "theorem add_mul (a b c : MyNat) : (a + b) * c = a * c + b * c := by", "theorem mul_assoc (a b c : MyNat) : (a * b) * c = a * (b * c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : a ≤ b) : a * t ≤ b * t := by"]}
{"id": 62, "name": "eq_succ_of_ne_zero", "statement": "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "proof": "  induction a with\n  | zero => contradiction\n  | succ d =>\n    use d", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by", "theorem le_succ_self (x : MyNat) : x ≤ succ x := by", "theorem le_trans (x y z : MyNat) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by", "theorem le_zero (x : MyNat) (hx : x ≤ zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : x ≤ y) (hyx : y ≤ x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : x ≤ y ∨ y ≤ x := by", "theorem succ_le_succ (x y : MyNat) (hx : succ x ≤ succ y) : x ≤ y := by", "theorem le_one (x : MyNat) (hx : x ≤ one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : x ≤ two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : x ≤ one + x := by", "theorem reflexive (x : MyNat) : x ≤  x := by", "theorem le_succ (a b : MyNat) : a ≤ b → a ≤ (succ b) := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by", "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by", "theorem add_mul (a b c : MyNat) : (a + b) * c = a * c + b * c := by", "theorem mul_assoc (a b c : MyNat) : (a * b) * c = a * (b * c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : a ≤ b) : a * t ≤ b * t := by", "theorem mul_left_ne_zero (a b : MyNat) (h : a * b ≠ zero) : b ≠ zero := by"]}
{"id": 63, "name": "one_le_of_ne_zero", "statement": "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : one ≤ a := by", "proof": "  apply eq_succ_of_ne_zero at ha\n  cases ha with\n  |intro n hn =>\n    use n\n    rw [hn, succ_eq_add_one, add_comm]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by", "theorem le_succ_self (x : MyNat) : x ≤ succ x := by", "theorem le_trans (x y z : MyNat) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by", "theorem le_zero (x : MyNat) (hx : x ≤ zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : x ≤ y) (hyx : y ≤ x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : x ≤ y ∨ y ≤ x := by", "theorem succ_le_succ (x y : MyNat) (hx : succ x ≤ succ y) : x ≤ y := by", "theorem le_one (x : MyNat) (hx : x ≤ one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : x ≤ two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : x ≤ one + x := by", "theorem reflexive (x : MyNat) : x ≤  x := by", "theorem le_succ (a b : MyNat) : a ≤ b → a ≤ (succ b) := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by", "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by", "theorem add_mul (a b c : MyNat) : (a + b) * c = a * c + b * c := by", "theorem mul_assoc (a b c : MyNat) : (a * b) * c = a * (b * c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : a ≤ b) : a * t ≤ b * t := by", "theorem mul_left_ne_zero (a b : MyNat) (h : a * b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by"]}
{"id": 64, "name": "le_mul_right", "statement": "theorem le_mul_right (a b : MyNat) (h : a * b ≠ zero) : a ≤ a * b := by", "proof": "  apply mul_left_ne_zero at h\n  apply one_le_of_ne_zero at h\n  apply mul_le_mul_right one b a at h\n  rw [one_mul, mul_comm] at h\n  exact h", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by", "theorem le_succ_self (x : MyNat) : x ≤ succ x := by", "theorem le_trans (x y z : MyNat) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by", "theorem le_zero (x : MyNat) (hx : x ≤ zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : x ≤ y) (hyx : y ≤ x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : x ≤ y ∨ y ≤ x := by", "theorem succ_le_succ (x y : MyNat) (hx : succ x ≤ succ y) : x ≤ y := by", "theorem le_one (x : MyNat) (hx : x ≤ one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : x ≤ two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : x ≤ one + x := by", "theorem reflexive (x : MyNat) : x ≤  x := by", "theorem le_succ (a b : MyNat) : a ≤ b → a ≤ (succ b) := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by", "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by", "theorem add_mul (a b c : MyNat) : (a + b) * c = a * c + b * c := by", "theorem mul_assoc (a b c : MyNat) : (a * b) * c = a * (b * c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : a ≤ b) : a * t ≤ b * t := by", "theorem mul_left_ne_zero (a b : MyNat) (h : a * b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : one ≤ a := by"]}
{"id": 65, "name": "mul_right_eq_one", "statement": "theorem mul_right_eq_one (x y : MyNat) (h : x * y = one) : x = one := by", "proof": "  have h2 : x * y ≠ zero := by\n    rw [h, one_eq_succ_zero]\n    symm\n    apply zero_ne_succ\n  apply le_mul_right at h2\n  rw [h] at h2\n  apply le_one at h2\n  cases h2 with\n  |inl h0 =>\n    rw [h0] at h\n    rw [zero_mul] at h\n    cases h\n  |inr h1 =>\n    exact h1", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by", "theorem le_succ_self (x : MyNat) : x ≤ succ x := by", "theorem le_trans (x y z : MyNat) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by", "theorem le_zero (x : MyNat) (hx : x ≤ zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : x ≤ y) (hyx : y ≤ x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : x ≤ y ∨ y ≤ x := by", "theorem succ_le_succ (x y : MyNat) (hx : succ x ≤ succ y) : x ≤ y := by", "theorem le_one (x : MyNat) (hx : x ≤ one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : x ≤ two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : x ≤ one + x := by", "theorem reflexive (x : MyNat) : x ≤  x := by", "theorem le_succ (a b : MyNat) : a ≤ b → a ≤ (succ b) := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by", "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by", "theorem add_mul (a b c : MyNat) : (a + b) * c = a * c + b * c := by", "theorem mul_assoc (a b c : MyNat) : (a * b) * c = a * (b * c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : a ≤ b) : a * t ≤ b * t := by", "theorem mul_left_ne_zero (a b : MyNat) (h : a * b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : one ≤ a := by", "theorem le_mul_right (a b : MyNat) (h : a * b ≠ zero) : a ≤ a * b := by"]}
{"id": 66, "name": "mul_ne_zero", "statement": "theorem mul_ne_zero (a b : MyNat) (ha : a ≠ zero) (hb : b ≠ zero) : a * b ≠ zero := by", "proof": "  apply eq_succ_of_ne_zero at ha\n  apply eq_succ_of_ne_zero at hb\n  cases ha with\n  |intro c hc =>\n    cases hb with\n    |intro d hd =>\n      rw [hc, hd]\n      rw [mul_succ, add_succ]\n      symm\n      apply zero_ne_succ", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by", "theorem le_succ_self (x : MyNat) : x ≤ succ x := by", "theorem le_trans (x y z : MyNat) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by", "theorem le_zero (x : MyNat) (hx : x ≤ zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : x ≤ y) (hyx : y ≤ x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : x ≤ y ∨ y ≤ x := by", "theorem succ_le_succ (x y : MyNat) (hx : succ x ≤ succ y) : x ≤ y := by", "theorem le_one (x : MyNat) (hx : x ≤ one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : x ≤ two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : x ≤ one + x := by", "theorem reflexive (x : MyNat) : x ≤  x := by", "theorem le_succ (a b : MyNat) : a ≤ b → a ≤ (succ b) := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by", "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by", "theorem add_mul (a b c : MyNat) : (a + b) * c = a * c + b * c := by", "theorem mul_assoc (a b c : MyNat) : (a * b) * c = a * (b * c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : a ≤ b) : a * t ≤ b * t := by", "theorem mul_left_ne_zero (a b : MyNat) (h : a * b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : one ≤ a := by", "theorem le_mul_right (a b : MyNat) (h : a * b ≠ zero) : a ≤ a * b := by", "theorem mul_right_eq_one (x y : MyNat) (h : x * y = one) : x = one := by"]}
{"id": 67, "name": "mul_eq_zero", "statement": "theorem mul_eq_zero (a b : MyNat) (h : a * b = zero) : a = zero ∨ b = zero := by", "proof": "  have h2 := mul_ne_zero a b\n  tauto", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by", "theorem le_succ_self (x : MyNat) : x ≤ succ x := by", "theorem le_trans (x y z : MyNat) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by", "theorem le_zero (x : MyNat) (hx : x ≤ zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : x ≤ y) (hyx : y ≤ x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : x ≤ y ∨ y ≤ x := by", "theorem succ_le_succ (x y : MyNat) (hx : succ x ≤ succ y) : x ≤ y := by", "theorem le_one (x : MyNat) (hx : x ≤ one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : x ≤ two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : x ≤ one + x := by", "theorem reflexive (x : MyNat) : x ≤  x := by", "theorem le_succ (a b : MyNat) : a ≤ b → a ≤ (succ b) := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by", "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by", "theorem add_mul (a b c : MyNat) : (a + b) * c = a * c + b * c := by", "theorem mul_assoc (a b c : MyNat) : (a * b) * c = a * (b * c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : a ≤ b) : a * t ≤ b * t := by", "theorem mul_left_ne_zero (a b : MyNat) (h : a * b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : one ≤ a := by", "theorem le_mul_right (a b : MyNat) (h : a * b ≠ zero) : a ≤ a * b := by", "theorem mul_right_eq_one (x y : MyNat) (h : x * y = one) : x = one := by", "theorem mul_ne_zero (a b : MyNat) (ha : a ≠ zero) (hb : b ≠ zero) : a * b ≠ zero := by"]}
{"id": 68, "name": "mul_left_cancel", "statement": "theorem mul_left_cancel (a b c : MyNat) (ha : a ≠ zero) (h : a * b = a * c) : b = c := by", "proof": "  revert c\n  induction b with\n  | zero =>\n    intro c h\n    rw [mul_zero] at h\n    symm at h\n    apply mul_eq_zero at h\n    cases h with\n    |inl ha0 => contradiction\n    |inr hc0 =>\n      rw [hc0]\n  | succ d ih =>\n    intro c h\n    induction c with\n    | zero =>\n      rw [mul_zero] at h\n      apply mul_eq_zero at h\n      cases h with\n      |inl ha0 => contradiction\n      |inr hc0 => contradiction\n    | succ e he =>\n      rw [mul_succ, mul_succ] at h\n      apply add_right_cancel at h\n      apply ih at h\n      rw [h]", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by", "theorem le_succ_self (x : MyNat) : x ≤ succ x := by", "theorem le_trans (x y z : MyNat) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by", "theorem le_zero (x : MyNat) (hx : x ≤ zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : x ≤ y) (hyx : y ≤ x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : x ≤ y ∨ y ≤ x := by", "theorem succ_le_succ (x y : MyNat) (hx : succ x ≤ succ y) : x ≤ y := by", "theorem le_one (x : MyNat) (hx : x ≤ one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : x ≤ two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : x ≤ one + x := by", "theorem reflexive (x : MyNat) : x ≤  x := by", "theorem le_succ (a b : MyNat) : a ≤ b → a ≤ (succ b) := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by", "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by", "theorem add_mul (a b c : MyNat) : (a + b) * c = a * c + b * c := by", "theorem mul_assoc (a b c : MyNat) : (a * b) * c = a * (b * c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : a ≤ b) : a * t ≤ b * t := by", "theorem mul_left_ne_zero (a b : MyNat) (h : a * b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : one ≤ a := by", "theorem le_mul_right (a b : MyNat) (h : a * b ≠ zero) : a ≤ a * b := by", "theorem mul_right_eq_one (x y : MyNat) (h : x * y = one) : x = one := by", "theorem mul_ne_zero (a b : MyNat) (ha : a ≠ zero) (hb : b ≠ zero) : a * b ≠ zero := by", "theorem mul_eq_zero (a b : MyNat) (h : a * b = zero) : a = zero ∨ b = zero := by"]}
{"id": 69, "name": "mul_right_eq_self", "statement": "theorem mul_right_eq_self (a b : MyNat) (ha : a ≠ zero) (h : a * b = a) : b = one := by", "proof": "  nth_rewrite 2 [← mul_one a] at h\n  exact mul_left_cancel a b one ha h", "known_theorems": ["theorem zero_add (n : MyNat) : .zero + n = n := by", "theorem succ_add (a b : MyNat) : succ a + b = succ (a + b)  := by", "theorem add_comm (a b : MyNat) : a + b = b + a := by", "theorem add_assoc (a b c : MyNat) : a + b + c = a + (b + c) := by", "theorem add_right_comm (a b c : MyNat) : a + b + c = a + c + b := by", "theorem add_left_comm (a b c : MyNat) : a + (b + c) = b + (a + c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = n + one := by", "theorem add_right_cancel (a b n : MyNat) : a + n = b + n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : n + a = n + b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : x + y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : x + y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : a + b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : a + b = zero → b = zero := by", "theorem le_refl (x : MyNat) : x ≤ x := by", "theorem zero_le (x : MyNat) : zero ≤ x := by", "theorem le_succ_self (x : MyNat) : x ≤ succ x := by", "theorem le_trans (x y z : MyNat) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z := by", "theorem le_zero (x : MyNat) (hx : x ≤ zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : x ≤ y) (hyx : y ≤ x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : x ≤ y ∨ y ≤ x := by", "theorem succ_le_succ (x y : MyNat) (hx : succ x ≤ succ y) : x ≤ y := by", "theorem le_one (x : MyNat) (hx : x ≤ one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : x ≤ two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : x ≤ one + x := by", "theorem reflexive (x : MyNat) : x ≤  x := by", "theorem le_succ (a b : MyNat) : a ≤ b → a ≤ (succ b) := by", "theorem mul_one (m : MyNat) : m * one = m := by", "theorem zero_mul (m : MyNat) : zero * m = zero := by", "theorem succ_mul (a b : MyNat) : succ a * b = a * b + b := by", "theorem mul_comm (a b : MyNat) : a * b = b * a := by", "theorem one_mul (m : MyNat) : one * m = m := by", "theorem two_mul (m : MyNat) : two * m = m + m := by", "theorem mul_add (a b c : MyNat) : a * (b + c) = a * b + a * c := by", "theorem add_mul (a b c : MyNat) : (a + b) * c = a * c + b * c := by", "theorem mul_assoc (a b c : MyNat) : (a * b) * c = a * (b * c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : a ≤ b) : a * t ≤ b * t := by", "theorem mul_left_ne_zero (a b : MyNat) (h : a * b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : one ≤ a := by", "theorem le_mul_right (a b : MyNat) (h : a * b ≠ zero) : a ≤ a * b := by", "theorem mul_right_eq_one (x y : MyNat) (h : x * y = one) : x = one := by", "theorem mul_ne_zero (a b : MyNat) (ha : a ≠ zero) (hb : b ≠ zero) : a * b ≠ zero := by", "theorem mul_eq_zero (a b : MyNat) (h : a * b = zero) : a = zero ∨ b = zero := by", "theorem mul_left_cancel (a b c : MyNat) (ha : a ≠ zero) (h : a * b = a * c) : b = c := by"]}
