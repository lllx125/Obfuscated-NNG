{"id": 1, "file": "Addition/L01zero_add.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement zero_add (n : ℕ) : 0 + n = n", "ground_truth": "Hint \"You can start a proof by induction on `n` by typing:\n  `induction n with d hd`.\"\n  induction n with d hd\n  · Hint \"Now you have two goals. Once you proved the first, you will jump to the second one.\n    This first goal is the base case $n = 0$.\n\n    Recall that you can rewrite the proof of any lemma which is visible\n    in your inventory, or of any assumption displayed above the goal,\n    as long as it is of the form `X = Y`.\"\n    Hint (hidden := true) \"try rewriting `add_zero`.\"\n    rw [add_zero]\n    rfl\n  · Hint \"Now for the second goal. Here you have the induction hypothesis\n    `{hd} : 0 + {d} = {d}`, and you need to prove that `0 + succ {d} = succ {d}`.\"\n    Hint (hidden := true) \"Use `add_succ`.\"\n    rw [add_succ]\n    Hint (hidden := true) \"At this point you see the term `0 + {d}`, so you can use the\n    induction hypothesis with `rw [{hd}]`.\"\n    rw [hd]\n    rfl\n\nattribute [simp] zero_add\n\n/--\n## Summary\n\nIf `n : ℕ` is an object, and the goal mentions `n`, then `induction n with d hd`\nattempts to prove the goal by induction on `n`, with the inductive\nvariable in the successor case being `d`, and the inductive hypothesis being `hd`.\n\n### Example:\nIf the goal is\n```\n0 + n = n\n```\n\nthen\n\n`induction n with d hd`\n\nwill turn it into two goals. The first is `0 + 0 = 0`;\nthe second has an assumption `hd : 0 + d = d` and goal\n`0 + succ d = succ d`.\n\nNote that you must prove the first\ngoal before you can access the second one.\n-/"}
{"id": 2, "file": "Addition/L02succ_add.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement succ_add (a b : ℕ) : succ a + b = succ (a + b)", "ground_truth": "Hint (hidden := true) \"You might want to think about whether induction\n  on `a` or `b` is the best idea.\"\n  Branch\n    induction a with _ _\n    Hint \"Induction on `a` will not work here. You are still stuck with an `+ b`.\n    I suggest you delete this line and try a different approach.\"\n    sorry\n  induction b with d hd\n  · rw [add_zero]\n    rw [add_zero]\n    rfl\n  · Hint \"Note that `succ a + {d}` means `(succ a) + {d}`. Put your cursor\n  on any `succ` in the goal or assumptions to see what exactly it's eating.\"\n    rw [add_succ, add_succ, hd]\n    rfl"}
{"id": 3, "file": "Addition/L03add_comm.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement add_comm (a b : ℕ) : a + b = b + a", "ground_truth": "Hint (hidden := true) \"Induction on `a` or `b` -- it's all the same in this one.\"\n  induction b with d hd\n  · rw [add_zero, zero_add]\n    rfl\n  · rw [add_succ, succ_add, hd]\n    rfl\n\n-- Adding this instance to make `ac_rfl` work.\ninstance : Std.Commutative (α := ℕ) (· + ·) := ⟨add_comm⟩"}
{"id": 4, "file": "Addition/L04add_assoc.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement add_assoc (a b c : ℕ) : a + b + c = a + (b + c)", "ground_truth": "Hint \"Remember that when Lean writes `a + b + c`, it means `(a + b) + c`.\n  If you are not sure where the brackets are in an expression, just hover\n  your cursor over it and look at what gets highlighted. For example,\n  hover over both `+` symbols on the left hand side of the goal and\n  you'll see where the invisible brackets are.\"\n  induction c with d hd\n  · rw [add_zero, add_zero]\n    rfl\n  · rw [add_succ, add_succ, hd, add_succ]\n    rfl\n\n-- Adding this instance to make `ac_rfl` work.\ninstance : Std.Associative (α := ℕ) (· + ·) := ⟨add_assoc⟩"}
{"id": 5, "file": "Addition/L05add_right_comm.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement add_right_comm (a b c : ℕ) : a + b + c = a + c + b", "ground_truth": "rw [add_assoc]\n  rw [add_comm b, add_assoc]\n  rfl"}
{"id": 6, "file": "AdvAddition/L01add_right_cancel.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement add_right_cancel (a b n : ℕ) : a + n = b + n → a = b", "ground_truth": "Hint (hidden := true) \"Start with induction on `n`.\"\n  induction n with d hd\n  intro h\n  repeat rw [add_zero] at h\n  exact h\n  intro h\n  repeat rw [add_succ] at h\n  apply succ_inj at h\n  apply hd at h\n  exact h"}
{"id": 7, "file": "AdvAddition/L02add_left_cancel.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement add_left_cancel (a b n : ℕ) : n + a = n + b → a = b", "ground_truth": "repeat rw [add_comm n]\n  intro h\n  apply add_right_cancel at h\n  exact h"}
{"id": 8, "file": "AdvAddition/L03add_left_eq_self.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement add_left_eq_self (x y : ℕ) : x + y = y → x = 0", "ground_truth": "intro h\n  nth_rewrite 2 [← zero_add y] at h\n  apply add_right_cancel at h\n  exact h"}
{"id": 9, "file": "AdvAddition/L04add_right_eq_self.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement add_right_eq_self (x y : ℕ) : x + y = x → y = 0", "ground_truth": "Branch\n    intro h\n    rw [add_comm] at h\n    rw [add_left_eq_self x y] at h\n    · rw [add_zero] at h\n      exact h\n    Hint \"This state is not provable! Did you maybe use `rw [add_left_eq_self] at h`\n    instead of `apply [add_left_eq_self] at h`? You can complare the two in the inventory.\"\n    -- not ideal to have the hint duplicated, but it's not obvious if they'd use `add_comm`\n    -- or not\n    rw [add_comm] at h\n    Hint \"This state is not provable! Did you maybe use `rw [add_left_eq_self] at h`\n    instead of `apply [add_left_eq_self] at h`? You can complare the two in the inventory.\"\n  rw [add_comm]\n  exact add_left_eq_self y x"}
{"id": 10, "file": "AdvAddition/L05add_right_eq_zero.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement add_right_eq_zero (a b : ℕ) : a + b = 0 → a = 0", "ground_truth": "Hint \"Here we want to deal with the cases `b = 0` and `b ≠ 0` separately,\n  so start with `cases b with d`.\"\n  cases b with d\n  intro h\n  rw [add_zero] at h\n  exact h\n  intro h\n  rw [add_succ] at h\n  symm at h\n  apply zero_ne_succ at h\n  cases h"}
{"id": 11, "file": "AdvAddition/L06add_left_eq_zero.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement add_left_eq_zero (a b : ℕ) : a + b = 0 → b = 0", "ground_truth": "rw [add_comm]\n  exact add_right_eq_zero b a"}
{"id": 12, "file": "AdvMultiplication/L01mul_le_mul_right.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement mul_le_mul_right (a b t : ℕ) (h : a ≤ b) : a * t ≤ b * t", "ground_truth": "cases h with d hd\n  use d * t\n  rw [hd, add_mul]\n  rfl"}
{"id": 13, "file": "AdvMultiplication/L02mul_left_ne_zero.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement mul_left_ne_zero (a b : ℕ) (h : a * b ≠ 0) : b ≠ 0", "ground_truth": "Hint \"We want to reduce this to a hypothesis `b = 0` and a goal `a * b = 0`,\n  which is logically equivalent but much easier to prove. Remember that `X ≠ 0`\n  is notation for `X = 0 → False`. Click on `Show more help!` if you need hints.\"\n  Hint (hidden := true) \"Start with `intro hb`.\"\n  intro hb\n  Hint (hidden := true) \"Now `apply h` and you can probably take it from here.\"\n  apply h\n  rw [hb, mul_zero]\n  rfl"}
{"id": 14, "file": "AdvMultiplication/L03eq_succ_of_ne_zero.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement eq_succ_of_ne_zero (a : ℕ) (ha : a ≠ 0) : ∃ n, a = succ n", "ground_truth": "Hint \"Start with `cases a with d` to do a case split on `a = 0` and `a = succ d`.\"\n  cases a with d\n  · Hint \"In the \\\"base case\\\" we have a hypothesis `ha : 0 ≠ 0`, and you can deduce anything\n  from a false statement. The `tauto` tactic will close this goal.\"\n    tauto\n  · use d\n    rfl"}
{"id": 15, "file": "AdvMultiplication/L04one_le_of_ne_zero.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement one_le_of_ne_zero (a : ℕ) (ha : a ≠ 0) : 1 ≤ a", "ground_truth": "Hint (hidden := true) \"Use the previous lemma with `apply eq_succ_of_ne_zero at ha`.\"\n  apply eq_succ_of_ne_zero at ha\n  Hint (hidden := true) \"Now take apart the existence statement with `cases ha with n hn`.\"\n  cases ha with n hn\n  use n\n  rw [hn, succ_eq_add_one, add_comm]\n  rfl"}
{"id": 16, "file": "AdvMultiplication/L05le_mul_right.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement le_mul_right (a b : ℕ) (h : a * b ≠ 0) : a ≤ a * b", "ground_truth": "apply mul_left_ne_zero at h\n  apply one_le_of_ne_zero at h\n  apply mul_le_mul_right 1 b a at h\n  rw [one_mul, mul_comm] at h\n  exact h"}
{"id": 17, "file": "AdvMultiplication/L06mul_right_eq_one.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "lemma `le_one` from `≤` world.\n\nWe'll prove it using a new and very useful tactic called `have`.\n\"\n\nStatement mul_right_eq_one (x y : ℕ) (h : x * y = 1) : x = 1", "ground_truth": "Hint (strict := true) \"We want to use `le_mul_right`, but we need a hypothesis `x * y ≠ 0`\n  which we don't have. Yet. Execute `have h2 : x * y ≠ 0` (you can type `≠` with `\\\\ne`).\n  You'll be asked to\n  prove it, and then you'll have a new hypothesis which you can apply\n  `le_mul_right` to.\"\n  have h2 : x * y ≠ 0\n  rw [h]\n  exact one_ne_zero\n  Hint (hidden := true) \"Now you can `apply le_mul_right at h2`.\"\n  apply le_mul_right at h2\n  Hint (hidden := true) \"Now `rw [{h}] at {h2}` so you can `apply le_one at {h2}`.\"\n  rw [h] at h2\n  apply le_one at h2\n  Hint (hidden := true) \"Now `cases h2 with h0 h1` and deal with the two\n  cases separately.\"\n  cases h2 with h0 h1\n  · rw [h0, zero_mul] at h\n    Hint (hidden := true) \"`tauto` is good enough to solve this goal.\"\n    tauto\n  · exact h1"}
{"id": 18, "file": "AdvMultiplication/L07mul_ne_zero.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement mul_ne_zero (a b : ℕ) (ha : a ≠ 0) (hb : b ≠ 0) : a * b ≠ 0", "ground_truth": "Hint (hidden := true) \"Start with `apply eq_succ_of_ne_zero at ha` and `... at hb`\"\n  apply eq_succ_of_ne_zero at ha\n  apply eq_succ_of_ne_zero at hb\n  cases ha with c hc\n  cases hb with d hd\n  rw [hc, hd]\n  rw [mul_succ, add_succ]\n  symm\n  apply zero_ne_succ"}
{"id": 19, "file": "AdvMultiplication/L08mul_eq_zero.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement mul_eq_zero (a b : ℕ) (h : a * b = 0) : a = 0 ∨ b = 0", "ground_truth": "Hint (hidden := true) \"Start with `have h2 := mul_ne_zero a b`.\"\n  have h2 := mul_ne_zero a b\n  Hint (hidden := true) \"Now the goal can be deduced from `h2` by pure logic, so use the `tauto`\n  tactic.\"\n  tauto"}
{"id": 20, "file": "AdvMultiplication/L09mul_left_cancel.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement mul_left_cancel (a b c : ℕ) (ha : a ≠ 0) (h : a * b = a * c) : b = c", "ground_truth": "Hint \"The way to start this proof is `induction b with d hd generalizing c`.\"\n  induction b with d hd generalizing c\n  · Hint (hidden := true) \"Use `mul_eq_zero` and remember that `tauto` will solve a goal\n  if there are hypotheses `a = 0` and `a ≠ 0`.\"\n    rw [mul_zero] at h\n    symm at h\n    apply mul_eq_zero at h\n    cases h with h1 h2\n    · tauto\n    · rw [h2]\n      rfl\n  · Hint \"The inductive hypothesis `hd` is \\\"For all natural numbers `c`, `a * d = a * c → d = c`\\\".\n    You can `apply` it `at` any hypothesis of the form `a * d = a * ?`.\"\n    Hint (hidden := true) \"Split into cases `c = 0` and `c = succ e` with `cases c with e`.\"\n    cases c with e\n    · rw [mul_succ, mul_zero] at h\n      apply add_left_eq_zero at h\n      tauto\n    · rw [mul_succ, mul_succ] at h\n      apply add_right_cancel at h\n      apply hd at h\n      rw [h]\n      rfl"}
{"id": 21, "file": "AdvMultiplication/L10mul_right_eq_self.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement mul_right_eq_self (a b : ℕ) (ha : a ≠ 0) (h : a * b = a) : b = 1", "ground_truth": "Hint (hidden := true) \"Reduce to the previous lemma with `nth_rewrite 2 [← mul_one a] at h`\"\n  nth_rewrite 2 [← mul_one a] at h\n  Hint (hidden := true) \"You can now `apply mul_left_cancel at h`\"\n  exact mul_left_cancel a b 1 ha h"}
{"id": 22, "file": "Algorithm/L01add_left_comm.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement add_left_comm (a b c : ℕ) : a + (b + c) = b + (a + c)", "ground_truth": "rw [← add_assoc]\n  rw [add_comm a b]\n  rw [add_assoc]\n  rfl"}
{"id": 23, "file": "Algorithm/L02add_algo1.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement (a b c d : ℕ) : a + b + (c + d) = a + c + d + b", "ground_truth": "Hint \"Start with `repeat rw [add_assoc]` to push all the brackets to the right.\"\n  repeat rw [add_assoc]\n  Hint \"Now use `rw [add_left_comm b c]` to switch `b` and `c` on the left\n  hand side.\"\n  rw [add_left_comm b c]\n  Hint \"Finally use a targetted `add_comm` to switch `b` and `d`\"\n  Hint (hidden := true) \"`rw [add_comm b d]`.\"\n  rw [add_comm b d]\n  rfl"}
{"id": 24, "file": "Algorithm/L03add_algo2.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement (a b c d e f g h : ℕ) :\n    (d + f) + (h + (a + c)) + (g + e + b) = a + b + c + d + e + f + g + h", "ground_truth": "Hint \"Solve this level in one line with `simp only [add_left_comm, add_comm]`\"\n  simp only [add_left_comm, add_comm]"}
{"id": 25, "file": "Algorithm/L04add_algo3.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement (a b c d e f g h : ℕ) :\n    (d + f) + (h + (a + c)) + (g + e + b) = a + b + c + d + e + f + g + h", "ground_truth": "simp_add"}
{"id": 26, "file": "Algorithm/L05pred.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement (a b : ℕ) (h : succ a = succ b) : a = b", "ground_truth": "Hint \"Start with `rw [← pred_succ a]` and take it from there.\"\n  rw [← pred_succ a]\n  rw [h]\n  rw [pred_succ]\n  rfl\n\nDisabledTheorem MyNat.succ_inj"}
{"id": 27, "file": "Algorithm/L06is_zero.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement succ_ne_zero (a : ℕ) : succ a ≠ 0", "ground_truth": "Hint \"Start with `intro h` (remembering that `X ≠ Y` is just notation\n  for `X = Y → False`).\"\n  intro h\n  Hint \"We're going to change that `False` into `True`. Start by changing it into\n  `is_zero (succ a)` by executing `rw [← is_zero_succ a]`.\"\n  rw [← is_zero_succ a]\n  Hint \"See if you can take it from here. Look at the new lemmas and tactic\n  available on the right.\"\n  rw [h]\n  rw [is_zero_zero]\n  trivial"}
{"id": 28, "file": "Algorithm/L07succ_ne_succ.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement succ_ne_succ (m n : ℕ) (h : m ≠ n) : succ m ≠ succ n", "ground_truth": "Hint \"Start with `contrapose! h`, to change the goal into its\n  contrapositive, namely a hypothesis of `succ m = succ n` and a goal of `m = n`.\"\n  contrapose! h\n  Hint \"Can you take it from here? (note: if you try `contrapose! h` again, it will\n  take you back to where you started!)\"\n  apply succ_inj at h\n  exact h"}
{"id": 29, "file": "Algorithm/L08decide.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement : (20 : ℕ) + 20 = 40", "ground_truth": "decide"}
{"id": 30, "file": "Algorithm/L09decide2.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement : (2 : ℕ) + 2 ≠ 5", "ground_truth": "decide"}
{"id": 31, "file": "Implication/L01exact.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement (x y z : ℕ) (h1 : x + y = 37) (h2 : 3 * x + z = 42) : x + y = 37", "ground_truth": "Hint \"The goal in this level is one of our hypotheses. Solve the goal by executing `exact h1`.\"\n  exact h1"}
{"id": 32, "file": "Implication/L02exact2.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement (x y : ℕ) (h : 0 + x = 0 + y + 2) : x = y + 2", "ground_truth": "Hint \"You can use `rw [zero_add] at {h}` to rewrite at `{h}` instead\n  of at the goal.\"\n  rw [zero_add] at h\n  Hint (hidden := true) \"Do that again!\n\n  `rw [zero_add] at {h}` tries to fill in\n  the arguments to `zero_add` (finding `{x}`) then it replaces all occurrences of\n  `0 + {x}` it finds. Therefor, it did not rewrite `0 + {y}`, yet.\"\n  rw [zero_add] at h\n  Hint \"Now you could finish with `rw [{h}]` then `rfl`, but `exact {h}`\n  does it in one line.\"\n  exact h"}
{"id": 33, "file": "Implication/L03apply.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement (x y : ℕ) (h1 : x = 37) (h2 : x = 37 → y = 42) : y = 42", "ground_truth": "Hint \"Start with `apply h2 at h1`. This will change `h1` to `y = 42`.\"\n  apply h2 at h1\n  Hint \"Now finish using the `exact` tactic.\"\n  exact h1"}
{"id": 34, "file": "Implication/L04succ_inj.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement (x : ℕ) (h : x + 1 = 4) : x = 3", "ground_truth": "Hint \"Let's first get `h` into the form `succ x = succ 3` so we can\n  apply `succ_inj`. First execute `rw [four_eq_succ_three] at h`\n  to change the 4 on the right hand side.\"\n  rw [four_eq_succ_three] at h\n  Hint \"Now rewrite `succ_eq_add_one` backwards at `h`\n  to get the right hand side.\"\n  Hint \"You can put a `←` in front of any theorem provided to `rw` to rewrite\n  the other way around. Look at the docs for `rw` for an explanation. Type `←` with `\\\\l`.\"\n  Hint (hidden := true) \"Concretely: `rw [← succ_eq_add_one] at h`.\"\n  rw [←succ_eq_add_one] at h\n  Hint \"Now let's `apply` our new theorem. Execute `apply succ_inj at h`\n  to change `h` to a proof of `x = 3`.\"\n  apply succ_inj at h\n  Hint \"Now finish in one line.\"\n  Hint (hidden := true) \"And now we've deduced what we wanted to prove: the goal is one of our assumptions.\n  Finish the level with `exact h`.\"\n  exact h"}
{"id": 35, "file": "Implication/L05succ_inj2.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement (x : ℕ) (h : x + 1 = 4) : x = 3", "ground_truth": "Hint \"Start with `apply succ_inj` to apply `succ_inj` to the *goal*.\"\n  apply succ_inj\n  Hint \"Applying a proof of $P\\\\implies Q$ to the *goal* changes $Q$ to $P$.\n  Now try `rw [succ_eq_add_one]` to make the goal more like the hypothesis.\"\n  rw [succ_eq_add_one]\n  Hint \"Now rewrite `four_eq_succ_three` backwards to make the goal\n  equal to the hypothesis.\"\n  rw [← four_eq_succ_three]\n  Hint \"You can now finish with `exact h`.\"\n  exact h"}
{"id": 36, "file": "Implication/L06intro.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement (x : ℕ) : x = 37 → x = 37", "ground_truth": "Hint \"Start with `intro h` to assume the hypothesis and call its proof `h`.\"\n  intro h\n  Hint (hidden := true) \"Now `exact h` finishes the job.\"\n  exact h"}
{"id": 37, "file": "Implication/L07intro2.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement (x y : ℕ) : x + 1 = y + 1 → x = y", "ground_truth": "Hint (hidden := true) \"Start with `intro h` to assume the hypothesis.\"\n  intro h\n  Hint (hidden := true) \"Now `repeat rw [← succ_eq_add_one] at h` is the quickest way to\n  change `h` to `succ x = succ y`.\"\n  repeat rw [← succ_eq_add_one] at h\n  Hint (hidden := true) \"Now `apply succ_inj at h` to cancel the `succ`s.\"\n  apply succ_inj at h\n  Hint (hidden := true) \"Now `rw [h]` then `rfl` works, but `exact h` is quicker.\"\n  exact h"}
{"id": 38, "file": "Implication/L08ne.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement (x y : ℕ) (h1 : x = y) (h2 : x ≠ y) : False", "ground_truth": "Hint \"Remember that `h2` is a proof of `x = y → False`. Try\n  `apply`ing `h2` either `at h1` or directly to the goal.\"\n  apply h2 at h1\n  exact h1\n\n/--\n`a ≠ b` is *notation* for `(a = b) → False`.\n\nThe reason this is mathematically\nvalid is that if `P` is a true-false statement then `P → False`\nis the logical opposite of `P`. Indeed `True → False` is false,\nand `False → False` is true!\n\nThe upshot of this is that you can treat `a ≠ b` in exactly\nthe same way as you treat any implication `P → Q`. For example,\nif your *goal* is of the form `a ≠ b` then you can make progress\nwith `intro h`, and if you have a hypothesis `h` of the\nform `a ≠ b` then you can `apply h at h1` if `h1` is a proof\nof `a = b`.\n-/\nDefinitionDoc Ne as \"≠\"\n\n\nNewDefinition Ne"}
{"id": 39, "file": "Implication/L09zero_ne_succ.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement zero_ne_one : (0 : ℕ) ≠ 1", "ground_truth": "Hint \"Start with `intro h`.\"\n  intro h\n  Hint \"Now change `1` to `succ 0` in `h`.\"\n  rw [one_eq_succ_zero] at h  -- **TODO** this line is not needed :-/\n  Hint \"Now you can `apply zero_ne_succ at h`.\"\n  apply zero_ne_succ at h -- **TODO** cripple `apply`.\n  exact h"}
{"id": 40, "file": "Implication/L10one_ne_zero.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement one_ne_zero : (1 : ℕ) ≠ 0", "ground_truth": "symm\n  exact zero_ne_one"}
{"id": 41, "file": "Implication/L11two_add_two_ne_five.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement : succ (succ 0) + succ (succ 0) ≠ succ (succ (succ (succ (succ 0))))", "ground_truth": "intro h\n  rw [add_succ, add_succ, add_zero] at h\n  repeat apply succ_inj at h\n  apply zero_ne_succ at h\n  exact h"}
{"id": 42, "file": "LessOrEqual/L01le_refl.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement le_refl (x : ℕ) : x ≤ x", "ground_truth": "Hint \"The reason `{x} ≤ {x}` is because `{x} = {x} + 0`.\n  So you should start this proof with `use 0`.\"\n  use 0\n  Hint \"You can probably take it from here.\"\n  rw [add_zero]\n  rfl"}
{"id": 43, "file": "LessOrEqual/L02zero_le.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement zero_le (x : ℕ) : 0 ≤ x", "ground_truth": "use x\n  rw [zero_add]\n  rfl"}
{"id": 44, "file": "LessOrEqual/L03le_succ_self.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement le_succ_self (x : ℕ) : x ≤ succ x", "ground_truth": "use 1\n  rw [succ_eq_add_one]\n  rfl"}
{"id": 45, "file": "LessOrEqual/L04le_trans.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement le_trans (x y z : ℕ) (hxy : x ≤ y) (hyz : y ≤ z) : x ≤ z", "ground_truth": "Hint \"Start with `cases {hxy} with a ha`.\"\n  cases hxy with a ha\n  Hint \"Now `{ha}` is a proof that `{y} = {x} + {a}`, and `hxy` has vanished. Similarly, you can destruct\n  `{hyz}` into its parts with `cases {hyz} with b hb`.\"\n  cases hyz with b hb\n  Hint \"Now you need to figure out which number to `use`. See if you can take it from here.\"\n  use a + b\n  rw [hb, ha]\n  exact add_assoc x a b"}
{"id": 46, "file": "LessOrEqual/L05le_zero.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement le_zero (x : ℕ) (hx : x ≤ 0) : x = 0", "ground_truth": "cases hx with y hy\n  Hint (hidden := true) \"You want to use `add_right_eq_zero`, which you already\n  proved, but you'll have to start with `symm at` your hypothesis.\"\n  symm at hy\n  apply add_right_eq_zero at hy\n  exact hy"}
{"id": 47, "file": "LessOrEqual/L06le_antisymm.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement le_antisymm (x y : ℕ) (hxy : x ≤ y) (hyx : y ≤ x) : x = y", "ground_truth": "cases hxy with a ha\n  cases hyx with b hb\n  rw [ha]\n  rw [ha, add_assoc] at hb\n  symm at hb\n  apply add_right_eq_self at hb\n  apply add_right_eq_zero at hb\n  rw [hb, add_zero]\n  rfl"}
{"id": 48, "file": "LessOrEqual/L07or_symm.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement (x y : ℕ) (h : x = 37 ∨ y = 42) : y = 42 ∨ x = 37", "ground_truth": "Hint \"We don't know whether to go left or right yet. So start with `cases {h} with hx hy`.\"\n  cases h with hx hy\n  Hint \"Now we can prove the `or` statement by proving the statement on the right,\n  so use the `right` tactic.\"\n  right\n  exact hx\n  Hint (hidden := true) \"This time, use the `left` tactic.\"\n  left\n  exact hy"}
{"id": 49, "file": "LessOrEqual/L08le_total.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement le_total (x y : ℕ) : x ≤ y ∨ y ≤ x", "ground_truth": "Hint (hidden := true) \"Start with `induction {y} with d hd`.\"\n  induction y with d hd\n  right\n  exact zero_le x\n  Hint (hidden := true) \"Try `cases {hd} with h1 h2`.\"\n  cases hd with h1 h2\n  left\n  cases h1 with e h1\n  rw [h1]\n  use e + 1\n  rw [succ_eq_add_one, add_assoc]\n  rfl\n  Hint (hidden := true) \"Now `cases {h2} with e he`.\"\n  cases h2 with e he\n  Hint (hidden := true) \"You still don't know which way to go, so do `cases {e} with a`.\"\n  cases e with a\n  rw [he]\n  left\n  rw [add_zero]\n  use 1\n  exact succ_eq_add_one d\n  right\n  use a\n  rw [add_succ] at he\n  rw [succ_add]\n  exact he"}
{"id": 50, "file": "LessOrEqual/L09succ_le_succ.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement succ_le_succ (x y : ℕ) (hx : succ x ≤ succ y) : x ≤ y", "ground_truth": "cases hx with d hd\n  use d\n  rw [succ_add] at hd\n  apply succ_inj at hd\n  exact hd"}
{"id": 51, "file": "LessOrEqual/L10le_one.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement le_one (x : ℕ) (hx : x ≤ 1) : x = 0 ∨ x = 1", "ground_truth": "cases x with y\n  left\n  rfl\n  rw [one_eq_succ_zero] at hx ⊢\n  apply succ_le_succ at hx\n  apply le_zero at hx\n  rw [hx]\n  right\n  rfl"}
{"id": 52, "file": "LessOrEqual/L11le_two.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement le_two (x : ℕ) (hx : x ≤ 2) : x = 0 ∨ x = 1 ∨ x = 2", "ground_truth": "cases x with y\n  left\n  rfl\n  cases y with z\n  right\n  left\n  rw [one_eq_succ_zero]\n  rfl\n  rw [two_eq_succ_one, one_eq_succ_zero] at hx ⊢\n  apply succ_le_succ at hx\n  apply succ_le_succ at hx\n  apply le_zero at hx\n  rw [hx]\n  right\n  right\n  rfl"}
{"id": 53, "file": "LessOrEqual/Level_1.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement --one_add_le_self\n    (x : ℕ) : x ≤ 1 + x", "ground_truth": "Hint \"\n  The goal below is to prove $x\\\\le 1+x$ for any natural number $x$.\n  First let's turn the goal explicitly into an existence problem with\n  `rw [le_iff_exists_add]`.\"\n  rw [MyNat.le_iff_exists_add]\n  Hint \"\n  Clearly this statement now is true,\n  and the proof is that $c=1$ will work (we also\n  need the fact that addition is commutative, but we proved that a long\n  time ago). How do we make progress with this goal?\n\n  The `use` tactic can be used on goals of the form `∃ c, ...`. The idea\n  is that we choose which natural number we want to use, and then we use it.\n  So try `use 1`.\"\n  use 1\n  Hint \"\n    and now you can solve this by\n  `exact add_comm 1 x`.\n  \"\n  -- -- TODO: Implement `ring`\n  -- , or if you are lazy you can just use the `ring` tactic,\n  -- which is a powerful AI which will solve any equality in algebra which can\n  -- be proved using the standard rules of addition and multiplication. Now\n  -- look at your proof. We're going to remove a line.\n  rw [TMP.add_comm]\n  rfl"}
{"id": 54, "file": "Multiplication/L01mul_one.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement mul_one (m : ℕ) : m * 1 = m", "ground_truth": "rw [one_eq_succ_zero]\n  rw [mul_succ]\n  rw [mul_zero]\n  rw [zero_add]\n  rfl"}
{"id": 55, "file": "Multiplication/L02zero_mul.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement zero_mul\n    (m : ℕ) : 0 * m = 0", "ground_truth": "induction m with d hd\n  · rw [mul_zero]\n    rfl\n  · rw [mul_succ]\n    rw [hd]\n    rw [add_zero]\n    rfl"}
{"id": 56, "file": "Multiplication/L03succ_mul.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement succ_mul\n    (a b : ℕ) : succ a * b = a * b + b", "ground_truth": "induction b with d hd\n  · rw [mul_zero]\n    rw [mul_zero]\n    rw [add_zero]\n    rfl\n  · rw [mul_succ]\n    rw [mul_succ]\n    rw [hd]\n    rw [add_succ]\n    rw [add_succ]\n    rw [add_right_comm]\n    rfl"}
{"id": 57, "file": "Multiplication/L04mul_comm.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement mul_comm\n    (a b : ℕ) : a * b = b * a", "ground_truth": "induction b with d hd\n  · rw [zero_mul]\n    rw [mul_zero]\n    rfl\n  · rw [succ_mul]\n    rw [← hd]\n    rw [mul_succ]\n    rfl"}
{"id": 58, "file": "Multiplication/L05one_mul.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement one_mul\n    (m : ℕ): 1 * m = m", "ground_truth": "rw [mul_comm, mul_one]\n  rfl"}
{"id": 59, "file": "Multiplication/L06two_mul.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement two_mul\n    (m : ℕ): 2 * m = m + m", "ground_truth": "rw [two_eq_succ_one, succ_mul, one_mul]\n  rfl"}
{"id": 60, "file": "Multiplication/L07mul_add.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement mul_add\n    (a b c : ℕ) : a * (b + c) = a * b + a * c", "ground_truth": "Branch\n    induction b with b hb\n    rw [zero_add, mul_zero, zero_add]\n    rfl\n    rw [succ_add, mul_succ, mul_succ, add_right_comm, hb]\n    rfl\n  Branch\n    induction a with a ha\n    rw [zero_mul, zero_mul, zero_mul, zero_add]\n    rfl\n    rw [succ_mul, succ_mul, succ_mul, ha]\n    repeat rw [add_assoc]\n    rw [← add_assoc (a*c), add_comm _ b, add_assoc]\n    rfl\n  Hint \"You can do induction on any of the three variables. Some choices\n  are harder to push through than others. Can you do the inductive step in\n  5 rewrites only?\"\n  Hint (hidden := true) \"Induction on `a` is the most troublesome, then `b`,\n  and `c` is the easiest.\"\n  induction c with d hd\n  rw [add_zero, mul_zero, add_zero]\n  rfl\n  rw [add_succ, mul_succ, hd, mul_succ, add_assoc]\n  rfl"}
{"id": 61, "file": "Multiplication/L08add_mul.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement add_mul\n    (a b c : ℕ) : (a + b) * c = a * c + b * c", "ground_truth": "rw [mul_comm, mul_add]\n  repeat rw [mul_comm c]\n  rfl"}
{"id": 62, "file": "Multiplication/L09mul_assoc.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement mul_assoc\n    (a b c : ℕ) : (a * b) * c = a * (b * c)", "ground_truth": "induction c with d hd\n  · rw [mul_zero, mul_zero, mul_zero]\n    rfl\n  · rw [mul_succ]\n    rw [mul_succ]\n    rw [hd]\n    rw [mul_add]\n    rfl"}
{"id": 63, "file": "OldAdvMultiplication/Level_2.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement MyNat.eq_zero_or_eq_zero_of_mul_eq_zero\n    (a b : ℕ) (h : a * b = 0) :\n  a = 0 ∨ b = 0", "ground_truth": "induction a with d hd\n  · Branch\n      simp\n    left\n    rfl\n  · induction b with e he\n    · Branch\n        simp\n      right\n      rfl\n    · exfalso\n      rw [mul_succ] at h\n      rw [add_succ] at h\n      exact succ_ne_zero _ h\n\n-- TODO: `induction` or `rcases`? Implement the latter."}
{"id": 64, "file": "OldAdvMultiplication/Level_4.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "theorem in this level. Exactly what statement do you want to prove\nby induction? It is subtle.\n\nOk so here are some spoilers. The problem with naively running at it,\nis that if you try induction on,\nsay, $c$, then you are imagining a and b as fixed, and your inductive\nhypothesis $P(c)$ is $ab=ac \\\\implies b=c$. So for your inductive step\nyou will be able to assume $ab=ad \\\\implies b=d$ and your goal will\nbe to show $ab=a(d+1) \\\\implies b=d+1$. When you also assume $ab=a(d+1)$\nyou will realise that your inductive hypothesis is *useless*, because\n$ab=ad$ is not true! The statement $P(c)$ (with $a$ and $b$ regarded\nas constants) is not provable by induction.\n\nWhat you *can* prove by induction is the following *stronger* statement.\nImagine $a\\\\ne 0$ as fixed, and then prove \\\"for all $b$, if $ab=ac$ then $b=c$\\\"\nby induction on $c$. This gives us the extra flexibility we require.\nNote that we are quantifying over all $b$ in the inductive hypothesis -- it\nis essential that $b$ is not fixed.\n\nYou can do this in two ways in Lean -- before you start the induction\nyou can write `revert b`. The `revert` tactic is the opposite of the `intro`\ntactic; it replaces the `b` in the hypotheses with \\\"for all $b$\\\" in the goal.\n\n[TODO: The second way does not work yet in this game]\n\nIf you do not modify your technique in this way, then this level seems\nto be impossible (judging by the comments I've had about it!)\n\"\n-- Alternatively, you can write `induction c with d hd\n-- generalizing b` as the first line of the proof.\n\n\n/-- If $a \\neq 0$, $b$ and $c$ are natural numbers such that\n$ ab = ac, $\nthen $b = c$. -/\nStatement MyNat.mul_left_cancel\n    (a b c : ℕ) (ha : a ≠ 0) : a * b = a * c → b = c", "ground_truth": "Hint \"NOTE: As is, this level is probably too hard and contains no hints yet.\n  Good luck!"}
{"id": 65, "file": "OldAdvMultiplication/mul_left_comm.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement MyNat.mul_left_comm\n    (a b c : ℕ) : a * (b * c) = b * (a * c)", "ground_truth": "Branch\n    induction c\n    · simp\n    · simp\n      rw [mul_add, n_ih, mul_add, mul_comm a b]\n      rfl\n  rw [← mul_assoc]\n  rw [mul_comm a]\n  rw [mul_assoc]\n  rfl"}
{"id": 66, "file": "OldAdvProposition/Level_2.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement -- and_symm\n    (P Q : Prop) : P ∧ Q → Q ∧ P", "ground_truth": "Hint \"The lemma below asks us to prove `P ∧ Q → Q ∧ P`, that is,\n  symmetry of the \\\"and\\\" relation. The obvious first move is\n\n  ```\n  intro h\n  ```\n\n  because the goal is an implication and this tactic is guaranteed\n  to make progress.\"\n  intro h\n  Hint \"Now `{h} : P ∧ Q` is a hypothesis, and\n\n  ```\n  rcases {h} with ⟨p, q⟩\n  ```\n\n  will change `{h}`, the proof of `P ∧ Q`, into two proofs `p : P`\n  and `q : Q`.\n\n  You can write `⟨p, q⟩` with `\\\\<>` or `\\\\<` and `\\\\>`. Note that `rcases h` by itself will just\n  automatically name the new assumptions.\"\n  rcases h with ⟨p, q⟩\n  Hint \"Now a combination of `constructor` and `exact` will get you home.\"\n  constructor\n  exact q\n  exact p"}
{"id": 67, "file": "OldAdvProposition/Level_3.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement --and_trans\n    (P Q R : Prop) : P ∧ Q → Q ∧ R → P ∧ R", "ground_truth": "Hint \"Here's a trick:\n\n  Your first steps would probably be\n  ```\n  intro h\n  rcases h with ⟨p, q⟩\n  ```\n  i.e. introducing a new assumption and then immediately take it apart.\n\n  In that case you could do that in a single step:\n\n  ```\n  intro ⟨p, q⟩\n  ```\n  \"\n  intro hpq\n  rcases hpq with ⟨p, q⟩\n  intro hqr\n  rcases hqr with ⟨q', r⟩\n  constructor\n  exact p\n  exact r"}
{"id": 68, "file": "OldAdvProposition/Level_4.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement --iff_trans\n    (P Q R : Prop) : (P ↔ Q) → (Q ↔ R) → (P ↔ R)", "ground_truth": "Hint \"Similar to \\\"and\\\", you can use `intro` and `rcases` to add the `P ↔ Q` to your\n  assumptions and split it into its constituent parts.\"\n  Branch\n    intro hpq\n    intro hqr\n    Hint \"Now you want to use `rcases {hpq} with ⟨pq, qp⟩`.\"\n    rcases hpq with ⟨hpq, hqp⟩\n    rcases hqr with ⟨hqr, hrq⟩\n  intro ⟨pq, qp⟩\n  intro ⟨qr, rq⟩\n  Hint \"If you want to prove an iff-statement, you can use `constructor` to split it\n  into its two implications.\"\n  constructor\n  · intro p\n    apply qr\n    apply pq\n    exact p\n  · intro r\n    apply qp\n    apply rq\n    exact r\n\nNewDefinition Iff"}
{"id": 69, "file": "OldAdvProposition/Level_5.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement --iff_trans\n    (P Q R : Prop) : (P ↔ Q) → (Q ↔ R) → (P ↔ R)", "ground_truth": "intro hpq hqr\n  Hint \"Make a choice and continue either with `constructor` or `rw`.\n\n  * if you use `constructor`, you will use `{hqr}.1, {hqr}.2, …` later.\n  * if you use `rw`, you can replace all `P`s with `Q`s using `rw [{hpq}]`\"\n  Branch\n    rw [hpq]\n    Branch\n      exact hqr\n    rw [hqr]\n    Hint \"Now `rfl` can close this goal.\n\n    TODO: Note that the current modification of `rfl` is too weak to prove this. For now, you can\n    use `simp` instead (which calls the \\\"real\\\" `rfl` internally).\"\n    simp\n  constructor\n  intro p\n  Hint \"Now you can directly `apply {hqr}.1`\"\n  apply hqr.1\n  apply hpq.1\n  exact p\n  intro r\n  apply hpq.2\n  apply hqr.2\n  exact r\n\nDisabledTactic rcases"}
{"id": 70, "file": "OldAdvProposition/Level_7.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement --or_symm\n    (P Q : Prop) : P ∨ Q → Q ∨ P", "ground_truth": "Hint \"`intro h` is the obvious start.\"\n  intro h\n  Branch\n    left\n    Hint \"This is a dead end that is not provable anymore. Hit \\\"undo\\\".\"\n  Branch\n    right\n    Hint \"This is a dead end that is not provable anymore. Hit \\\"undo\\\".\"\n  Hint \"But now, even though the goal is an `∨` statement, both `left` and `right` put\n  you in a situation with an impossible goal. Fortunately,\n  you can do `rcases h with p | q`. (that is a normal vertical slash)\n  \"\n  rcases h with p | q\n  Hint \" Something new just happened: because\n  there are two ways to prove the assumption `P ∨ Q` (namely, proving `P` or proving `Q`),\n  the `rcases` tactic turns one goal into two, one for each case.\n\n  So now you proof the goal under the assumption that `P` is true, and waiting under \\\"Other Goals\\\"\n  there is the same goal but under the assumption that `Q` is true.\n\n  You should be able to make it home from there. \"\n  right\n  exact p\n  Hint \"Note how now you finished the first goal and jumped to the one, where you assume `Q`.\"\n  left\n  exact q"}
{"id": 71, "file": "OldAdvProposition/Level_8.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement --and_or_distrib_left\n    (P Q R : Prop) : P ∧ (Q ∨ R) ↔ (P ∧ Q) ∨ (P ∧ R)", "ground_truth": "constructor\n  intro h\n  rcases h with ⟨hp, hqr⟩\n  rcases hqr with q | r\n  left\n  constructor\n  exact hp\n  exact q\n  right\n  constructor\n  exact hp\n  exact r\n  intro h\n  rcases h with hpq | hpr\n  rcases hpq with ⟨p, q⟩\n  constructor\n  exact p\n  left\n  exact q\n  rcases hpr with ⟨hp, hr⟩\n  constructor\n  exact hp\n  right\n  exact hr"}
{"id": 72, "file": "OldAdvProposition/Level_9.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement --contra\n  (P Q : Prop) : (P ∧ ¬ P) → Q", "ground_truth": "Hint \"Start as usual with `intro ⟨p, np⟩`.\"\n  Branch\n    exfalso\n    -- TODO: This hint needs to be strict\n    -- Hint \"Not so quick! Now you just threw everything away.\"\n  intro h\n  Hint \"You should also call `rcases` on your assumption `{h}`.\"\n  rcases h with ⟨p, np ⟩\n  -- TODO: This hint should before the last `exact p` step again.\n  Hint \"Now you can call `exfalso` to throw away your goal `Q`. It will be replaced with `False` and\n  which means you will have to prove a contradiction.\"\n  Branch\n    -- TODO: Would `contradiction` not be more useful to introduce than `exfalso`?\n    contradiction\n  exfalso\n  Hint \"Recall that `{np} : ¬ P` means `np : P → False`, which means you can simply `apply {np}` now.\n\n  You can also first call `rw [Not] at {np}` to make this step more explicit.\"\n  Branch\n    rw [Not] at np\n  apply np\n  exact p\n\n-- TODO: `contradiction`?"}
{"id": 73, "file": "OldProposition/FuncProgram.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "theorem double_eq_two_mul (n : ℕ) : double n = 2 * n", "ground_truth": "induction' n with d hd -- need hacked induction' so that it gives `0` not `Nat.zero`\n  show 0 = 2 * 0 -- system should do this\n  norm_num -- needs to be taught\n  show 2 + double d = 2 * d.succ\n  rw [hd]\n  rw [Nat.succ_eq_add_one] -- `ring` should do this\n  ring--"}
{"id": 74, "file": "Power/L01zero_pow_zero.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement zero_pow_zero : (0 : ℕ) ^ 0 = 1", "ground_truth": "rw [pow_zero]\n  rfl"}
{"id": 75, "file": "Power/L02zero_pow_succ.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement zero_pow_succ\n    (m : ℕ) : (0 : ℕ) ^ (succ m) = 0", "ground_truth": "rw [pow_succ]\n  rw [mul_zero]\n  rfl"}
{"id": 76, "file": "Power/L03pow_one.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement pow_one (a : ℕ) : a ^ 1 = a", "ground_truth": "rw [one_eq_succ_zero]\n  rw [pow_succ]\n  rw [pow_zero]\n  rw [one_mul]\n  rfl"}
{"id": 77, "file": "Power/L04one_pow.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement one_pow\n    (m : ℕ) : (1 : ℕ) ^ m = 1", "ground_truth": "induction m with t ht\n  · rw [pow_zero]\n    rfl\n  · rw [pow_succ]\n    rw [ht]\n    rw [mul_one]\n    rfl"}
{"id": 78, "file": "Power/L05pow_two.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement pow_two\n    (a : ℕ) : a ^ 2 = a * a", "ground_truth": "rw [two_eq_succ_one]\n  rw [pow_succ]\n  rw [pow_one]\n  rfl"}
{"id": 79, "file": "Power/L06pow_add.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement pow_add\n    (a m n : ℕ) : a ^ (m + n) = a ^ m * a ^ n", "ground_truth": "induction n with t ht\n  · rw [add_zero, pow_zero, mul_one]\n    rfl\n  · rw [add_succ, pow_succ, pow_succ, ht, mul_assoc]\n    rfl"}
{"id": 80, "file": "Power/L07mul_pow.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement mul_pow\n    (a b n : ℕ) : (a * b) ^ n = a ^ n * b ^ n", "ground_truth": "induction n with t Ht\n  · rw [pow_zero, pow_zero, pow_zero, mul_one]\n    rfl\n  · rw [pow_succ, pow_succ, pow_succ, Ht]\n    -- simp\n    repeat rw [mul_assoc]\n    rw [mul_comm a (_ * b), mul_assoc, mul_comm b a]\n    rfl"}
{"id": 81, "file": "Power/L08pow_pow.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement pow_pow\n    (a m n : ℕ) : (a ^ m) ^ n = a ^ (m * n)", "ground_truth": "induction n with t Ht\n  · rw [mul_zero, pow_zero, pow_zero]\n    rfl\n  · rw [pow_succ, Ht, mul_succ, pow_add]\n    rfl"}
{"id": 82, "file": "Power/L09add_sq.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement add_sq\n    (a b : ℕ) : (a + b) ^ 2 = a ^ 2 + b ^ 2 + 2 * a * b", "ground_truth": "rw [pow_two, pow_two, pow_two]\n  rw [add_right_comm]\n  rw [mul_add, add_mul, add_mul]\n  rw [two_mul, add_mul]\n  rw [mul_comm b a]\n  rw [← add_assoc, ← add_assoc]\n  rfl"}
{"id": 83, "file": "Tutorial/L04rw_backwards.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement : 2 = succ (succ 0)", "ground_truth": "Hint \"Try `rw [← one_eq_succ_zero]` to change `succ 0` into `1`.\"\n  rw [← one_eq_succ_zero]\n  Hint \"Can you now change the goal into `2 = 2`?\"\n  Hint (hidden := true) \"Now `rw [← two_eq_succ_one]` will change `succ 1` into `2`.\"\n  rw [← two_eq_succ_one]\n  rfl"}
{"id": 84, "file": "Tutorial/L05add_zero.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement (a b c : ℕ) : a + (b + 0) + (c + 0) = a + b + c", "ground_truth": "Hint \"`rw [add_zero]` will change `b + 0` into `b`.\"\n  rw [add_zero]\n  Hint \"Now `rw [add_zero]` will change `c + 0` into `c`.\"\n  rw [add_zero]\n  rfl"}
{"id": 85, "file": "Tutorial/L06add_zero2.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement (a b c : ℕ) : a + (b + 0) + (c + 0) = a + b + c", "ground_truth": "Hint \"Try `rw [add_zero c]`.\"\n  rw [add_zero c]\n  Hint \"`add_zero c` is a proof of `c + 0 = c` so that was what got rewritten.\n  You can now change `b + 0` to `b` with `rw [add_zero]` or `rw [add_zero b]`. You\n  can usually stick to `rw [add_zero]` unless you need real precision.\"\n  rw [add_zero]\n  rfl"}
{"id": 86, "file": "Tutorial/L07add_succ.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement succ_eq_add_one n : succ n = n + 1", "ground_truth": "Hint \"Start by unravelling the `1`.\"\n  Hint (hidden := true) \"`rw [one_eq_succ_zero]` will do this.\"\n  rw [one_eq_succ_zero]\n  Hint (hidden := true) \"Now you can `rw [add_succ]`\"\n  rw [add_succ]\n  Hint (hidden := true) \"And now `rw [add_zero]`\"\n  rw [add_zero]\n  Hint (hidden := true) \"And finally `rfl`.\"\n  rfl"}
{"id": 87, "file": "Tutorial/L08twoaddtwo.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement : (2 : ℕ) + 2 = 4", "ground_truth": "Hint (hidden := true) \"`nth_rewrite 2 [two_eq_succ_one]` is I think quicker than `rw [two_eq_succ_one]`.\"\n  nth_rewrite 2 [two_eq_succ_one]\n  Hint (hidden := true) \"Now you can `rw [add_succ]`\"\n  rw [add_succ]\n  rw [one_eq_succ_zero]\n  rw [add_succ]\n  rw [add_zero]\n  rw [four_eq_succ_three]\n  rw [three_eq_succ_two]\n  rfl"}
{"id": 88, "file": "WIPAlgorithm/L11ac_rfl.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement (a b c d e f g h : ℕ) :\n    (d + f) + (h + (a + c)) + (g + e + b) = a + b + c + d + e + f + g + h", "ground_truth": "ac_rfl"}
{"id": 89, "file": "WIPFuncProg/decide_level.lean", "header": [{"full_name": "succ_ne_succ", "code": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := sorry", "category": "axiom"}, {"full_name": "succ_ne_zero", "code": "axiom succ_ne_zero (n : MyNat) : succ n ≠ 0", "category": "axiom"}, {"full_name": "MyNat", "code": "inductive MyNat where\n| zero : MyNat\n| succ : MyNat → MyNat", "category": "inductive"}, {"full_name": "ofNat", "code": "def ofNat (x : Nat) : MyNat :=\n  match x with\n  | Nat.zero   => MyNat.zero\n  | Nat.succ b => MyNat.succ (ofNat b)", "category": "definition"}, {"full_name": "toNat", "code": "def toNat (x : MyNat) : Nat :=\n  match x with\n  | MyNat.zero   => Nat.zero\n  | MyNat.succ b => Nat.succ (toNat b)", "category": "definition"}, {"full_name": "one", "code": "def one : MyNat := MyNat.succ 0", "category": "definition"}, {"full_name": "zero_eq_0", "code": "theorem zero_eq_0 : MyNat.zero = 0 := rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : Inhabited MyNat where\n  default := MyNat.zero", "category": "instance"}, {"full_name": "instofNat", "code": "instance instofNat {n : Nat} : OfNat MyNat n where\n  ofNat := ofNat n", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : ToString MyNat where\n  toString p := toString (toNat p)", "category": "instance"}, {"full_name": "pred", "code": "def pred : ℕ → ℕ\n| 0 => 37\n| succ n => n", "category": "definition"}, {"full_name": "is_zero", "code": "def is_zero : ℕ → Prop\n| 0 => True\n| succ _ => False", "category": "definition"}, {"full_name": "succ_inj", "code": "theorem succ_inj (a b : ℕ) (h : succ a = succ b) : a = b := by\n  rw [← pred_succ a, h, pred_succ]", "category": "theorem"}, {"full_name": "zero_ne_succ", "code": "theorem zero_ne_succ (a : ℕ) : 0 ≠ succ a := by\n  intro h\n  rw [← is_zero_succ a]\n  rw [← h]\n  rw [is_zero_zero]\n  trivial", "category": "theorem"}, {"full_name": "pred_succ", "code": "lemma pred_succ (n : ℕ) : pred (succ n) = n := rfl", "category": "lemma"}, {"full_name": "is_zero_zero", "code": "lemma is_zero_zero : is_zero 0 = True := rfl", "category": "lemma"}, {"full_name": "is_zero_succ", "code": "lemma is_zero_succ (n : ℕ) : is_zero (succ n) = False := rfl", "category": "lemma"}, {"full_name": "add", "code": "opaque add : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "add_zero", "code": "axiom add_zero (a: MyNat) : a + 0 = a", "category": "axiom"}, {"full_name": "add_succ", "code": "axiom add_succ (a d: MyNat) : a + (succ d) = succ (a + d)", "category": "axiom"}, {"full_name": "instAdd", "code": "instance instAdd : Add MyNat where\n  add := MyNat.add", "category": "instance"}, {"full_name": "mul", "code": "opaque mul : MyNat → MyNat → MyNat", "category": "opaque"}, {"full_name": "mul_zero", "code": "axiom mul_zero (a: MyNat) : a * 0 = 0", "category": "axiom"}, {"full_name": "mul_succ", "code": "axiom mul_succ (a b: MyNat) : a * (succ b) = a * b + a", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Mul MyNat where\n  mul := MyNat.mul", "category": "instance"}, {"full_name": "one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0 := by rfl", "category": "theorem"}, {"full_name": "two_eq_succ_one", "code": "theorem two_eq_succ_one : 2 = succ 1 := by rfl", "category": "theorem"}, {"full_name": "three_eq_succ_two", "code": "theorem three_eq_succ_two : 3 = succ 2 := by rfl", "category": "theorem"}, {"full_name": "four_eq_succ_three", "code": "theorem four_eq_succ_three : 4 = succ 3 := by rfl", "category": "theorem"}, {"full_name": "pow", "code": "opaque pow : ℕ → ℕ → ℕ", "category": "opaque"}, {"full_name": "pow_zero", "code": "axiom pow_zero (m: ℕ) : m ^ 0 = 1", "category": "axiom"}, {"full_name": "pow_succ", "code": "axiom pow_succ (m n: ℕ) : m ^ (succ n) = m ^ n * m", "category": "axiom"}, {"full_name": "anonymous_instance", "code": "instance : Pow ℕ ℕ where\n  pow := pow\n\n\nmacro_rules | `($x ^ $y)   => `(HPow.hPow ($x : MyNat) ($y : MyNat))", "category": "instance"}, {"full_name": "le", "code": "def le (a b : ℕ) :=  ∃ (c : ℕ), b = a + c", "category": "definition"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "le", "code": "def le (a b : MyNat) :=  ∃ (c : MyNat), b = a + c", "category": "definition"}, {"full_name": "lt_myNat", "code": "def lt_myNat (a b : MyNat) := a ≤ b ∧ ¬ (b ≤ a)", "category": "definition"}, {"full_name": "le_def", "code": "theorem le_def' : MyNat.le = (.≤.) := rfl", "category": "theorem"}, {"full_name": "le_iff_exists_add", "code": "theorem le_iff_exists_add (a b : MyNat) : a ≤ b ↔ ∃ (c : MyNat), b = a + c := Iff.rfl", "category": "theorem"}, {"full_name": "lt", "code": "theorem lt :  ∀ (a b : MyNat), a < b ↔ a ≤ b ∧ ¬b ≤ a := fun _ _ => Iff.rfl", "category": "theorem"}, {"full_name": "anonymous_instance", "code": "instance : LE MyNat := ⟨MyNat.le⟩", "category": "instance"}, {"full_name": "anonymous_instance", "code": "instance : LT MyNat := ⟨lt_myNat⟩", "category": "instance"}, {"full_name": "instDecidableEq", "code": "instance instDecidableEq : DecidableEq MyNat\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m ≠ 0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 ≠ succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m ≠ n) => isFalse <| by\n    show succ m ≠ succ n\n    exact succ_ne_succ m n h", "category": "instance"}], "statement": "Statement : (29 : ℕ) + 35 = 64", "ground_truth": "decide"}
