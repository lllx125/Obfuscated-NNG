{"id": 1, "name": "zero_add", "statement": "theorem zero_add (n : MyNat) : add zero n = n := by", "proof": "induction n with\n  | zero =>\n    rw [add_zero]\n  | succ d ih =>\n    rw [add_succ, ih]", "known_theorems": []}
{"id": 2, "name": "succ_add", "statement": "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "proof": "induction b with\n| zero =>\n  rw [add_zero (succ a)]\n  rw [add_zero a]\n| succ d ih =>\n  rw [add_succ (succ a) d]\n  rw [add_succ a d]\n  rw [ih]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by"]}
{"id": 3, "name": "add_comm", "statement": "theorem add_comm (a b : MyNat) : add a b = add b a := by", "proof": "induction b with\n| zero =>\n  rw [add_zero]\n  rw [zero_add]\n  exact rfl\n| succ d ih =>\n  rw [add_succ]\n  rw [succ_add]\n  rw [ih]\n  exact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by"]}
{"id": 4, "name": "add_assoc", "statement": "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "proof": "induction c with\n| zero =>\n  repeat rw [add_zero]\n  exact rfl\n| succ d ih =>\n  rw [add_succ]\n  rw [add_succ]\n  rw [ih]\n  exact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by"]}
{"id": 5, "name": "add_right_comm", "statement": "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "proof": "rw [add_assoc a b c]\nrw [add_comm b c]\nrw [← add_assoc a c b]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by"]}
{"id": 6, "name": "add_left_comm", "statement": "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "proof": "rw [← add_assoc a b c]\nrw [add_right_comm a b c]\nrw [add_comm (add a c) b]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by"]}
{"id": 7, "name": "succ_eq_add_one", "statement": "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "proof": "rw [one_eq_succ_zero]\nrw [add_succ]\nrw [add_zero]\nrfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by"]}
{"id": 8, "name": "implication_one", "statement": "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "proof": "exact h1", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by"]}
{"id": 9, "name": "implication_two", "statement": "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "proof": "repeat rw [zero_add] at h\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by"]}
{"id": 10, "name": "implication_three", "statement": "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "proof": "exact h2 h1", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by"]}
{"id": 11, "name": "implication_four", "statement": "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "proof": "intro x h\napply succ_inj x three\nrw [succ_eq_add_one x]\nrw [h]\nrw [four_eq_succ_three]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by"]}
{"id": 12, "name": "implication_five", "statement": "theorem implication_five (x : MyNat) : x = four → x = four := by", "proof": "intro h\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by"]}
{"id": 13, "name": "implication_six", "statement": "theorem implication_six (x y : MyNat) : add x one = add y one → x = y := by", "proof": "intro h\nrw [← succ_eq_add_one x] at h\nrw [← succ_eq_add_one y] at h\nexact succ_inj x y h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by"]}
{"id": 14, "name": "implication_seven", "statement": "theorem implication_seven (x y : MyNat) (h1 : x = y) (h2 : x ≠ y) : False := by", "proof": "exact h2 h1", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by", "theorem implication_six (x y : MyNat) : add x one = add y one → x = y := by"]}
{"id": 15, "name": "zero_ne_one", "statement": "theorem zero_ne_one : (zero : MyNat) ≠ one := by", "proof": "intro h\napply (zero_ne_succ zero)\nrw [one_eq_succ_zero] at h\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by", "theorem implication_six (x y : MyNat) : add x one = add y one → x = y := by", "theorem implication_seven (x y : MyNat) (h1 : x = y) (h2 : x ≠ y) : False := by"]}
{"id": 16, "name": "one_ne_zero", "statement": "theorem one_ne_zero : (one : MyNat) ≠ zero := by", "proof": "intro h\napply zero_ne_one\nsymm\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by", "theorem implication_six (x y : MyNat) : add x one = add y one → x = y := by", "theorem implication_seven (x y : MyNat) (h1 : x = y) (h2 : x ≠ y) : False := by", "theorem zero_ne_one : (zero : MyNat) ≠ one := by"]}
{"id": 17, "name": "two_plus_two_ne_five", "statement": "theorem two_plus_two_ne_five : add (succ (succ zero)) (succ (succ zero)) ≠ succ (succ (succ (succ (succ zero)))) := by", "proof": "intro h\nrepeat rw [add_succ] at h\nrw [add_zero] at h\napply (zero_ne_succ zero)\nexact\n  succ_inj zero (succ zero) (\n    succ_inj (succ zero) (succ (succ zero)) (\n      succ_inj (succ (succ zero)) (succ (succ (succ zero))) (\n        succ_inj (succ (succ (succ zero))) (succ (succ (succ (succ zero)))) h\n      )\n    )\n  )", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by", "theorem implication_six (x y : MyNat) : add x one = add y one → x = y := by", "theorem implication_seven (x y : MyNat) (h1 : x = y) (h2 : x ≠ y) : False := by", "theorem zero_ne_one : (zero : MyNat) ≠ one := by", "theorem one_ne_zero : (one : MyNat) ≠ zero := by"]}
{"id": 18, "name": "add_algo_1", "statement": "theorem add_algo_1 (a b c d : MyNat) : add (add a b) (add c d) = add (add (add a c) d) b := by", "proof": "rw [add_right_comm a b (add c d)]\nrw [← add_assoc a c d]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by"]}
{"id": 19, "name": "succ_ne_zero", "statement": "theorem succ_ne_zero (a : MyNat) : succ a ≠ zero := by", "proof": "intro h\napply (zero_ne_succ a)\nsymm\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_algo_1 (a b c d : MyNat) : add (add a b) (add c d) = add (add (add a c) d) b := by"]}
{"id": 20, "name": "succ_ne_succ", "statement": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := by", "proof": "intro hsn\napply h\nexact succ_inj m n hsn", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_algo_1 (a b c d : MyNat) : add (add a b) (add c d) = add (add (add a c) d) b := by", "theorem succ_ne_zero (a : MyNat) : succ a ≠ zero := by"]}
{"id": 21, "name": "mul_one", "statement": "theorem mul_one (m : MyNat) : mul m one = m := by", "proof": "rw [one_eq_succ_zero]\nrw [mul_succ]\nrw [mul_zero]\nrw [zero_add]\nexact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by"]}
{"id": 22, "name": "zero_mul", "statement": "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "proof": "induction m with\n| zero =>\n  rw [mul_zero]\n| succ d ih =>\n  rw [mul_succ, ih, zero_add]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by"]}
{"id": 23, "name": "succ_mul", "statement": "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "proof": "induction b with\n| zero =>\n  rw [mul_zero, mul_zero, add_zero]\n| succ d ih =>\n  rw [mul_succ, mul_succ]\n  rw [ih]\n  rw [add_right_comm (mul a d) d (succ a)]\n  rw [add_succ (mul a d) a]\n  rw [succ_add]\n  rw [add_succ]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by"]}
{"id": 24, "name": "mul_comm", "statement": "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "proof": "induction b with\n| zero =>\n  rw [mul_zero a]\n  rw [zero_mul a]\n  exact rfl\n| succ d ih =>\n  rw [mul_succ a d]\n  rw [succ_mul d a]\n  rw [ih]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by"]}
{"id": 25, "name": "one_mul", "statement": "theorem one_mul (m : MyNat) : mul one m = m := by", "proof": "rw [mul_comm one m]\nrw [mul_one m]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by"]}
{"id": 26, "name": "two_mul", "statement": "theorem two_mul (m : MyNat) : mul two m = add m m := by", "proof": "rw [two_eq_succ_one]\nrw [succ_mul]\nrw [one_mul]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by"]}
{"id": 27, "name": "mul_add", "statement": "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "proof": "induction c with\n| zero =>\n  rw [add_zero]\n  rw [mul_zero]\n  rw [add_zero]\n| succ d ih =>\n  rw [add_succ]\n  rw [mul_succ]\n  rw [ih]\n  rw [add_assoc]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by"]}
{"id": 28, "name": "add_mul", "statement": "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "proof": "rw [mul_comm (add a b) c]\nrw [mul_add c a b]\nrw [mul_comm c a]\nrw [mul_comm c b]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by"]}
{"id": 29, "name": "mul_assoc", "statement": "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "proof": "induction c with\n| zero =>\n  rw [mul_zero (mul a b)]\n  rw [mul_zero b]\n  rw [mul_zero a]\n| succ d ih =>\n  rw [mul_succ (mul a b) d]\n  rw [mul_succ b d]\n  rw [mul_add]\n  rw [ih]\n  exact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by"]}
{"id": 30, "name": "zero_pow_zero", "statement": "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "proof": "exact pow_zero zero", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by"]}
{"id": 31, "name": "zero_pow_succ", "statement": "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "proof": "rw [pow_succ (m := zero) (n := m)]\nrw [mul_zero (a := pow zero m)]\nexact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by"]}
{"id": 32, "name": "pow_one", "statement": "theorem pow_one (a : MyNat) : pow a one = a  := by", "proof": "rw [one_eq_succ_zero]\nrw [pow_succ]\nrw [pow_zero]\nrw [one_mul]\nexact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by"]}
{"id": 33, "name": "one_pow", "statement": "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by", "proof": "induction m with\n| zero =>\n  rw [pow_zero]\n| succ d ih =>\n  rw [pow_succ]\n  rw [ih]\n  rw [one_mul]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by"]}
{"id": 34, "name": "pow_two", "statement": "theorem pow_two (a : MyNat) : pow a two = mul a a := by", "proof": "rw [two_eq_succ_one]\nrw [pow_succ]\nrw [pow_one]\nexact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by", "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by"]}
{"id": 35, "name": "pow_add", "statement": "theorem pow_add (a m n : MyNat) : pow a (add m n) = mul (pow a m) (pow a n) := by", "proof": "induction n with\n| zero =>\n  rw [add_zero, pow_zero, mul_one]\n| succ d ih =>\n  rw [add_succ, pow_succ, ih, pow_succ, mul_assoc]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by", "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by", "theorem pow_two (a : MyNat) : pow a two = mul a a := by"]}
{"id": 36, "name": "mul_pow", "statement": "theorem mul_pow (a b n : MyNat) : pow (mul a b) n = mul (pow a n) (pow b n) := by", "proof": "induction n with\n| zero =>\n  rw [pow_zero (mul a b), pow_zero a, pow_zero b]\n  rw [one_mul]\n  exact rfl\n| succ d ih =>\n  rw [pow_succ (mul a b) d, pow_succ a d, pow_succ b d]\n  rw [ih]\n  rw [mul_assoc (pow a d) (pow b d) (mul a b)]\n  rw [← mul_assoc (pow b d) a b]\n  rw [mul_comm (pow b d) a]\n  rw [← mul_assoc (pow a d) (mul a (pow b d)) b]\n  rw [← mul_assoc (pow a d) a (pow b d)]\n  rw [mul_assoc (mul (pow a d) a) (pow b d) b]\n  exact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by", "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by", "theorem pow_two (a : MyNat) : pow a two = mul a a := by", "theorem pow_add (a m n : MyNat) : pow a (add m n) = mul (pow a m) (pow a n) := by"]}
{"id": 37, "name": "pow_pow", "statement": "theorem pow_pow (a m n : MyNat) : pow (pow a m) n = pow a (mul m n) := by", "proof": "induction n with\n| zero =>\n  rw [pow_zero]\n  rw [mul_zero]\n  rw [pow_zero]\n  exact rfl\n| succ d ih =>\n  rw [pow_succ]\n  rw [ih]\n  rw [← pow_add a (mul m d) m]\n  rw [← mul_succ m d]\n  exact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by", "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by", "theorem pow_two (a : MyNat) : pow a two = mul a a := by", "theorem pow_add (a m n : MyNat) : pow a (add m n) = mul (pow a m) (pow a n) := by", "theorem mul_pow (a b n : MyNat) : pow (mul a b) n = mul (pow a n) (pow b n) := by"]}
{"id": 38, "name": "add_sq", "statement": "theorem add_sq (a b : MyNat) : pow (add a b) two = add (add (pow a two) (pow b two)) (mul (mul two a) b) := by", "proof": "rw [pow_two (add a b)]\nrw [mul_add (add a b) a b]\nrw [add_mul a b a]\nrw [add_mul a b b]\nrw [mul_comm b a]\nrw [add_assoc (mul a a) (mul a b) (add (mul a b) (mul b b))]\nrw [add_left_comm (mul a b) (mul a b) (mul b b)]\nrw [← add_assoc (mul a b) (mul a b) (mul b b)]\nrw [add_left_comm (mul a a) (add (mul a b) (mul a b)) (mul b b)]\nrw [add_comm (add (mul a b) (mul a b)) (add (mul a a) (mul b b))]\nrw [← two_mul (mul a b)]\nrw [← mul_assoc two a b]\nrw [← pow_two a, ← pow_two b]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by", "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by", "theorem pow_two (a : MyNat) : pow a two = mul a a := by", "theorem pow_add (a m n : MyNat) : pow a (add m n) = mul (pow a m) (pow a n) := by", "theorem mul_pow (a b n : MyNat) : pow (mul a b) n = mul (pow a n) (pow b n) := by", "theorem pow_pow (a m n : MyNat) : pow (pow a m) n = pow a (mul m n) := by"]}
{"id": 39, "name": "add_right_cancel", "statement": "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "proof": "induction n with\n| zero =>\n  intro h\n  rw [add_zero a, add_zero b] at h\n  exact h\n| succ d ih =>\n  intro h\n  rw [add_succ a d, add_succ b d] at h\n  apply ih\n  apply succ_inj (add a d) (add b d)\n  exact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by"]}
{"id": 40, "name": "add_left_cancel", "statement": "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "proof": "intro h\nrw [add_comm n a] at h\nrw [add_comm n b] at h\nexact add_right_cancel a b n h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by"]}
{"id": 41, "name": "add_left_eq_self", "statement": "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "proof": "intro h\napply add_right_cancel x zero y\nrw [zero_add y]\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by"]}
{"id": 42, "name": "add_right_eq_self", "statement": "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "proof": "intro h\nrw [add_comm x y] at h\nexact add_left_eq_self y x h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by"]}
{"id": 43, "name": "add_right_eq_zero", "statement": "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "proof": "intro h\ncases b with\n| zero =>\n  rw [add_zero] at h\n  exact h\n| succ d =>\n  rw [add_succ] at h\n  symm at h\n  have hFalse : False := by\n    apply zero_ne_succ (add a d)\n    exact h\n  cases hFalse", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by"]}
{"id": 44, "name": "add_left_eq_zero", "statement": "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "proof": "intro h\nrw [add_comm a b] at h\nexact add_right_eq_zero b a h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by"]}
{"id": 45, "name": "le_refl", "statement": "theorem le_refl (x : MyNat) : le x x := by", "proof": "use zero\nsymm\nexact add_zero x", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by"]}
{"id": 46, "name": "zero_le", "statement": "theorem zero_le (x : MyNat) : le zero x := by", "proof": "apply (le_iff_exists_add zero x).mpr\nuse x\nsymm\nexact zero_add x", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by"]}
{"id": 47, "name": "le_succ_self", "statement": "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "proof": "use one\nexact succ_eq_add_one x", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by"]}
{"id": 48, "name": "le_trans", "statement": "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "proof": "cases hxy with\n| intro c hc =>\n  cases hyz with\n  | intro d hd =>\n    use add c d\n    rw [hd]\n    rw [hc]\n    rw [add_assoc]\n    exact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by"]}
{"id": 49, "name": "le_zero", "statement": "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "proof": "cases hx with\n| intro c hc =>\n  symm at hc\n  exact add_right_eq_zero x c hc", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by"]}
{"id": 50, "name": "le_antisymm", "statement": "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "proof": "cases hxy with\n| intro a hya =>\n  cases hyx with\n  | intro b hxb =>\n    have h3 : x = add x (add a b) := by\n      have h2 : x = add (add x a) b := by\n        rw [hya] at hxb\n        exact hxb\n      rw [add_assoc] at h2\n      exact h2\n    have hsum_zero : add a b = zero := by\n      symm at h3\n      rw [← add_zero x] at h3\n      apply add_left_cancel (a := add a b) (b := zero) (n := x)\n      exact h3\n    have ha0 : a = zero := by\n      apply add_right_eq_zero (a := a) (b := b)\n      exact hsum_zero\n    have hy_eqx : y = x := by\n      rw [ha0] at hya\n      rw [add_zero] at hya\n      exact hya\n    symm\n    exact hy_eqx", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by"]}
{"id": 51, "name": "or_symm", "statement": "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "proof": "intro x y h\ncases h with\n| inl hx =>\n  right\n  exact hx\n| inr hy =>\n  left\n  exact hy", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by"]}
{"id": 52, "name": "le_total", "statement": "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "proof": "revert y\ninduction x with\n| zero =>\n  intro y\n  left\n  apply zero_le\n| succ a ih =>\n  intro y\n  cases y with\n  | zero =>\n    right\n    apply zero_le\n  | succ b =>\n    cases ih b with\n    | inl h1 =>\n      left\n      cases h1 with\n      | intro c hc =>\n        use c\n        rw [hc]\n        symm\n        rw [succ_add]\n    | inr h2 =>\n      right\n      cases h2 with\n      | intro c hc =>\n        use c\n        rw [hc]\n        symm\n        rw [succ_add]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by"]}
{"id": 53, "name": "succ_le_succ", "statement": "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "proof": "cases hx with\n| intro c hc =>\n  use c\n  apply succ_inj\n  rw [succ_add x c] at hc\n  exact hc", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by"]}
{"id": 54, "name": "le_one", "statement": "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "proof": "intro x hx\nrw [le_iff_exists_add] at hx\ncases hx with\n| intro c hc =>\n  cases c with\n  | zero =>\n    rw [add_zero] at hc\n    symm at hc\n    right\n    exact hc\n  | succ d =>\n    rw [add_succ] at hc\n    rw [one_eq_succ_zero] at hc\n    symm at hc\n    left\n    apply add_right_eq_zero x d\n    exact succ_inj (add x d) zero hc", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by"]}
{"id": 55, "name": "le_two", "statement": "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "proof": "intro x hx\ncases le_total x one with\n| inl hxle1 =>\n  have hx01 : x = zero ∨ x = one := by\n    exact (le_one x hxle1)\n  cases hx01 with\n  | inl hz =>\n    left\n    exact hz\n  | inr h1 =>\n    right; left\n    exact h1\n| inr h1lex =>\n  cases h1lex with\n  | intro c hx_eq =>\n    -- Turn x = add one c into x = succ c\n    symm at hx_eq\n    rw [add_comm] at hx_eq\n    rw [← succ_eq_add_one c] at hx_eq\n    symm at hx_eq\n    -- Use hx : le x two to get a decomposition of two\n    cases hx with\n    | intro d htwo =>\n      rw [hx_eq] at htwo\n      rw [succ_add c d] at htwo\n      rw [two_eq_succ_one] at htwo\n      -- Now succ one = succ (add c d), so inject\n      have hone : one = add c d := by\n        apply succ_inj\n        exact htwo\n      -- From this, c ≤ one\n      have hle_c1 : le c one := by\n        use d\n        exact hone\n      -- Classify c\n      have hc_cases : c = zero ∨ c = one := by\n        exact (le_one c hle_c1)\n      cases hc_cases with\n      | inl hcz =>\n        rw [hcz] at hx_eq\n        rw [← one_eq_succ_zero] at hx_eq\n        right; left\n        exact hx_eq\n      | inr hco =>\n        rw [hco] at hx_eq\n        rw [← two_eq_succ_one] at hx_eq\n        right; right\n        exact hx_eq", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by"]}
{"id": 56, "name": "one_add_le_self", "statement": "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "proof": "use one\nexact add_comm one x", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by"]}
{"id": 57, "name": "reflexive", "statement": "theorem reflexive (x : MyNat) : le x  x := by", "proof": "use zero\nsymm\nexact add_zero x", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by"]}
{"id": 58, "name": "le_succ", "statement": "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "proof": "intro h\ncases h with\n| intro c hc =>\n  use succ c\n  rw [hc, ← add_succ a c]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by"]}
{"id": 59, "name": "mul_le_mul_right", "statement": "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "proof": "intro a b t h\ncases h with\n| intro c hc =>\n  use (mul c t)\n  rw [hc]\n  exact add_mul a c t", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by"]}
{"id": 60, "name": "mul_left_ne_zero", "statement": "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "proof": "intro hb\napply h\nrw [hb]\nexact mul_zero a", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by"]}
{"id": 61, "name": "eq_succ_of_ne_zero", "statement": "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "proof": "revert ha\ncases a with\n| zero =>\n  intro h\n  cases (h rfl)\n| succ n =>\n  intro h\n  use n\n  exact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by"]}
{"id": 62, "name": "one_le_of_ne_zero", "statement": "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "proof": "intro a ha\ncases eq_succ_of_ne_zero a ha with\n| intro n hn =>\n  use n\n  rw [hn]\n  rw [succ_eq_add_one n]\n  rw [add_comm n one]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by"]}
{"id": 63, "name": "le_mul_right", "statement": "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by", "proof": "intro a b h\nhave hbne : b ≠ zero := by\n  apply mul_left_ne_zero a b\n  exact h\nhave honele : le one b := by\n  apply one_le_of_ne_zero b\n  exact hbne\nhave hmul : le (mul one a) (mul b a) := by\n  apply mul_le_mul_right one b a\n  exact honele\nrw [one_mul] at hmul\nrw [mul_comm b a] at hmul\nexact hmul", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by"]}
{"id": 64, "name": "mul_right_eq_one", "statement": "theorem mul_right_eq_one (x y : MyNat) (h : mul x y = one) : x = one := by", "proof": "  have hne : mul x y ≠ zero := by\n    intro hz\n    have hzo : zero = one := by\n      rw [hz] at h\n      exact h\n    have nz : zero ≠ one := by\n      have t := zero_ne_succ zero\n      rw [← one_eq_succ_zero] at t\n      exact t\n    exact nz hzo\n  have hxle : le x (mul x y) := by\n    apply le_mul_right\n    exact hne\n  rw [h] at hxle\n  have hx0or1 := le_one x hxle\n  cases hx0or1 with\n  | inl hx0 =>\n    have hzo : zero = one := by\n      have h' := h\n      rw [hx0] at h'\n      rw [zero_mul y] at h'\n      exact h'\n    have nz : zero ≠ one := by\n      have t := zero_ne_succ zero\n      rw [← one_eq_succ_zero] at t\n      exact t\n    have F : False := by exact nz hzo\n    cases F\n  | inr hx1 =>\n    exact hx1", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by"]}
{"id": 65, "name": "mul_ne_zero", "statement": "theorem mul_ne_zero (a b : MyNat) (ha : a ≠ zero) (hb : b ≠ zero) : mul a b ≠ zero := by", "proof": "cases (eq_succ_of_ne_zero a ha) with\n| intro n hn =>\n  rw [hn]\n  intro h\n  rw [succ_mul] at h\n  apply hb\n  apply add_left_eq_zero (mul n b) b\n  exact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by", "theorem mul_right_eq_one (x y : MyNat) (h : mul x y = one) : x = one := by"]}
{"id": 66, "name": "mul_eq_zero", "statement": "theorem mul_eq_zero (a b : MyNat) (h : mul a b = zero) : a = zero ∨ b = zero := by", "proof": "contrapose! h\napply mul_ne_zero a b\nintro ha0\napply h\nleft\nexact ha0\nintro hb0\napply h\nright\nexact hb0", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by", "theorem mul_right_eq_one (x y : MyNat) (h : mul x y = one) : x = one := by", "theorem mul_ne_zero (a b : MyNat) (ha : a ≠ zero) (hb : b ≠ zero) : mul a b ≠ zero := by"]}
{"id": 67, "name": "mul_left_cancel", "statement": "theorem mul_left_cancel (a b c : MyNat) (ha : a ≠ zero) (h : mul a b = mul a c) : b = c := by", "proof": "intro a b c ha h\ncases le_total b c with\n| inl hbc =>\n  cases hbc with\n  | intro k hk =>\n    have hk1 : mul a c = add (mul a b) (mul a k) := by\n      rw [hk, mul_add]\n    have hk2 := hk1\n    rw [← h] at hk2\n    have hk3 : add (mul a b) (mul a k) = mul a b := by\n      symm\n      exact hk2\n    have hmk0 : mul a k = zero := by\n      apply add_right_eq_self (mul a b) (mul a k)\n      exact hk3\n    have hcase := mul_eq_zero a k hmk0\n    cases hcase with\n    | inl ha0 =>\n      contradiction\n    | inr hk0 =>\n      rw [hk0, add_zero] at hk\n      symm\n      exact hk\n| inr hcb =>\n  cases hcb with\n  | intro k hk =>\n    have hb1 : mul a b = add (mul a c) (mul a k) := by\n      rw [hk, mul_add]\n    have hb2 : add (mul a c) (mul a k) = mul a c := by\n      have tmp := hb1\n      rw [h] at tmp\n      symm\n      exact tmp\n    have hmk0 : mul a k = zero := by\n      apply add_right_eq_self (mul a c) (mul a k)\n      exact hb2\n    have hcase := mul_eq_zero a k hmk0\n    cases hcase with\n    | inl ha0 =>\n      contradiction\n    | inr hk0 =>\n      rw [hk0, add_zero] at hk\n      exact hk", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by", "theorem mul_right_eq_one (x y : MyNat) (h : mul x y = one) : x = one := by", "theorem mul_ne_zero (a b : MyNat) (ha : a ≠ zero) (hb : b ≠ zero) : mul a b ≠ zero := by", "theorem mul_eq_zero (a b : MyNat) (h : mul a b = zero) : a = zero ∨ b = zero := by"]}
{"id": 68, "name": "mul_right_eq_self", "statement": "theorem mul_right_eq_self (a b : MyNat) (ha : a ≠ zero) (h : mul a b = a) : b = one := by", "proof": "rw [← mul_one a] at h\nexact mul_left_cancel a b one ha h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by", "theorem mul_right_eq_one (x y : MyNat) (h : mul x y = one) : x = one := by", "theorem mul_ne_zero (a b : MyNat) (ha : a ≠ zero) (hb : b ≠ zero) : mul a b ≠ zero := by", "theorem mul_eq_zero (a b : MyNat) (h : mul a b = zero) : a = zero ∨ b = zero := by", "theorem mul_left_cancel (a b c : MyNat) (ha : a ≠ zero) (h : mul a b = mul a c) : b = c := by"]}
