{"draft": "We aim to prove add zero n = n by induction on n.\nBase case: n = zero. The goal becomes add zero zero = zero. This follows directly from the axiom add_zero with a instantiated to zero; after rewriting, the goal is zero = zero, which holds by reflexivity.\nInductive step: assume the induction hypothesis ih: add zero d = d for some d, and prove add zero (succ d) = succ d. Using the axiom add_succ with a = zero, we rewrite the left-hand side to succ (add zero d). Then applying the induction hypothesis, this becomes succ d, giving succ d = succ d, which is reflexive.\nThus, by induction, add zero n = n for all n.", "code": "induction n with\n| zero =>\n  rw [add_zero]\n  exact rfl\n| succ d ih =>\n  rw [add_succ]\n  rw [ih]\n  exact rfl"}
{"draft": "Goal: Prove add (succ a) b = succ (add a b) using induction on b, since addition is defined recursively on its second argument.\n\nPlan:\n- Base case b = zero: The goal becomes add (succ a) zero = succ (add a zero). Using add_zero, rewrite the left to succ a and the right inner term add a zero to a, yielding succ a = succ a.\n- Inductive step b = succ d: Assume IH: add (succ a) d = succ (add a d). The goal is add (succ a) (succ d) = succ (add a (succ d)). Rewrite both sides using add_succ: the left becomes succ (add (succ a) d) and the right becomes succ (succ (add a d)). Then rewrite the inner add (succ a) d using the IH to get succ (succ (add a d)) on the left, which matches the right.\n\nThis completes the proof.", "code": "induction b with\n| zero =>\n  rw [add_zero (succ a)]\n  rw [add_zero a]\n| succ d ih =>\n  rw [add_succ (succ a) d]\n  rw [add_succ a d]\n  rw [ih]"}
{"draft": "Goal: Prove add_comm (a b) : add a b = add b a. Strategy: Induction on b. Base case b = zero: The goal is add a zero = add zero a. Rewrite LHS using add_zero to get a; rewrite RHS using zero_add to get a. Thus both sides are equal. Inductive step b = succ d with IH: add a d = add d a. We need add a (succ d) = add (succ d) a. Rewrite LHS with add_succ to succ (add a d). Rewrite RHS with succ_add to succ (add d a). Then use IH to rewrite add a d to add d a, giving succ (add d a) = succ (add d a), which is reflexive. Tactics used: induction, rw.", "code": "induction b with\n  | zero =>\n    rw [add_zero a, zero_add a]\n  | succ d ih =>\n    rw [add_succ a d, succ_add d a, ih]"}
{"draft": "We aim to prove associativity of add by induction on the third argument c. Base case c = zero: The goal becomes add (add a b) zero = add a (add b zero). Using the axiom add_zero twice, the left rewrites to add a b and the right to add a b, so the equality holds. Inductive step c = succ d with IH: add (add a b) d = add a (add b d). Starting from the goal add (add a b) (succ d) = add a (add b (succ d)), we rewrite the left using add_succ to get succ (add (add a b) d). On the right, first rewrite the inner add b (succ d) using add_succ to get add a (succ (add b d)), then rewrite again using add_succ to get succ (add a (add b d)). Now both sides are succ of some term; we rewrite the inner term on the left using the induction hypothesis IH to obtain succ (add a (add b d)) on both sides, completing the proof. No use of commutativity is needed.", "code": "induction c with\n| zero =>\n  repeat rw [add_zero]\n| succ d ih =>\n  rw [add_succ]\n  rw [add_succ]\n  rw [ih]"}
{"draft": "Goal: Prove add (add a b) c = add (add a c) b. Strategy: Use associativity to reassociate the left-hand side, then commutativity to swap b and c in the inner sum, and finally associativity again (in the reverse direction) to match the right-hand side. Steps: (1) Rewrite add (add a b) c to add a (add b c) using add_assoc. (2) Rewrite the inner add b c to add c b using add_comm. (3) Rewrite add a (add c b) to add (add a c) b using the reverse of add_assoc.", "code": "rw [add_assoc a b c]\nrw [add_comm b c]\nrw [← add_assoc a c b]"}
{"draft": "We want to show add a (add b c) = add b (add a c). The strategy is to use associativity and the provided right-commutativity. First, rewrite the left side using associativity in reverse to group a and b together: add a (add b c) becomes add (add a b) c. Next, apply add_right_comm to swap b and c in the right position relative to a: add (add a b) c becomes add (add a c) b. Finally, use add_comm to swap the two arguments at the outer level, turning add (add a c) b into add b (add a c), which matches the goal.", "code": "rw [← add_assoc a b c]\nrw [add_right_comm a b c]\nrw [add_comm (add a c) b]"}
{"draft": "Goal: Show succ n = add n one. Strategy: unfold one as succ zero and then use the right-argument recursion of addition. Steps: (1) Rewrite one using one_eq_succ_zero, so the goal becomes succ n = add n (succ zero). (2) Apply add_succ to the RHS to get succ n = succ (add n zero). (3) Simplify add n zero using add_zero to get succ n = succ n. (4) Close by reflexivity (exact rfl). No induction is needed.", "code": "rw [one_eq_succ_zero]\nrw [add_succ]\nrw [add_zero]\nexact rfl"}
{"draft": "The goal is to prove add x y = four. Among the hypotheses, we are given h1 : add x y = four, which exactly matches the goal. Therefore, we can conclude the goal immediately by using the hypothesis h1. The second hypothesis h2 is irrelevant for this conclusion and is not needed.", "code": "exact h1"}
{"draft": "Goal: From h: add zero x = add (add zero y) two, show x = add y two. Strategy: Use the lemma zero_add which states add zero n = n to simplify both sides of h. On the left, add zero x rewrites to x. On the right, the inner term add zero y rewrites to y, yielding add y two. After these rewrites, h becomes exactly x = add y two, which matches the goal. Then we conclude by exact h.", "code": "repeat rw [zero_add] at h\nexact h"}
{"draft": "We are given two hypotheses: h1 saying x = three, and h2 saying that if x = three then y = four. To prove y = four, we simply apply modus ponens: from h2 and h1 we can conclude y = four. In Lean, this is accomplished by providing the term h2 h1 to the goal y = four, which we can do with the 'exact' tactic.", "code": "exact (h2 h1)"}
{"draft": "Goal: from add x one = four, deduce x = three. Key idea: use succ_eq_add_one to convert add x one into succ x, and four_eq_succ_three to convert four into succ three, then apply succ_inj to cancel successors.\nSteps:\n- Reduce the goal x = three by applying succ_inj, which changes the goal to succ x = succ three.\n- Rewrite the left side succ x using succ_eq_add_one to get add x one.\n- Rewrite the right side succ three using the reverse of four_eq_succ_three to get four.\n- The goal becomes add x one = four, which is exactly the hypothesis h.\nThus, the result follows.", "code": "apply succ_inj x three\nrw [succ_eq_add_one x]\nrw [← four_eq_succ_three]\nexact h"}
{"draft": "We need to prove a tautological implication: from the assumption x = four, conclude x = four. The plan is straightforward: introduce the hypothesis h : x = four and immediately finish by exact h, since the goal matches the hypothesis.", "code": "intro h\nexact h"}
{"draft": "We want to show that add x one = add y one implies x = y. The key is to use the provided lemma succ_eq_add_one: succ n = add n one, which allows us to identify adding one with taking the successor. Given the hypothesis h: add x one = add y one, we rewrite both sides using the symmetry of succ_eq_add_one to turn add x one into succ x and add y one into succ y. This yields h: succ x = succ y. Then we apply the injectivity of succ, given by succ_inj, to conclude x = y.", "code": "intro h\nrw [← succ_eq_add_one x] at h\nrw [← succ_eq_add_one y] at h\nexact succ_inj x y h"}
{"draft": "We are given h1: x = y and h2: x ≠ y. In Lean, x ≠ y is a notation for x = y → False. Therefore, h2 can be directly applied to h1 to obtain a proof of False. No rewrites or case splits are necessary. The proof is a one-liner: exact h2 h1.", "code": "exact h2 h1"}
{"draft": "Goal: prove zero ≠ one. Since we know one = succ zero (by one_eq_succ_zero) and also have the general theorem zero_ne_succ (a : MyNat) : zero ≠ succ a, we can rewrite the goal zero ≠ one by replacing one with succ zero, yielding zero ≠ succ zero. This is exactly an instance of zero_ne_succ with a = zero. Therefore, the proof is a simple rewrite followed by exact.", "code": "rw [one_eq_succ_zero]\nexact zero_ne_succ zero"}
{"draft": "Goal: Prove one ≠ zero. Strategy: Use proof by contradiction. Assume h: one = zero. From the given theorem zero_ne_one: zero ≠ one (i.e., zero = one → False), we can obtain a contradiction if we can produce zero = one. From h, we can get zero = one by symmetry of equality. Tactically: introduce h, apply zero_ne_one to change the goal to zero = one, use symm to flip the goal to one = zero, then close with exact h.", "code": "intro h\napply zero_ne_one\nsymm\nexact h"}
{"draft": "Goal: show 2 + 2 ≠ 5. Strategy: Reduce the left side to 4, then use injectivity of succ to derive a contradiction. 1) Assume h: add (succ (succ zero)) (succ (succ zero)) = succ (succ (succ (succ (succ zero)))). 2) Normalize the left side of h using the recursion of add: rewrite twice by add_succ and once by add_zero to get h: succ (succ (succ (succ zero))) = succ (succ (succ (succ (succ zero)))). 3) To derive a contradiction, change the goal False into zero = succ zero by applying zero_ne_succ zero. 4) Use succ_inj four times on the goal to lift it to succ^4 zero = succ^5 zero, which exactly matches the normalized h. 5) Close by exact h, yielding the contradiction.", "code": "intro h\nrw [add_succ (succ (succ zero)) (succ zero)] at h\nrw [add_succ (succ (succ zero)) zero] at h\nrw [add_zero (succ (succ zero))] at h\napply (zero_ne_succ zero)\napply succ_inj\napply succ_inj\napply succ_inj\napply succ_inj\nexact h"}
{"draft": "Goal: Transform add (add a b) (add c d) into add (add (add a c) d) b using commutativity/associativity of add. Step 1: Apply add_right_comm with arguments (a, b, add c d) to swap b with the outer right term, obtaining add (add a (add c d)) b. Step 2: Use associativity in reverse (← add_assoc a c d) to regroup the inner add: add a (add c d) becomes add (add a c) d. This yields add (add (add a c) d) b, which matches the target.", "code": "rw [add_right_comm a b (add c d)]\nrw [← add_assoc a c d]"}
{"draft": "We need to prove that for any MyNat a, succ a ≠ zero. We already have the complementary fact zero ≠ succ a. The plan is by contradiction: assume succ a = zero. Then by symmetry of equality, we get zero = succ a. This contradicts zero_ne_succ a. In Lean tactics: introduce the assumption h : succ a = zero. Create hz : zero = succ a by using symm to flip the goal and then exact h. Then obtain hne : zero ≠ succ a from zero_ne_succ a. Apply hne to reduce the goal to proving zero = succ a, which is exactly hz. This yields a contradiction and completes the proof.", "code": "intro h\nhave hz : zero = succ a := by\n  symm\n  exact h\nhave hne : zero ≠ succ a := zero_ne_succ a\napply hne\nexact hz"}
{"draft": "Goal: Show succ m ≠ succ n from m ≠ n. Strategy: Prove by contradiction. Assume succ m = succ n. By the injectivity of succ (succ_inj), this implies m = n, which contradicts h : m ≠ n. Therefore succ m ≠ succ n. In Lean tactics: introduce the assumption succ m = succ n, then apply h to reduce the goal to m = n, derive m = n via succ_inj using the introduced assumption, and conclude the contradiction.", "code": "intro hsn\napply h\napply succ_inj m n\nexact hsn"}
{"draft": "Goal: Show mul m one = m. Plan: Unfold one as succ zero. Then apply the multiplication-by-successor axiom mul_succ with b = zero to rewrite mul m (succ zero) as add (mul m zero) m. Next, rewrite mul m zero to zero using mul_zero. Then simplify add zero m to m using the lemma zero_add. The goal reduces to m = m, which is closed by reflexivity.", "code": "rw [one_eq_succ_zero]\nrw [mul_succ]\nrw [mul_zero]\nrw [zero_add]\nexact rfl"}
{"draft": "Goal: Prove zero_mul (m : MyNat) : mul zero m = zero. Strategy: Use induction on m. Base case m = zero: mul zero zero = zero by the axiom mul_zero. Inductive step: assume IH: mul zero d = zero. For m = succ d, use the axiom mul_succ to rewrite mul zero (succ d) to add (mul zero d) zero. Then rewrite mul zero d to zero using IH, yielding add zero zero, and finally use add_zero to simplify to zero. This completes the induction.", "code": "induction m with\n| zero =>\n  rw [mul_zero]\n| succ d ih =>\n  rw [mul_succ]\n  rw [ih]\n  rw [add_zero]"}
{"draft": "We aim to prove mul (succ a) b = add (mul a b) b by induction on b.\n\nBase case (b = zero):\n- LHS: mul (succ a) zero = zero by mul_zero.\n- RHS: add (mul a zero) zero = add zero zero by mul_zero = zero by zero_add.\n- Hence both sides are zero.\n\nInductive step (b = succ d, with IH: mul (succ a) d = add (mul a d) d):\n- Start from LHS: mul (succ a) (succ d) = add (mul (succ a) d) (succ a) by mul_succ.\n- Apply IH on mul (succ a) d to get LHS = add (add (mul a d) d) (succ a).\n- Rewrite RHS using mul_succ: add (mul a (succ d)) (succ d) = add (add (mul a d) a) (succ d).\n- Replace succs with addition of one via succ_eq_add_one on both sides: becomes add (add (mul a d) d) (add a one) = add (add (mul a d) a) (add d one).\n- Reassociate both sides using ← add_assoc to factor out the trailing one: both sides become add (...) one with inner terms add (add (mul a d) d) a and add (add (mul a d) a) d.\n- Reduce the goal by applying congrArg (fun t => add t one), turning it into add (add (mul a d) d) a = add (add (mul a d) a) d.\n- This is exactly add_right_comm with a := mul a d, b := d, c := a.\n\nThus the statement holds for all b.", "code": "induction b with\n| zero =>\n  rw [mul_zero]\n  rw [mul_zero]\n  rw [zero_add]\n  exact rfl\n| succ d ih =>\n  rw [mul_succ]\n  rw [ih]\n  rw [mul_succ]\n  repeat rw [succ_eq_add_one]\n  rw [← add_assoc]\n  apply congrArg (fun t => add t one)\n  exact add_right_comm (mul a d) d a"}
{"draft": "We prove commutativity of multiplication by induction on the second argument b, using the provided recursion laws for mul and the distributive identities involving succ.\n\nPlan:\n- Base case b = zero: mul a zero rewrites to zero by mul_zero, and mul zero a rewrites to zero by zero_mul, so both sides are zero and the equality holds by reflexivity.\n- Inductive step b = succ d with IH: mul a d = mul d a. We rewrite the left side using mul_succ: mul a (succ d) = add (mul a d) a. We rewrite the right side using succ_mul: mul (succ d) a = add (mul d a) a. Then use the induction hypothesis to rewrite mul a d to mul d a inside the left side, making both sides identical, closing by reflexivity.", "code": "induction b with\n| zero =>\n  rw [mul_zero, zero_mul]\n  exact rfl\n| succ d ih =>\n  rw [mul_succ a d, succ_mul d a]\n  rw [ih]\n  exact rfl"}
{"draft": "Goal: Prove one_mul (m : MyNat) : mul one m = m.\nPlan: Use the commutativity of multiplication to swap the factors, turning mul one m into mul m one. Then apply the known theorem mul_one to conclude mul m one = m. This uses only the provided theorems mul_comm and mul_one, and requires two straightforward rewrites.", "code": "rw [mul_comm]\nrw [mul_one]"}
{"draft": "We aim to show mul two m = add m m. First, rewrite two as succ one using two_eq_succ_one. This turns the goal into mul (succ one) m. Next, apply succ_mul, which states mul (succ a) b = add (mul a b) b, with a = one and b = m. This yields add (mul one m) m. Finally, simplify mul one m to m using one_mul. The result is add m m, as required.", "code": "rw [two_eq_succ_one]\nrw [succ_mul]\nrw [one_mul]"}
{"draft": "We prove left-distributivity of multiplication over addition by induction on c.\n\nBase case (c = zero):\n- Goal: mul a (add b zero) = add (mul a b) (mul a zero).\n- Rewrite add b zero using add_zero to get mul a b on the left.\n- Rewrite mul a zero to zero using mul_zero; the right becomes add (mul a b) zero.\n- Rewrite add (mul a b) zero to mul a b using add_zero. Both sides match.\n\nInductive step (c = succ d), with IH: mul a (add b d) = add (mul a b) (mul a d):\n- Rewrite add b (succ d) using add_succ to get succ (add b d) inside the multiplication on the left.\n- Rewrite both occurrences of mul a (succ ...) using mul_succ: on the left to add (mul a (add b d)) a, and on the right to add (mul a b) (add (mul a d) a).\n- Apply the induction hypothesis to replace mul a (add b d) with add (mul a b) (mul a d) on the left; the left becomes add (add (mul a b) (mul a d)) a.\n- Use associativity add_assoc to re-associate to add (mul a b) (add (mul a d) a), which matches the right-hand side.\n\nOnly rw and induction are used, along with the given axioms and theorems.", "code": "induction c with\n| zero =>\n  rw [add_zero]\n  rw [mul_zero]\n  rw [add_zero]\n| succ d ih =>\n  rw [add_succ]\n  rw [mul_succ]\n  rw [mul_succ]\n  rw [ih]\n  rw [add_assoc]"}
{"draft": "Goal: show left distributivity of multiplication over addition. Strategy: use commutativity of multiplication to swap the arguments and then apply the given right-distributivity theorem mul_add. Steps: (1) Rewrite the left-hand side mul (add a b) c using mul_comm to get mul c (add a b). (2) Apply mul_add with parameters (c, a, b) to rewrite this as add (mul c a) (mul c b). (3) Use commutativity mul_comm on each factor to turn mul c a into mul a c and mul c b into mul b c. The goal then becomes an identity and is closed by rfl.", "code": "rw [mul_comm (add a b) c]\nrw [mul_add c a b]\nrw [mul_comm c a]\nrw [mul_comm c b]\nexact rfl"}
{"draft": "We prove associativity of multiplication by induction on c.\nBase case (c = zero): The left side reduces via mul_zero to zero. On the right, first rewrite mul b zero to zero (mul_zero), then mul a zero to zero (mul_zero). Both sides become zero.\nInductive step (c = succ d): Expand the left side using mul_succ with a = mul a b and b = d to get add (mul (mul a b) d) (mul a b). For the right side, first rewrite mul b (succ d) via mul_succ to add (mul b d) b, then distribute mul a over this addition using mul_add to get add (mul a (mul b d)) (mul a b). Apply the induction hypothesis mul (mul a b) d = mul a (mul b d) to the first term on the left, making both sides identical. Conclude by reflexivity.", "code": "induction c with\n| zero =>\n  rw [mul_zero]\n  rw [mul_zero b]\n  rw [mul_zero a]\n| succ d ih =>\n  rw [mul_succ (mul a b) d]\n  rw [mul_succ b d]\n  rw [mul_add a (mul b d) b]\n  rw [ih]\n  exact rfl"}
{"draft": "We want to prove pow zero zero = one. There is a direct axiom pow_zero (m : MyNat) : pow m zero = one, which holds for any base m. By specializing this axiom to m = zero, we obtain exactly the desired statement. Therefore, we can conclude the theorem immediately by exact pow_zero zero.", "code": "exact pow_zero zero"}
{"draft": "We want to show that zero raised to a successor exponent is zero. Using the power recursion axiom pow_succ specialized to base zero, we have pow zero (succ m) = mul (pow zero m) zero. Then we apply the multiplication axiom mul_zero, which states mul a zero = zero for any a. With a = pow zero m, this simplifies the expression to zero, completing the proof. No induction is needed.", "code": "rw [pow_succ zero m]\nrw [mul_zero (pow zero m)]"}
{"draft": "Goal: Show pow a one = a. Plan: Replace one with succ zero using the given equality one_eq_succ_zero. Then apply the power successor axiom pow_succ to rewrite pow a (succ zero) into mul (pow a zero) a. Next, use pow_zero to rewrite pow a zero to one. The goal becomes mul one a = a, which matches exactly the theorem one_mul, so conclude by exact one_mul a.", "code": "rw [one_eq_succ_zero]\nrw [pow_succ]\nrw [pow_zero]\nexact one_mul a"}
{"draft": "We prove by induction on m.\n- Base case m = zero: pow one zero = one by the axiom pow_zero with m = one.\n- Inductive step m = succ d: Assume IH: pow one d = one. Then\n  pow one (succ d) = mul (pow one d) one by pow_succ,\n  = mul one one by IH,\n  = one by mul_one.\nThus pow one m = one for all m.", "code": "induction m with\n| zero =>\n  rw [pow_zero]\n| succ d ih =>\n  rw [pow_succ, ih, mul_one]"}
{"draft": "Goal: Show pow a two = mul a a. Strategy: Unfold two using two_eq_succ_one to rewrite the exponent as succ one. Then apply the axiom pow_succ to rewrite pow a (succ one) into mul (pow a one) a. Next, use the theorem pow_one to simplify pow a one to a. After these rewrites, both sides of the equation become mul a a, and we close by reflexivity. Steps: 1) rw [two_eq_succ_one] to get pow a (succ one) = mul a a. 2) rw [pow_succ] to get mul (pow a one) a = mul a a. 3) rw [pow_one] to get mul a a = mul a a. 4) exact rfl.", "code": "rw [two_eq_succ_one]\nrw [pow_succ]\nrw [pow_one]\nexact rfl"}
{"draft": "We prove pow_add by induction on the exponent n.\nBase case n = zero:\n- LHS: pow a (add m zero). Using add_zero, this becomes pow a m.\n- RHS: mul (pow a m) (pow a zero). Using pow_zero, this is mul (pow a m) one, and then mul_one simplifies it to pow a m.\nThus both sides are equal.\nInductive step n = succ d, with IH: pow a (add m d) = mul (pow a m) (pow a d).\n- Start from pow a (add m (succ d)). Using add_succ, rewrite the exponent to succ (add m d), so the LHS becomes pow a (succ (add m d)).\n- Apply pow_succ to both sides: LHS becomes mul (pow a (add m d)) a, RHS becomes mul (pow a m) (mul (pow a d) a).\n- Rewrite pow a (add m d) via the IH to mul (pow a m) (pow a d).\n- Now LHS is mul (mul (pow a m) (pow a d)) a, and by mul_assoc this equals mul (pow a m) (mul (pow a d) a), which matches the RHS.\nThus the inductive step holds, completing the proof.", "code": "induction n with\n| zero =>\n  rw [add_zero, pow_zero, mul_one]\n| succ d ih =>\n  rw [add_succ]\n  repeat rw [pow_succ]\n  rw [ih]\n  rw [mul_assoc]"}
{"draft": "Goal: prove pow (mul a b) n = mul (pow a n) (pow b n) for all a b n. Strategy: induction on n using the axioms for exponentiation (pow_zero, pow_succ). Base case n = zero: pow (ab) 0 = 1; RHS is mul (pow a 0) (pow b 0) = mul 1 1. Rewrite both sides with pow_zero, then use one_mul to conclude 1 = 1. Inductive step n = succ d: expand all powers with pow_succ to get mul (pow (ab) d) (ab) = mul (mul (pow a d) a) (mul (pow b d) b). Use the induction hypothesis to replace pow (ab) d by mul (pow a d) (pow b d). Now we must show mul (mul X Y) (mul a b) = mul (mul X a) (mul Y b) where X = pow a d and Y = pow b d. Using associativity and commutativity of multiplication, we rearrange only the left-hand side to match the right-hand side. We do this carefully with nth_rewrite to avoid rewriting the right-hand side: 1) associate LHS as mul X (mul Y (mul a b)); 2) reassociate the inner to mul (mul Y a) b; 3) reassociate outer to mul (mul X (mul Y a)) b; 4) commute Y and a to get mul (mul X (mul a Y)) b; 5) reassociate inner to mul (mul X a) Y; 6) reassociate outer to mul (mul X a) (mul Y b). The goal then becomes an obvious reflexive equality.", "code": "induction n with\n| zero =>\n  repeat rw [pow_zero]\n  rw [one_mul]\n  exact rfl\n| succ d ih =>\n  repeat rw [pow_succ]\n  rw [ih]\n  nth_rewrite 1 [mul_assoc]\n  nth_rewrite 2 [← mul_assoc]\n  nth_rewrite 1 [← mul_assoc]\n  nth_rewrite 1 [mul_comm (pow b d) a]\n  nth_rewrite 1 [← mul_assoc]\n  nth_rewrite 1 [mul_assoc]\n  exact rfl"}
{"draft": "We prove (a^m)^n = a^(m*n) by induction on n.\n- Base n = zero: LHS is pow (pow a m) zero = one by pow_zero. RHS is pow a (mul m zero). Using mul_zero, mul m zero = zero, hence RHS = pow a zero = one. So both sides are one.\n- Inductive step n -> succ n: Rewrite LHS using pow_succ to get mul (pow (pow a m) n) (pow a m). By the IH, pow (pow a m) n = pow a (mul m n), so LHS becomes mul (pow a (mul m n)) (pow a m). On the RHS, use mul_succ to rewrite mul m (succ n) as add (mul m n) m, then apply pow_add to turn pow a (add (mul m n) m) into mul (pow a (mul m n)) (pow a m). Both sides match.\nOnly rw is used with the given axioms/theorems.", "code": "induction n with\n| zero =>\n  rw [pow_zero]\n  rw [mul_zero, pow_zero]\n| succ n ih =>\n  rw [pow_succ]\n  rw [ih]\n  rw [mul_succ]\n  rw [pow_add]"}
{"draft": "Goal: prove (a + b)^2 = a^2 + b^2 + 2ab. Plan:\n1) Rewrite the power using pow_two: pow (a + b) two = mul (add a b) (add a b).\n2) Distribute using add_mul and mul_add to expand (a + b)(a + b) into aa + ab + ba + bb.\n3) Use mul_comm to replace ba with ab so the cross terms are identical.\n4) Reassociate sums to group the cross terms together and rewrite ab + ab as mul two (mul a b) via the backwards direction of two_mul.\n5) Reassociate to obtain (aa + bb) + [mul two (mul a b)], and then use mul_assoc (backwards) to rewrite mul two (mul a b) as mul (mul two a) b.\n6) Finally, rewrite aa and bb back to pow a two and pow b two using the backwards direction of pow_two. This yields the desired RHS form.", "code": "rw [pow_two (add a b)]\nrw [add_mul a b (add a b)]\nrw [mul_add a a b]\nrw [mul_add b a b]\nrw [add_assoc (mul a a) (mul a b) (add (mul b a) (mul b b))]\nrw [mul_comm b a]\nrw [← add_assoc (mul a b) (mul a b) (mul b b)]\nrw [← two_mul (mul a b)]\nrw [← add_assoc (mul a a) (mul two (mul a b)) (mul b b)]\nrw [add_right_comm (mul a a) (mul two (mul a b)) (mul b b)]\nrw [← mul_assoc two a b]\nrw [← pow_two a]\nrw [← pow_two b]"}
{"draft": "We want to prove right-cancellation for addition: if add a n = add b n, then a = b. The natural approach is induction on n using the definition of addition on the right argument. To make the induction hypothesis applicable, we revert the hypothesis h so that in the inductive step we obtain ih: add a d = add b d → a = b. Base case n = zero: rewrite both sides of h with add_zero to get a = b directly. Inductive step n = succ d: rewrite h using add_succ on both sides to obtain succ (add a d) = succ (add b d). Apply succ_inj to cancel the outer succ, yielding add a d = add b d, and then apply the induction hypothesis ih to conclude a = b.", "code": "intro h\nrevert h\ninduction n with\n| zero =>\n  intro h\n  repeat rw [add_zero] at h\n  exact h\n| succ d ih =>\n  intro h\n  repeat rw [add_succ] at h\n  apply ih\n  apply succ_inj (add a d) (add b d)\n  exact h"}
{"draft": "Goal: Prove add_left_cancel: from add n a = add n b, deduce a = b. Strategy: use the already available add_right_cancel, which cancels the right addend: add a n = add b n → a = b. To fit our hypothesis into that form, we rewrite the goal of add_right_cancel to match our hypothesis. Specifically, after applying add_right_cancel a b n, the new goal becomes add a n = add b n. We then rewrite both sides of this goal using commutativity: rw [add_comm a n] rewrites the left to add n a, and rw [add_comm b n] rewrites the right to add n b. This yields exactly the original hypothesis h, which we then close by exact h.", "code": "intro h\napply add_right_cancel a b n\nrw [add_comm a n]\nrw [add_comm b n]\nexact h"}
{"draft": "Goal: From add x y = y, show x = zero. Strategy: rewrite the right-hand side y as add zero y using zero_add, then apply add_right_cancel with n = y to cancel the common addend y on the right. Steps: (1) Introduce hypothesis h : add x y = y. (2) Rewrite h using y = add zero y (i.e., rw [← zero_add y] at h) to get add x y = add zero y. (3) Apply add_right_cancel x zero y to conclude x = zero from the equality add x y = add zero y.", "code": "intro h\nrw [← zero_add y] at h\napply add_right_cancel x zero y\nexact h"}
{"draft": "We want to deduce y = zero from the hypothesis h: add x y = x. The available theorem add_left_eq_self states: add a b = b → a = zero. If we swap the arguments (a := y, b := x), it becomes: add y x = x → y = zero. So it suffices to prove add y x = x. From commutativity of addition, add y x = add x y, so rewriting the goal with add_comm reduces it to add x y = x, which is exactly our hypothesis h. Steps: introduce h; apply add_left_eq_self y x to reduce the goal to add y x = x; rewrite with add_comm to obtain add x y = x; close with h.", "code": "intro h\napply (add_left_eq_self y x)\nrw [add_comm y x]\nexact h"}
{"draft": "Goal: Prove add a b = zero → a = zero. Plan: Do a case split on b.\n- Case b = zero: From the hypothesis h : add a zero = zero, use add_zero to rewrite the left side to a, so h becomes a = zero, which is the goal.\n- Case b = succ d: Instead of proving the implication directly, prove its contrapositive using contrapose!. That is, show a ≠ zero → add a (succ d) ≠ zero. Then rewrite add a (succ d) using add_succ to succ (add a d), and show succ (add a d) ≠ zero. To prove an inequality x ≠ y, assume x = y and derive a contradiction. Here, assume succ (add a d) = zero, symmetrize it to zero = succ (add a d), which contradicts zero_ne_succ (add a d). This closes the contrapositive and thus the original implication.", "code": "cases b with\n| zero =>\n  intro h\n  rw [add_zero] at h\n  exact h\n| succ d =>\n  contrapose!\n  rw [add_succ]\n  intro h\n  symm at h\n  apply zero_ne_succ (add a d)\n  exact h"}
{"draft": "Goal: Prove that if add a b = zero, then b = zero. Plan: Use commutativity of addition to rewrite add a b as add b a. Then apply the available theorem add_right_eq_zero, which states that if add x y = zero then x = zero, with x := b and y := a. Steps: (1) Introduce the hypothesis h : add a b = zero. (2) Rewrite h using add_comm to get h : add b a = zero. (3) Apply add_right_eq_zero with arguments (b, a) to obtain b = zero.", "code": "intro h\nrw [add_comm] at h\nexact add_right_eq_zero b a h"}
{"draft": "Goal: prove le x x. By definition, le a b means there exists c with b = add a c. We can use the provided equivalence le_iff_exists_add to rewrite the goal into an existential. After rewriting, the goal is to find c such that x = add x c. Choosing c = zero works, because add x zero = x by add_zero. Since the equality we need is the reverse direction (x = add x zero), we take symmetry of add_zero x to finish.", "code": "rw [le_iff_exists_add x x]\nuse zero\nsymm\nexact add_zero x"}
{"draft": "Goal: prove le zero x, which by definition means there exists c such that x = add zero c. A natural witness is c = x. With this choice, we need to show x = add zero x. From the available theorem zero_add, we know add zero x = x. Taking symmetry of this equality yields x = add zero x, which completes the proof.", "code": "use x\nsymm\nexact zero_add x"}
{"draft": "Goal: Prove le x (succ x), i.e., there exists a c such that succ x = add x c. Strategy: Choose c = one. By the provided theorem succ_eq_add_one, we have succ x = add x one. Thus the existential condition is satisfied, and le x (succ x) holds.", "code": "use one\nexact succ_eq_add_one x"}
{"draft": "We aim to prove transitivity of le, which is defined by existence of a witness c with b = add a c. Given hxy : le x y and hyz : le y z, we unpack these existentials to obtain c and d such that y = add x c and z = add y d. To prove le x z, it suffices to produce a witness for z = add x something. We choose the witness e := add c d. Then we show z = add x (add c d) by rewriting z using hyz, then rewriting y using hxy, and finally applying associativity add_assoc to transform add (add x c) d into add x (add c d). This gives a reflexive equality, completing the proof.", "code": "cases hxy with\n| intro c hxyEq =>\n  cases hyz with\n  | intro d hyzEq =>\n    use (add c d)\n    rw [hyzEq]\n    rw [hxyEq]\n    rw [add_assoc]\n    exact rfl"}
{"draft": "Goal: From hx : le x zero, deduce x = zero. By definition, le x zero means there exists c such that zero = add x c. So destruct hx to get c and h : zero = add x c. To derive x = zero, we can use the theorem add_right_eq_zero: if add a b = zero then a = zero. We need a proof of add x c = zero. Our h is the reverse equality, so we flip it using symmetry on the goal: after applying add_right_eq_zero x c, the goal becomes add x c = zero; use the 'symm' tactic to change the goal to zero = add x c, which is exactly h; then close with exact h.", "code": "cases hx with\n| intro c h =>\n  apply add_right_eq_zero x c\n  symm\n  exact h"}
{"draft": "Goal: Prove antisymmetry of le. Given hxy: le x y and hyx: le y x, we have witnesses c and d such that y = add x c and x = add y d. Substitute y into the second equation to obtain x = add (add x c) d, which by associativity becomes x = add x (add c d). Symmetrize to get add x (add c d) = x. By add_right_eq_self, this implies add c d = zero. From add_left_eq_zero, deduce d = zero (and we could also deduce c = zero via add_right_eq_zero if needed). Now return to x = add y d and rewrite d = zero, then apply add_zero to obtain x = y. Steps:\n- Destructure hxy to get c, hc: y = add x c.\n- Destructure hyx to get d, hd: x = add y d.\n- Let h1 := hd, rewrite using hc and add_assoc to get h1: x = add x (add c d), then symm h1: add x (add c d) = x.\n- From add_right_eq_self, get hcd0: add c d = zero.\n- From add_left_eq_zero on hcd0, get hd0: d = zero.\n- Rewrite hd with hd0 and add_zero to conclude x = y.", "code": "cases hxy with\n| intro c hc =>\n  cases hyx with\n  | intro d hd =>\n    have h1 := hd\n    rw [hc] at h1\n    rw [add_assoc] at h1\n    symm at h1\n    have hcd0 := add_right_eq_self x (add c d) h1\n    have hd0 := add_left_eq_zero c d hcd0\n    rw [hd0, add_zero] at hd\n    exact hd"}
{"draft": "We need to prove the symmetry of a disjunction: from h : x = four ∨ y = three, derive y = three ∨ x = four. The plan is to perform case analysis on h using the cases tactic. There are two cases:\n- Case h = inl hx with hx : x = four. Then we can build the goal y = three ∨ x = four by choosing the right side and providing hx.\n- Case h = inr hy with hy : y = three. Then we build the goal by choosing the left side and providing hy.\nThis directly constructs the desired disjunction by switching the order of the alternatives.", "code": "cases h with\n| inl hx =>\n  right\n  exact hx\n| inr hy =>\n  left\n  exact hy"}
{"draft": "Goal: Prove le_total: for any x y : MyNat, le x y ∨ le y x. Since le a b is defined as ∃ c, b = add a c, we aim to show that either y is a plus something or x is y plus something.\n\nPlan: We generalize over y and perform induction on x with y reverted, so the induction hypothesis applies to all y.\n\n- After reverting y, perform induction on x.\n\nBase case x = zero:\n- For any y, le zero y holds by zero_le, so the left disjunct is satisfied.\n\nInductive step x = succ a, with IH: ∀ y, le a y ∨ le y a. We now handle arbitrary y by cases on y.\n- If y = zero: Then le zero (succ a) holds by zero_le, so the right disjunct holds.\n- If y = succ b: Apply IH to b to get le a b ∨ le b a. Do case analysis:\n  * If le a b, then there exists c with b = add a c. We want le (succ a) (succ b), i.e., ∃ c, succ b = add (succ a) c. Using b = add a c, we rewrite succ b to succ (add a c), which by the lemma succ_add equals add (succ a) c. Thus le (succ a) (succ b).\n  * If le b a, then there exists c with a = add b c. We want le (succ b) (succ a), i.e., ∃ c, succ a = add (succ b) c. Rewriting succ a as succ (add b c) and using succ_add again yields add (succ b) c, giving the desired inequality.\n\nThis covers all cases and establishes totality of le.", "code": "revert y\ninduction x with\n| zero =>\n  intro y\n  left\n  exact zero_le y\n| succ a ih =>\n  intro y\n  cases y with\n  | zero =>\n    right\n    exact zero_le (succ a)\n  | succ b =>\n    have h := ih b\n    cases h with\n    | inl h1 =>\n      left\n      cases h1 with\n      | intro c hc =>\n        use c\n        rw [hc]\n        symm\n        apply succ_add\n    | inr h2 =>\n      right\n      cases h2 with\n      | intro c hc =>\n        use c\n        rw [hc]\n        symm\n        apply succ_add"}
{"draft": "We need to show le x y from hx : le (succ x) (succ y). By the definition of le, hx provides a witness c with succ y = add (succ x) c. Using the theorem succ_add, we can rewrite add (succ x) c to succ (add x c), thus obtaining succ y = succ (add x c). Applying succ_inj to this equality cancels the succ on both sides, yielding y = add x c. This exactly matches the definition of le x y with the same witness c. Thus, we can conclude le x y by providing c.", "code": "cases hx with\n| intro c hc =>\n  use c\n  rw [succ_add] at hc\n  apply succ_inj y (add x c)\n  exact hc"}
{"draft": "We unfold the definition of le: hx means there exists c with one = add x c. We split by cases on c.\n- If c = zero, then one = add x zero = x by add_zero. Thus x = one and we conclude the right disjunct.\n- If c = succ d, then one = add x (succ d) = succ (add x d) by add_succ. Also, one = succ zero, so succ zero = succ (add x d). By succ_inj we get zero = add x d, hence add x d = zero. By add_right_eq_zero, this implies x = zero, giving the left disjunct.\nThis covers all possibilities, proving x = zero ∨ x = one.", "code": "cases hx with\n| intro c hc =>\n  cases c with\n  | zero =>\n    have h1 := hc\n    rw [add_zero] at h1\n    symm at h1\n    right\n    exact h1\n  | succ d =>\n    have h1 := hc\n    rw [add_succ] at h1\n    rw [one_eq_succ_zero] at h1\n    have h2 : zero = add x d := by\n      apply succ_inj zero (add x d)\n      exact h1\n    symm at h2\n    have hxz : x = zero := by\n      apply add_right_eq_zero x d\n      exact h2\n    left\n    exact hxz"}
{"draft": "Plan: Use the definition of le to express hx as an existence: two = add x c for some c. Proceed by cases on x.\n- If x = zero, we are done with the left disjunct.\n- If x = succ x1, rewrite the equality two = add (succ x1) c using two = succ one and succ_add to get succ one = succ (add x1 c). Apply succ_inj to deduce one = add x1 c. Now case-split on x1:\n  - If x1 = zero, then x = succ zero = one, giving the middle disjunct.\n  - If x1 = succ x2, then one = add (succ x2) c; rewrite as succ zero = succ (add x2 c) and apply succ_inj to get zero = add x2 c. Symmetrize to add x2 c = zero, and use add_right_eq_zero and add_left_eq_zero to deduce x2 = zero and c = zero. Hence x = succ (succ zero) = two, giving the rightmost disjunct.", "code": "cases hx with\n| intro c h =>\n  cases x with\n  | zero =>\n    left\n    exact rfl\n  | succ x1 =>\n    rw [two_eq_succ_one] at h\n    rw [succ_add] at h\n    have h1 : one = add x1 c := by\n      exact succ_inj one (add x1 c) h\n    cases x1 with\n    | zero =>\n      right; left\n      symm\n      exact one_eq_succ_zero\n    | succ x2 =>\n      rw [one_eq_succ_zero] at h1\n      rw [succ_add] at h1\n      have hz0 : zero = add x2 c := by\n        exact succ_inj zero (add x2 c) h1\n      have hz : add x2 c = zero := by\n        symm\n        exact hz0\n      have hx2 : x2 = zero := by\n        exact add_right_eq_zero x2 c hz\n      have hc : c = zero := by\n        exact add_left_eq_zero x2 c hz\n      right; right\n      rw [hx2]\n      rw [two_eq_succ_one]\n      rw [one_eq_succ_zero]\n      exact rfl"}
{"draft": "Goal: le x (add one x). By definition, le a b means there exists c such that b = add a c. So we need to produce a c with add one x = add x c. Choose c = one. Then the required equality is add one x = add x one, which holds by add_comm. Therefore, we witness c = one and apply add_comm to finish.", "code": "use one\nexact add_comm one x"}
{"draft": "Goal: Prove le x x. By definition, le a b means there exists c such that b = add a c. To show le x x, it suffices to exhibit a specific c with x = add x c. Choose c = zero. Then we need to prove x = add x zero. Using the axiom add_zero, we know add x zero = x. So by symmetry, x = add x zero. Therefore, the witness c = zero satisfies the definition, and le x x holds.\n\nSteps:\n- Introduce the existential witness: use zero.\n- Change the goal from x = add x zero to add x zero = x via symm.\n- Close the goal with the axiom add_zero.", "code": "use zero\nsymm\napply add_zero"}
{"draft": "We must show that if a ≤ b (by the given le definition), then a ≤ succ b. By definition, le a b means there exists c such that b = add a c. From this witness c, we can construct a witness for le a (succ b) as succ c. Indeed, starting from succ b, rewrite b using b = add a c to get succ (add a c). Then use the axiom add_succ: add a (succ c) = succ (add a c). Rewriting the right-hand side with add_succ makes the goal succ (add a c) = succ (add a c), which is reflexive. Therefore, we can produce the required witness succ c and conclude le a (succ b).", "code": "intro h\ncases h with\n| intro c hc =>\n  use succ c\n  rw [hc]\n  rw [add_succ a c]\n  exact rfl"}
{"draft": "Goal: Show le (mul a t) (mul b t). By definition of le, this means we need to exhibit some c' such that mul b t = add (mul a t) c'. From h : le a b, unpack it to get a witness c with b = add a c. Multiply this equality on the right by t and use left distributivity: mul (add a c) t = add (mul a t) (mul c t) (by add_mul). Thus, taking c' = mul c t witnesses the desired inequality.\n\nProof steps:\n- Destructure h to obtain c and hc : b = add a c.\n- Use the existential introduction with witness mul c t.\n- Rewrite the goal using hc to get mul (add a c) t = add (mul a t) (mul c t).\n- Rewrite using add_mul a c t to close the goal.", "code": "intro a b t h\ncases h with\n| intro c hc =>\n  use mul c t\n  rw [hc]\n  rw [add_mul a c t]\n"}
{"draft": "We need to show that if mul a b ≠ 0, then b ≠ 0. We'll prove this by direct contradiction: assume b = 0 and derive mul a b = 0, which contradicts the given hypothesis. Concretely: introduce hb : b = zero. To reach a contradiction from h : mul a b ≠ zero, we will change the goal to proving mul a b = zero using 'apply h'. Then rewrite using hb to turn mul a b into mul a zero, and use the axiom mul_zero a : mul a zero = zero to finish. This yields the required contradiction, completing the proof.", "code": "intro hb\napply h\nrw [hb]\nexact mul_zero a"}
{"draft": "We want to show that any nonzero MyNat is a successor. Proceed by case analysis on a.\n- Case a = zero: The hypothesis ha becomes zero ≠ zero, which is contradictory since zero = zero by reflexivity. We can close this branch using the contradiction tactic (it uses rfl internally to derive the contradiction). Alternatively, we could explicitly derive False via ha rfl and close the goal by cases on False.\n- Case a = succ n: Then we can exhibit n as the witness for the existential, and the equality a = succ n holds by rfl.\nThus, the two cases cover all possibilities for a and complete the proof.", "code": "cases a with\n| zero =>\n  contradiction\n| succ n =>\n  use n\n  rfl"}
{"draft": "Goal: show le one a (i.e., ∃ c, a = add one c) given a ≠ zero. By eq_succ_of_ne_zero, from ha we get a = succ n for some n. Rewrite the goal with this equality to reduce to proving le one (succ n), which by definition means ∃ c, succ n = add one c. Choose c = n. It remains to show succ n = add one n. Using succ_eq_add_one, we have succ n = add n one, and then by add_comm we get add n one = add one n. Thus the required equality holds, and hence le one a.", "code": "cases eq_succ_of_ne_zero a ha with\n| intro n hn =>\n  rw [hn]\n  use n\n  rw [succ_eq_add_one n, add_comm]\n"}
{"draft": "Goal: show le a (mul a b), i.e., there exists c with mul a b = add a c. Strategy: use a monotonicity property of multiplication on the right (mul_le_mul_right). From h : mul a b ≠ 0, we get b ≠ 0 via mul_left_ne_zero. Then one_le_of_ne_zero gives le one b. Applying mul_le_mul_right with t := a to this inequality yields le (mul one a) (mul b a). We then rewrite using one_mul to simplify mul one a to a and mul_comm to rewrite mul b a to mul a b, obtaining the desired le a (mul a b).\n\nSteps:\n- Turn the goal into le (mul one a) (mul b a) by rewriting the goal with ← one_mul a and ← mul_comm a b.\n- Apply mul_le_mul_right, reducing to proving le one b.\n- Apply one_le_of_ne_zero, reducing to b ≠ 0.\n- Use mul_left_ne_zero with h to conclude b ≠ 0.\n- The rewrites and applications finish the proof.", "code": "intro a b h\nrw [← one_mul a]\nrw [← mul_comm a b]\napply mul_le_mul_right\napply one_le_of_ne_zero\napply mul_left_ne_zero\nexact h"}
{"draft": "Goal: Prove x = one from mul x y = one. Plan: Use antisymmetry of ≤ to show le x one and le one x, then conclude x = one.\n1) Show le x one:\n   - Rewrite the goal using h: le x one ↔ le x (mul x y) by rw [← h].\n   - Apply le_mul_right x y, which reduces to proving mul x y ≠ zero.\n   - Prove mul x y ≠ zero by contradiction: assume mul x y = zero, then using h rewrite to one = zero, symmetrize to zero = one, rewrite one as succ zero, obtaining zero = succ zero, contradicting zero_ne_succ.\n2) Show le one x:\n   - Apply one_le_of_ne_zero x; it suffices to show x ≠ zero.\n   - Prove x ≠ zero by contradiction: assume x = zero, rewrite h to mul zero y = one, then rewrite with zero_mul y to get zero = one, rewrite one as succ zero, and contradict zero_ne_succ.\nThis yields both le x one and le one x, then by le_antisymm we get x = one.", "code": "apply le_antisymm x one\n  -- First: le x one\n  rw [← h]\n  apply le_mul_right x y\n  intro hz\n  rw [h] at hz\n  symm at hz\n  rw [one_eq_succ_zero] at hz\n  apply (zero_ne_succ zero)\n  exact hz\n  -- Second: le one x\n  apply one_le_of_ne_zero x\n  intro hx0\n  rw [hx0] at h\n  rw [zero_mul y] at h\n  rw [one_eq_succ_zero] at h\n  apply (zero_ne_succ zero)\n  exact h"}
{"draft": "Goal: Prove mul a b ≠ zero given a ≠ zero and b ≠ zero. Strategy: Prove by contradiction. From a ≠ zero, obtain a = succ n for some n via eq_succ_of_ne_zero. Assume mul a b = zero. Rewriting using a = succ n and the lemma succ_mul, we get add (mul n b) b = zero. By add_left_eq_zero, this implies b = zero, which contradicts hb. Hence, the assumption mul a b = zero is false, and thus mul a b ≠ zero.\n\nDetailed steps:\n1. Introduce h: mul a b = zero.\n2. Use eq_succ_of_ne_zero a ha to get ∃ n, a = succ n, and case split to obtain n and hn: a = succ n.\n3. Rewrite h with hn and succ_mul to get add (mul n b) b = zero.\n4. To derive False, apply hb (which expects b = zero), and then deduce b = zero from the add-equality using add_left_eq_zero with a := mul n b and b := b.\n5. This closes the contradiction, completing the proof.", "code": "intro h\ncases eq_succ_of_ne_zero a ha with\n| intro n hn =>\n  rw [hn] at h\n  rw [succ_mul] at h\n  apply hb\n  apply add_left_eq_zero (mul n b) b\n  apply h"}
{"draft": "Goal: Show that if mul a b = 0 then a = 0 or b = 0. Plan: It's cleaner to argue by contrapositive using the provided no–zero-divisors theorem mul_ne_zero. 1) First, revert the hypothesis h so the goal becomes an implication: mul a b = 0 → (a = 0 ∨ b = 0). 2) Apply contrapose! to turn the goal into ¬(a = 0 ∨ b = 0) → mul a b ≠ 0. 3) Introduce the assumption hnot : ¬(a = 0 ∨ b = 0). 4) To prove mul a b ≠ 0, apply mul_ne_zero a b, which reduces the goal to showing a ≠ 0 and b ≠ 0. 5) Derive a ≠ 0 from hnot by: intro ha0; apply hnot; left; exact ha0. Similarly derive b ≠ 0 by: intro hb0; apply hnot; right; exact hb0. This completes the contrapositive, hence the original statement.", "code": "revert h\ncontrapose!\nintro hnot\napply mul_ne_zero a b\n  intro ha0\n  apply hnot\n  left\n  exact ha0\n  intro hb0\n  apply hnot\n  right\n  exact hb0"}
{"draft": "Goal: Prove left-cancellation for multiplication: if a ≠ 0 and a*b = a*c, then b = c. Strategy: Induct on b.\n\n1) Base case b = zero:\n   - From h: mul a zero = mul a c, rewrite mul a zero to zero to get 0 = mul a c, then symmetrize to mul a c = 0.\n   - By mul_eq_zero, a = 0 ∨ c = 0. The first contradicts ha : a ≠ 0, so we must have c = 0. Hence b = 0 = c, as required.\n\n2) Inductive step b = succ d with IH: for all c and h', if mul a d = mul a c then d = c.\n   - Start from h: mul a (succ d) = mul a c. Rewrite the left with mul_succ to get add (mul a d) a = mul a c.\n   - Case-analyze c:\n     a) c = zero: Then the equation becomes add (mul a d) a = 0. From add_left_eq_zero, we get a = 0, contradicting ha; thus this branch closes by contradiction.\n     b) c = succ k: Rewrite right side using mul_succ to obtain add (mul a d) a = add (mul a k) a. Apply add_right_cancel to deduce mul a d = mul a k. Now apply the IH with c := k to get d = k. Then b = succ d and c = succ k, so rewriting with d = k yields succ d = succ k, completing the proof (close with reflexivity).\n\nKey tools used: mul_zero, mul_succ, mul_eq_zero (no zero divisors), add_left_eq_zero, add_right_cancel, contradiction, induction, cases, rw, symm, exact rfl.", "code": "revert h\nrevert c\ninduction b with\n| zero =>\n  intro c\n  intro h\n  rw [mul_zero a] at h\n  symm at h\n  cases (mul_eq_zero a c h) with\n  | inl ha0 =>\n    -- ha : a ≠ zero, ha0 : a = zero\n    contradiction\n  | inr hc0 =>\n    -- goal: zero = c, and hc0 : c = zero\n    symm\n    exact hc0\n| succ d ih =>\n  intro c\n  intro h\n  rw [mul_succ a d] at h\n  cases c with\n  | zero =>\n    rw [mul_zero a] at h\n    -- add (mul a d) a = zero ⇒ a = zero, contradiction with ha\n    have ha0 := add_left_eq_zero (mul a d) a h\n    have := ha ha0\n    contradiction\n  | succ k =>\n    rw [mul_succ a k] at h\n    -- cancel the common right addend a\n    have hx := add_right_cancel (mul a d) (mul a k) a h\n    -- use the inductive hypothesis on d and k\n    have hdkeq := ih k hx\n    -- now b = succ d, c = succ k; rewrite by d = k\n    rw [hdkeq]\n    exact rfl"}
{"draft": "Goal: Given a ≠ zero and mul a b = a, show b = one. The idea is to recognize that a = mul a one by the lemma mul_one. Therefore, from h: mul a b = a, we can consider the equality mul a b = mul a one. Then, using the left cancellation law for multiplication (mul_left_cancel) which requires a ≠ zero, we can cancel the common left factor a from both sides to conclude b = one.\n\nSteps:\n1. Apply mul_left_cancel with left factor a, comparing b and one. This reduces the goal to proving mul a b = mul a one.\n2. Rewrite mul a one to a using mul_one to change the goal to mul a b = a.\n3. Close the goal by the given hypothesis h.", "code": "apply mul_left_cancel a b one ha\nrw [mul_one a]\nexact h"}
