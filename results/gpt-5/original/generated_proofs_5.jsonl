{"id": 1, "name": "zero_add", "statement": "theorem zero_add (n : MyNat) : add zero n = n := by", "proof": "induction n with\n| zero =>\n  rw [add_zero]\n| succ d ih =>\n  rw [add_succ, ih]", "known_theorems": []}
{"id": 2, "name": "succ_add", "statement": "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "proof": "induction b with\n| zero =>\n  rw [add_zero (succ a)]\n  rw [add_zero a]\n| succ d ih =>\n  rw [add_succ (succ a) d]\n  rw [add_succ a d]\n  rw [ih]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by"]}
{"id": 3, "name": "add_comm", "statement": "theorem add_comm (a b : MyNat) : add a b = add b a := by", "proof": "induction b with\n| zero =>\n  rw [add_zero, zero_add]\n  exact rfl\n| succ d ih =>\n  rw [add_succ, succ_add, ih]\n  exact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by"]}
{"id": 4, "name": "add_assoc", "statement": "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "proof": "induction c with\n| zero =>\n  rw [add_zero]\n  rw [add_zero]\n| succ d ih =>\n  rw [add_succ (add a b) d]\n  rw [add_succ b d]\n  rw [add_succ a (add b d)]\n  rw [ih]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by"]}
{"id": 5, "name": "add_right_comm", "statement": "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "proof": "rw [add_assoc a b c]\nrw [add_comm b c]\nrw [← add_assoc a c b]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by"]}
{"id": 6, "name": "add_left_comm", "statement": "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "proof": "rw [← add_assoc a b c]\nrw [add_right_comm a b c]\nrw [add_comm (add a c) b]\nexact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by"]}
{"id": 7, "name": "succ_eq_add_one", "statement": "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "proof": "rw [one_eq_succ_zero]\nrw [add_succ]\nrw [add_zero]\nexact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by"]}
{"id": 8, "name": "implication_one", "statement": "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "proof": "exact h1", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by"]}
{"id": 9, "name": "implication_two", "statement": "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "proof": "rw [zero_add] at h\nrw [zero_add] at h\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by"]}
{"id": 10, "name": "implication_three", "statement": "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "proof": "exact h2 h1", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by"]}
{"id": 11, "name": "implication_four", "statement": "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "proof": "rw [← succ_eq_add_one x] at h\nrw [four_eq_succ_three] at h\nexact succ_inj x three h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by"]}
{"id": 12, "name": "implication_five", "statement": "theorem implication_five (x : MyNat) : x = four → x = four := by", "proof": "intro h\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by"]}
{"id": 13, "name": "implication_six", "statement": "theorem implication_six (x y : MyNat) : add x one = add y one → x = y := by", "proof": "intro h\nrw [← succ_eq_add_one x] at h\nrw [← succ_eq_add_one y] at h\nexact succ_inj x y h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by"]}
{"id": 14, "name": "implication_seven", "statement": "theorem implication_seven (x y : MyNat) (h1 : x = y) (h2 : x ≠ y) : False := by", "proof": "apply h2\nexact h1", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by", "theorem implication_six (x y : MyNat) : add x one = add y one → x = y := by"]}
{"id": 15, "name": "zero_ne_one", "statement": "theorem zero_ne_one : (zero : MyNat) ≠ one := by", "proof": "rw [one_eq_succ_zero]\nexact zero_ne_succ zero", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by", "theorem implication_six (x y : MyNat) : add x one = add y one → x = y := by", "theorem implication_seven (x y : MyNat) (h1 : x = y) (h2 : x ≠ y) : False := by"]}
{"id": 16, "name": "one_ne_zero", "statement": "theorem one_ne_zero : (one : MyNat) ≠ zero := by", "proof": "intro h\napply zero_ne_one\nsymm\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by", "theorem implication_six (x y : MyNat) : add x one = add y one → x = y := by", "theorem implication_seven (x y : MyNat) (h1 : x = y) (h2 : x ≠ y) : False := by", "theorem zero_ne_one : (zero : MyNat) ≠ one := by"]}
{"id": 17, "name": "two_plus_two_ne_five", "statement": "theorem two_plus_two_ne_five : add (succ (succ zero)) (succ (succ zero)) ≠ succ (succ (succ (succ (succ zero)))) := by", "proof": "intro h\nrw [add_succ] at h\nrw [add_succ] at h\nrw [add_zero] at h\n-- now h : succ (succ (succ (succ zero))) = succ (succ (succ (succ (succ zero))))\nhave h1 : succ (succ (succ zero)) = succ (succ (succ (succ zero))) := by\n  exact succ_inj (succ (succ (succ zero))) (succ (succ (succ (succ zero)))) h\nhave h2 : succ (succ zero) = succ (succ (succ zero)) := by\n  exact succ_inj (succ (succ zero)) (succ (succ (succ zero))) h1\nhave h3 : succ zero = succ (succ zero) := by\n  exact succ_inj (succ zero) (succ (succ zero)) h2\nhave h4 : zero = succ zero := by\n  exact succ_inj zero (succ zero) h3\nexact (zero_ne_succ zero) h4", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by", "theorem implication_six (x y : MyNat) : add x one = add y one → x = y := by", "theorem implication_seven (x y : MyNat) (h1 : x = y) (h2 : x ≠ y) : False := by", "theorem zero_ne_one : (zero : MyNat) ≠ one := by", "theorem one_ne_zero : (one : MyNat) ≠ zero := by"]}
{"id": 18, "name": "add_algo_1", "statement": "theorem add_algo_1 (a b c d : MyNat) : add (add a b) (add c d) = add (add (add a c) d) b := by", "proof": "rw [add_right_comm a b (add c d)]\nrw [← add_assoc a c d]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by"]}
{"id": 19, "name": "succ_ne_zero", "statement": "theorem succ_ne_zero (a : MyNat) : succ a ≠ zero := by", "proof": "intro h\napply zero_ne_succ a\nsymm\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_algo_1 (a b c d : MyNat) : add (add a b) (add c d) = add (add (add a c) d) b := by"]}
{"id": 20, "name": "succ_ne_succ", "statement": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := by", "proof": "intro hEq\napply h\nexact succ_inj m n hEq", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_algo_1 (a b c d : MyNat) : add (add a b) (add c d) = add (add (add a c) d) b := by", "theorem succ_ne_zero (a : MyNat) : succ a ≠ zero := by"]}
{"id": 21, "name": "mul_one", "statement": "theorem mul_one (m : MyNat) : mul m one = m := by", "proof": "rw [one_eq_succ_zero]\nrw [mul_succ]\nrw [mul_zero]\nrw [zero_add]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by"]}
{"id": 22, "name": "zero_mul", "statement": "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "proof": "induction m with\n| zero =>\n  rw [mul_zero]\n  exact rfl\n| succ d ih =>\n  rw [mul_succ]\n  rw [ih]\n  rw [add_zero]\n  exact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by"]}
{"id": 23, "name": "succ_mul", "statement": "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "proof": "induction b with\n| zero =>\n  rw [mul_zero, mul_zero, add_zero]\n| succ d ih =>\n  rw [mul_succ (succ a) d]\n  rw [ih]\n  rw [mul_succ a d]\n  rw [add_assoc]\n  rw [add_comm d (succ a)]\n  rw [succ_eq_add_one a]\n  rw [add_assoc a one d]\n  rw [add_comm one d]\n  rw [← succ_eq_add_one d]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by"]}
{"id": 24, "name": "mul_comm", "statement": "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "proof": "induction b with\n| zero =>\n  rw [mul_zero, zero_mul]\n| succ d ih =>\n  rw [mul_succ, succ_mul, ih]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by"]}
{"id": 25, "name": "one_mul", "statement": "theorem one_mul (m : MyNat) : mul one m = m := by", "proof": "rw [mul_comm one m]\nrw [mul_one m]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by"]}
{"id": 26, "name": "two_mul", "statement": "theorem two_mul (m : MyNat) : mul two m = add m m := by", "proof": "rw [two_eq_succ_one]\nrw [succ_mul]\nrw [one_mul]\nexact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by"]}
{"id": 27, "name": "mul_add", "statement": "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "proof": "induction c with\n| zero =>\n  rw [add_zero b]\n  rw [mul_zero a]\n  rw [add_zero (mul a b)]\n| succ d ih =>\n  rw [add_succ b d]\n  rw [mul_succ a (add b d)]\n  rw [mul_succ a d]\n  rw [ih]\n  rw [add_assoc (mul a b) (mul a d) a]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by"]}
{"id": 28, "name": "add_mul", "statement": "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "proof": "rw [mul_comm (add a b) c]\nrw [mul_add c a b]\nrw [mul_comm c a]\nrw [mul_comm c b]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by"]}
{"id": 29, "name": "mul_assoc", "statement": "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "proof": "induction c with\n| zero =>\n  repeat rw [mul_zero]\n  exact rfl\n| succ d ih =>\n  rw [mul_succ (mul a b) d]\n  rw [mul_succ b d]\n  rw [mul_add a (mul b d) b]\n  rw [ih]\n  exact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by"]}
{"id": 30, "name": "zero_pow_zero", "statement": "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "proof": "exact pow_zero zero", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by"]}
{"id": 31, "name": "zero_pow_succ", "statement": "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "proof": "rw [pow_succ (m := zero) (n := m)]\nrw [mul_zero]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by"]}
{"id": 32, "name": "pow_one", "statement": "theorem pow_one (a : MyNat) : pow a one = a  := by", "proof": "rw [one_eq_succ_zero]\nrw [pow_succ]\nrw [pow_zero]\nrw [one_mul]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by"]}
{"id": 33, "name": "one_pow", "statement": "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by", "proof": "induction m with\n| zero =>\n  rw [pow_zero]\n  exact rfl\n| succ d ih =>\n  rw [pow_succ]\n  rw [ih]\n  rw [mul_one]\n  exact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by"]}
{"id": 34, "name": "pow_two", "statement": "theorem pow_two (a : MyNat) : pow a two = mul a a := by", "proof": "rw [two_eq_succ_one]\nrw [pow_succ]\nrw [pow_one]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by", "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by"]}
{"id": 35, "name": "pow_add", "statement": "theorem pow_add (a m n : MyNat) : pow a (add m n) = mul (pow a m) (pow a n) := by", "proof": "induction n with\n| zero =>\n  rw [add_zero, pow_zero, mul_one]\n| succ d ih =>\n  rw [add_succ, pow_succ]\n  rw [ih]\n  rw [mul_assoc]\n  rw [pow_succ]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by", "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by", "theorem pow_two (a : MyNat) : pow a two = mul a a := by"]}
{"id": 36, "name": "mul_pow", "statement": "theorem mul_pow (a b n : MyNat) : pow (mul a b) n = mul (pow a n) (pow b n) := by", "proof": "induction n with\n| zero =>\n  rw [pow_zero (mul a b), pow_zero a, pow_zero b, one_mul]\n| succ d ih =>\n  rw [pow_succ (mul a b) d, pow_succ a d, pow_succ b d]\n  rw [ih]\n  rw [mul_assoc (pow a d) (pow b d) (mul a b)]\n  rw [← mul_assoc (pow b d) a b]\n  rw [mul_comm (pow b d) a]\n  rw [← mul_assoc (pow a d) (mul a (pow b d)) b]\n  rw [← mul_assoc (pow a d) a (pow b d)]\n  rw [mul_assoc (mul (pow a d) a) (pow b d) b]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by", "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by", "theorem pow_two (a : MyNat) : pow a two = mul a a := by", "theorem pow_add (a m n : MyNat) : pow a (add m n) = mul (pow a m) (pow a n) := by"]}
{"id": 37, "name": "pow_pow", "statement": "theorem pow_pow (a m n : MyNat) : pow (pow a m) n = pow a (mul m n) := by", "proof": "induction n with\n| zero =>\n  rw [pow_zero, mul_zero, pow_zero]\n| succ d ih =>\n  rw [pow_succ, ih, mul_succ, pow_add]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by", "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by", "theorem pow_two (a : MyNat) : pow a two = mul a a := by", "theorem pow_add (a m n : MyNat) : pow a (add m n) = mul (pow a m) (pow a n) := by", "theorem mul_pow (a b n : MyNat) : pow (mul a b) n = mul (pow a n) (pow b n) := by"]}
{"id": 38, "name": "add_sq", "statement": "theorem add_sq (a b : MyNat) : pow (add a b) two = add (add (pow a two) (pow b two)) (mul (mul two a) b) := by", "proof": "rw [pow_two (add a b)]\nrw [mul_add (add a b) a b]\nrw [add_mul a b a]\nrw [add_mul a b b]\nrw [mul_comm b a]\nrw [add_right_comm (mul a a) (mul a b) (add (mul a b) (mul b b))]\nrw [← add_assoc (mul a a) (mul a b) (mul b b)]\nrw [add_right_comm (add (mul a a) (mul a b)) (mul b b) (mul a b)]\nrw [add_assoc (mul a a) (mul a b) (mul a b)]\nrw [← two_mul (mul a b)]\nrw [← mul_assoc two a b]\nrw [← pow_two a, ← pow_two b]\nrw [add_right_comm (pow a two) (mul (mul two a) b) (pow b two)]\nexact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by", "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by", "theorem pow_two (a : MyNat) : pow a two = mul a a := by", "theorem pow_add (a m n : MyNat) : pow a (add m n) = mul (pow a m) (pow a n) := by", "theorem mul_pow (a b n : MyNat) : pow (mul a b) n = mul (pow a n) (pow b n) := by", "theorem pow_pow (a m n : MyNat) : pow (pow a m) n = pow a (mul m n) := by"]}
{"id": 39, "name": "add_right_cancel", "statement": "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "proof": "induction n with\n| zero =>\n  intro h\n  repeat rw [add_zero] at h\n  exact h\n| succ d ih =>\n  intro h\n  repeat rw [add_succ] at h\n  apply ih\n  apply succ_inj (add a d) (add b d)\n  exact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by"]}
{"id": 40, "name": "add_left_cancel", "statement": "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "proof": "intro h\napply add_right_cancel a b n\nrw [add_comm n a] at h\nrw [add_comm n b] at h\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by"]}
{"id": 41, "name": "add_left_eq_self", "statement": "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "proof": "intro h\napply add_left_cancel (a:=x) (b:=zero) (n:=y)\nrw [add_comm y x]\nrw [add_comm y zero]\nrw [zero_add y]\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by"]}
{"id": 42, "name": "add_right_eq_self", "statement": "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "proof": "intro h\nrw [add_comm x y] at h\napply add_left_eq_self y x\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by"]}
{"id": 43, "name": "add_right_eq_zero", "statement": "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "proof": "induction b with\n| zero =>\n  intro h\n  rw [add_zero] at h\n  exact h\n| succ d ih =>\n  intro h\n  rw [add_succ] at h\n  have h' : zero = succ (add a d) := by\n    symm\n    exact h\n  have : False := by\n    apply zero_ne_succ (add a d)\n    exact h'\n  contradiction", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by"]}
{"id": 44, "name": "add_left_eq_zero", "statement": "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "proof": "intro h\nrw [add_comm] at h\nexact add_right_eq_zero b a h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by"]}
{"id": 45, "name": "le_refl", "statement": "theorem le_refl (x : MyNat) : le x x := by", "proof": "use zero\nsymm\nrw [add_zero]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by"]}
{"id": 46, "name": "zero_le", "statement": "theorem zero_le (x : MyNat) : le zero x := by", "proof": "use x\nsymm\napply zero_add", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by"]}
{"id": 47, "name": "le_succ_self", "statement": "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "proof": "rw [le_iff_exists_add]\nuse one\nexact succ_eq_add_one x", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by"]}
{"id": 48, "name": "le_trans", "statement": "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "proof": "apply (le_iff_exists_add x z).mpr\ncases hxy with\n| intro c hc =>\n  cases hyz with\n  | intro d hd =>\n    use add c d\n    rw [hd]\n    rw [hc]\n    rw [add_assoc x c d]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by"]}
{"id": 49, "name": "le_zero", "statement": "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "proof": "cases hx with\n| intro c hc =>\n  apply add_right_eq_zero x c\n  symm\n  exact hc", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by"]}
{"id": 50, "name": "le_antisymm", "statement": "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "proof": "cases hxy with\n| intro a hya =>\n  cases hyx with\n  | intro b hxb =>\n    rw [hya] at hxb\n    rw [add_assoc] at hxb\n    rw [← zero_add x] at hxb\n    rw [add_comm x (add a b)] at hxb\n    have hab_zero : zero = add a b := by\n      apply add_right_cancel zero (add a b) x\n      exact hxb\n    have ha_zero : a = zero := by\n      apply add_right_eq_zero a b\n      symm\n      exact hab_zero\n    have hb_zero : b = zero := by\n      apply add_left_eq_zero a b\n      symm\n      exact hab_zero\n    rw [ha_zero] at hya\n    rw [add_zero] at hya\n    symm\n    exact hya", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by"]}
{"id": 51, "name": "or_symm", "statement": "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "proof": "cases h with\n| inl hx =>\n  right\n  exact hx\n| inr hy =>\n  left\n  exact hy", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by"]}
{"id": 52, "name": "le_total", "statement": "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "proof": "revert y\ninduction x with\n| zero =>\n  intro y\n  left\n  exact zero_le y\n| succ a ih =>\n  intro y\n  cases y with\n  | zero =>\n    right\n    exact zero_le (succ a)\n  | succ b =>\n    cases (ih b) with\n    | inl h =>\n      left\n      cases h with\n      | intro c hc =>\n        use c\n        rw [hc]\n        symm\n        rw [succ_add]\n    | inr h =>\n      right\n      cases h with\n      | intro c hc =>\n        use c\n        rw [hc]\n        symm\n        rw [succ_add]\n", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by"]}
{"id": 53, "name": "succ_le_succ", "statement": "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "proof": "cases hx with\n| intro c hc =>\n  rw [succ_add] at hc\n  use c\n  apply succ_inj\n  exact hc", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by"]}
{"id": 54, "name": "le_one", "statement": "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "proof": "cases hx with\n| intro c hc =>\n  cases c with\n  | zero =>\n    rw [add_zero] at hc\n    symm at hc\n    right\n    exact hc\n  | succ d =>\n    rw [add_succ] at hc\n    rw [one_eq_succ_zero] at hc\n    left\n    apply add_right_eq_zero\n    symm\n    exact succ_inj zero (add x d) hc", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by"]}
{"id": 55, "name": "le_two", "statement": "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "proof": "cases hx with\n| intro c hc =>\n  cases c with\n  | zero =>\n    rw [add_zero] at hc\n    right\n    right\n    symm\n    exact hc\n  | succ d =>\n    rw [add_succ] at hc\n    rw [two_eq_succ_one] at hc\n    cases (le_one x (by\n      use d\n      apply succ_inj one (add x d)\n      exact hc\n    )) with\n    | inl hz =>\n      left\n      exact hz\n    | inr hone =>\n      right\n      left\n      exact hone", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by"]}
{"id": 56, "name": "one_add_le_self", "statement": "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "proof": "apply (le_iff_exists_add x (add one x)).mpr\nuse one\nexact add_comm one x", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by"]}
{"id": 57, "name": "reflexive", "statement": "theorem reflexive (x : MyNat) : le x  x := by", "proof": "apply (le_iff_exists_add x x).mpr\nuse zero\nsymm\napply add_zero", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by"]}
{"id": 58, "name": "le_succ", "statement": "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "proof": "intro h\ncases h with\n| intro c hc =>\n  use succ c\n  rw [hc]\n  rw [← add_succ a c]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by"]}
{"id": 59, "name": "mul_le_mul_right", "statement": "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "proof": "cases h with\n| intro c hc =>\n  use mul c t\n  rw [hc, add_mul]\n", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by"]}
{"id": 60, "name": "mul_left_ne_zero", "statement": "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "proof": "intro hb\napply h\nrw [hb]\nexact mul_zero a", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by"]}
{"id": 61, "name": "eq_succ_of_ne_zero", "statement": "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "proof": "cases a with\n| zero =>\n  have h : False := by\n    apply ha\n    exact rfl\n  cases h\n| succ n =>\n  use n\n  exact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by"]}
{"id": 62, "name": "one_le_of_ne_zero", "statement": "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "proof": "cases eq_succ_of_ne_zero a ha with\n| intro n hn =>\n  use n\n  symm\n  rw [hn]\n  rw [succ_eq_add_one]\n  rw [add_comm one n]\n  exact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by"]}
{"id": 63, "name": "le_mul_right", "statement": "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by", "proof": "cases eq_succ_of_ne_zero b (mul_left_ne_zero a b h) with\n| intro n hb =>\n  rw [hb]\n  use (mul a n)\n  rw [mul_succ]\n  rw [add_comm]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by"]}
{"id": 64, "name": "mul_right_eq_one", "statement": "theorem mul_right_eq_one (x y : MyNat) (h : mul x y = one) : x = one := by", "proof": "intro x y h\n-- mul x y is nonzero since it equals one\nhave hne : mul x y ≠ zero := by\n  intro hz\n  rw [h] at hz\n  rw [one_eq_succ_zero] at hz\n  symm at hz\n  apply zero_ne_succ zero\n  exact hz\n-- derive x ≤ one from le_mul_right and h\nhave hxle : le x one := by\n  rw [← h]\n  apply le_mul_right\n  exact hne\n-- analyze the possibilities for x\ncases le_one x hxle with\n| inl hx0 =>\n  -- show x ≠ 0 using commutativity and mul_left_ne_zero\n  have hne' : mul y x ≠ zero := by\n    intro hz\n    rw [mul_comm] at hz\n    apply hne\n    exact hz\n  have x_ne_zero : x ≠ zero := by\n    apply mul_left_ne_zero y x\n    exact hne'\n  contradiction\n| inr hx1 =>\n  exact hx1", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by"]}
{"id": 65, "name": "mul_ne_zero", "statement": "theorem mul_ne_zero (a b : MyNat) (ha : a ≠ zero) (hb : b ≠ zero) : mul a b ≠ zero := by", "proof": "intro h\ncases eq_succ_of_ne_zero b hb with\n| intro n hb_eq =>\n  rw [hb_eq] at h\n  rw [mul_succ] at h\n  apply ha\n  apply add_left_eq_zero (mul a n) a\n  exact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by", "theorem mul_right_eq_one (x y : MyNat) (h : mul x y = one) : x = one := by"]}
{"id": 66, "name": "mul_eq_zero", "statement": "theorem mul_eq_zero (a b : MyNat) (h : mul a b = zero) : a = zero ∨ b = zero := by", "proof": "contrapose! h\nhave ha : a ≠ zero := by\n  intro ha0\n  apply h\n  left\n  exact ha0\nhave hb : b ≠ zero := by\n  intro hb0\n  apply h\n  right\n  exact hb0\nexact mul_ne_zero a b ha hb", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by", "theorem mul_right_eq_one (x y : MyNat) (h : mul x y = one) : x = one := by", "theorem mul_ne_zero (a b : MyNat) (ha : a ≠ zero) (hb : b ≠ zero) : mul a b ≠ zero := by"]}
{"id": 67, "name": "mul_left_cancel", "statement": "theorem mul_left_cancel (a b c : MyNat) (ha : a ≠ zero) (h : mul a b = mul a c) : b = c := by", "proof": "revert c\ninduction b with\n| zero =>\n  intro c\n  intro h\n  rw [mul_zero] at h\n  symm at h\n  have hcOr := mul_eq_zero a c h\n  cases hcOr with\n  | inl ha0 =>\n    contradiction\n  | inr hc0 =>\n    symm\n    exact hc0\n| succ d ih =>\n  intro c\n  intro h\n  rw [mul_succ] at h\n  cases c with\n  | zero =>\n    rw [mul_zero] at h\n    have ha0 : a = zero := add_left_eq_zero (mul a d) a h\n    contradiction\n  | succ c' =>\n    rw [mul_succ] at h\n    have hcancel : mul a d = mul a c' := add_right_cancel (mul a d) (mul a c') a h\n    have hdc : d = c' := ih c' hcancel\n    rw [hdc]\n", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by", "theorem mul_right_eq_one (x y : MyNat) (h : mul x y = one) : x = one := by", "theorem mul_ne_zero (a b : MyNat) (ha : a ≠ zero) (hb : b ≠ zero) : mul a b ≠ zero := by", "theorem mul_eq_zero (a b : MyNat) (h : mul a b = zero) : a = zero ∨ b = zero := by"]}
{"id": 68, "name": "mul_right_eq_self", "statement": "theorem mul_right_eq_self (a b : MyNat) (ha : a ≠ zero) (h : mul a b = a) : b = one := by", "proof": "apply mul_left_cancel (a := a) (b := b) (c := one) (ha := ha)\nrw [mul_one]\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by", "theorem mul_right_eq_one (x y : MyNat) (h : mul x y = one) : x = one := by", "theorem mul_ne_zero (a b : MyNat) (ha : a ≠ zero) (hb : b ≠ zero) : mul a b ≠ zero := by", "theorem mul_eq_zero (a b : MyNat) (h : mul a b = zero) : a = zero ∨ b = zero := by", "theorem mul_left_cancel (a b c : MyNat) (ha : a ≠ zero) (h : mul a b = mul a c) : b = c := by"]}
