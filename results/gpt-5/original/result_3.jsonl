{"draft": "Goal: Prove add zero n = n for all n. Strategy: Induction on n.\n- Base case n = zero: We need add zero zero = zero. This follows directly by the axiom add_zero with a = zero, so rewrite using add_zero.\n- Inductive step: Suppose the statement holds for d, i.e., add zero d = d. We must show add zero (succ d) = succ d. Using the axiom add_succ with a = zero and d, we rewrite the left-hand side to succ (add zero d). Then apply the induction hypothesis to conclude succ (add zero d) = succ d. Thus the statement holds for succ d.\nThis completes the proof by induction.", "code": "induction n with\n| zero =>\n  rw [add_zero]\n| succ d ih =>\n  rw [add_succ, ih]"}
{"draft": "Goal: Prove add (succ a) b = succ (add a b) for all a, b. Plan: Induct on b.\n- Base case b = zero: LHS is add (succ a) zero, which by add_zero reduces to succ a. RHS is succ (add a zero), and add a zero reduces to a by add_zero, giving succ a. Both sides match.\n- Inductive step b = succ d with IH: add (succ a) d = succ (add a d). We rewrite the LHS using add_succ: add (succ a) (succ d) = succ (add (succ a) d). Apply IH to the inner add on the LHS to get succ (succ (add a d)). For the RHS, rewrite add a (succ d) using add_succ to get succ (add a d), thus RHS becomes succ (succ (add a d)). Both sides match.\nThis uses only the given axioms add_zero and add_succ and induction on the second argument.", "code": "induction b with\n| zero =>\n  rw [add_zero (succ a)]\n  rw [add_zero a]\n| succ d ih =>\n  rw [add_succ (succ a) d]\n  rw [ih]\n  rw [add_succ a d]"}
{"draft": "We prove commutativity of addition by induction on the second argument b.\n\nBase case (b = zero): The goal is add a zero = add zero a. Using add_zero, the left side becomes a. We then flip the goal with symm to get add zero a = a, and finish with zero_add.\n\nInductive step (b = succ d): The induction hypothesis is add a d = add d a. Our goal is add a (succ d) = add (succ d) a. Rewrite the left using add_succ to get succ (add a d). Rewrite the right using succ_add to get succ (add d a). Now rewrite using the induction hypothesis to turn succ (add a d) into succ (add d a), making both sides identical and closing the goal by reflexivity.\n\nThis uses only rw, symm, and induction, all allowed tactics.", "code": "induction b with\n| zero =>\n  rw [add_zero]\n  symm\n  rw [zero_add]\n| succ d ih =>\n  rw [add_succ a d]\n  rw [succ_add d a]\n  rw [ih]"}
{"draft": "We prove associativity of addition by induction on the third argument c, exploiting the recursion axioms add_zero and add_succ.\n\nBase case (c = zero): We need to show add (add a b) zero = add a (add b zero). Using add_zero on both occurrences of addition, the goal simplifies to add a b = add a b, which is reflexive.\n\nInductive step (c = succ d): The goal is add (add a b) (succ d) = add a (add b (succ d)). Rewrite the left side using add_succ (with a := add a b, d := d) to succ (add (add a b) d). On the right, first rewrite add b (succ d) using add_succ (with a := b, d := d) to get add a (succ (add b d)), then rewrite again using add_succ (with a := a, d := add b d) to obtain succ (add a (add b d)). Now both sides are succ of something, and by the induction hypothesis we have add (add a b) d = add a (add b d). Rewriting with this equality makes both sides identical, and the goal closes by reflexivity.", "code": "induction c with\n  | zero =>\n    repeat rw [add_zero]\n    exact rfl\n  | succ d ih =>\n    rw [add_succ (add a b) d]\n    rw [add_succ b d]\n    rw [add_succ a (add b d)]\n    rw [ih]\n    exact rfl"}
{"draft": "We want to show add (add a b) c = add (add a c) b. The strategy is to use associativity and commutativity of addition. First, reassociate the left-hand side using add_assoc to get add a (add b c). Then swap the order of b and c inside using add_comm to obtain add a (add c b). Finally, reassociate back using the inverse direction of add_assoc to reach add (add a c) b, which is the desired right-hand side.", "code": "rw [add_assoc a b c]\nrw [add_comm b c]\nrw [← add_assoc a c b]"}
{"draft": "Goal: Prove add a (add b c) = add b (add a c). Plan: Use associativity to reassociate the left side, then commutativity to swap a and b in the inner sum, then associativity again to re-associate to the desired right-hand side. Steps: (1) Rewrite using the symmetric of add_assoc to turn add a (add b c) into add (add a b) c. (2) Rewrite the inner addition by add_comm a b to get add (add b a) c. (3) Apply add_assoc again (with parameters b a c) to obtain add b (add a c). At this point both sides are identical, so close with reflexivity (exact rfl).", "code": "rw [← add_assoc a b c]\nrw [add_comm a b]\nrw [add_assoc b a c]\nexact rfl"}
{"draft": "Goal: show succ n = add n one. Strategy: rewrite the goal to the equivalent equality add n one = succ n using symmetry. Then unfold one as succ zero. Apply the add_succ axiom with d = zero to rewrite add n (succ zero) to succ (add n zero). Finally, use add_zero to simplify add n zero to n, giving succ n = succ n, which closes by reflexivity.", "code": "symm\nrw [one_eq_succ_zero]\nrw [add_succ n zero]\nrw [add_zero n]\nexact rfl"}
{"draft": "We want to prove add x y = four given two hypotheses: h1: add x y = four and h2: add (mul three x) z = two. The conclusion is exactly the same as h1, so this is a tautological implication of the form P ∧ Q → P (or more precisely, from assumptions h1 and h2, conclude h1). The second hypothesis h2 is irrelevant to the goal. Therefore, we can close the goal immediately by exact h1.", "code": "exact h1"}
{"draft": "We are given h: add zero x = add (add zero y) two, and we want to show x = add y two. The key tool is the theorem zero_add, which states add zero n = n for any n. We can rewrite both occurrences of add zero _ in h: the left side add zero x rewrites to x, and the inner add zero y on the right rewrites to y, turning the right side into add y two. Using repeat rw [zero_add] at h performs both rewrites. After these rewrites, h is exactly x = add y two, which is our goal, so we conclude by exact h.", "code": "repeat rw [zero_add] at h\nexact h"}
{"draft": "We are given two hypotheses: h1: x = three and h2: x = three → y = four. The goal is y = four. This is a direct application of modus ponens: from h1 we have the antecedent of the implication in h2, so applying h2 to h1 yields the conclusion y = four. In Lean, we can directly conclude with `exact h2 h1`.", "code": "exact h2 h1"}
{"draft": "We want to derive x = three from the hypothesis h: add x one = four. The key idea is to use the injectivity of succ. First, we aim to transform the goal x = three into an equality between succ x and succ three, so that succ_inj can be applied. Specifically, applying succ_inj x three changes the goal to succ x = succ three. Next, we rewrite the goal to match the given hypothesis h. Using succ_eq_add_one x, we rewrite succ x as add x one, turning the goal into add x one = succ three. Then, using four_eq_succ_three in the reverse direction, we rewrite succ three as four, making the goal add x one = four, which is exactly h. Finally, we close the goal with exact h.", "code": "apply succ_inj x three\nrw [← succ_eq_add_one x]\nrw [← four_eq_succ_three]\nexact h"}
{"draft": "We need to prove the tautology: from the assumption x = four, conclude x = four. The plan is straightforward: introduce the hypothesis h : x = four, and then close the goal by exactly this hypothesis. No rewrites or auxiliary theorems are needed.", "code": "intro h\nexact h"}
{"draft": "We need to show right-cancellation of adding one: from add x one = add y one conclude x = y. We use the given lemma succ_eq_add_one, which states succ n = add n one, to translate the equality involving add into an equality involving succ. Then we can apply succ_inj, which cancels succ on both sides. Concretely: introduce the hypothesis h : add x one = add y one. We apply succ_inj x y, which changes the goal to proving succ x = succ y. We then rewrite both sides of this goal using succ_eq_add_one x and succ_eq_add_one y to get add x one = add y one, which is exactly our hypothesis h. Therefore, we can close the goal with exact h.", "code": "intro h\napply succ_inj x y\nrw [succ_eq_add_one x, succ_eq_add_one y]\nexact h"}
{"draft": "We are given h1: x = y and h2: x ≠ y. In Lean, the statement x ≠ y is definitionally Not (x = y), i.e., a function from (x = y) to False. Therefore, we can directly apply h2 to h1 to obtain a contradiction, i.e., False. This requires no rewriting or induction—just using h2 as a function on the proof h1.", "code": "exact h2 h1"}
{"draft": "Goal: prove zero ≠ one. Since one = succ zero, it suffices to show zero ≠ succ zero, which is exactly zero_ne_succ with a = zero.\nPlan:\n- Assume h : zero = one.\n- Rewrite one as succ zero using one_eq_succ_zero to get h : zero = succ zero.\n- Contradict zero_ne_succ zero with h.\nThis yields the contradiction, proving zero ≠ one.", "code": "intro h\nrw [one_eq_succ_zero] at h\nexact (zero_ne_succ zero) h"}
{"draft": "We want to show one ≠ zero. By the definition of ≠, we assume h: one = zero and derive a contradiction. We already have the theorem zero_ne_one: zero ≠ one. If we can produce zero = one, zero_ne_one will yield False. From h: one = zero, by symmetry of equality we get zero = one. Tactically: introduce h, apply zero_ne_one (which changes the goal to zero = one), then use symm to flip the goal to one = zero, and solve it with h.", "code": "intro h\napply zero_ne_one\nsymm\nexact h"}
{"draft": "Goal: Prove that 2 + 2 ≠ 5 in the given system. We denote two = succ (succ zero). The right-hand side is succ (succ (succ (succ (succ zero)))) which is succ of four.\n\nPlan:\n1) Assume the contrary: h : add (succ (succ zero)) (succ (succ zero)) = succ (succ (succ (succ (succ zero)))).\n2) Simplify the left side using the axiom add_succ twice, then add_zero:\n   - add a (succ d) = succ (add a d)\n   So we get h becomes: succ (succ (add (succ (succ zero)) zero)) = succ (succ (succ (succ (succ zero)))). Then rewrite add (succ (succ zero)) zero = succ (succ zero) via add_zero, leading to:\n   - h: succ (succ (succ (succ zero))) = succ (succ (succ (succ (succ zero)))).\n3) Repeatedly apply succ_inj to h to peel off the outer successors on both sides. After four applications, we obtain zero = succ zero.\n4) This contradicts zero_ne_succ zero, yielding False.\n5) Therefore, the original equality cannot hold, and we conclude add (succ (succ zero)) (succ (succ zero)) ≠ succ (succ (succ (succ (succ zero)))).", "code": "intro h\nrepeat rw [add_succ] at h\nrw [add_zero] at h\n-- Now h : succ (succ (succ (succ zero))) = succ (succ (succ (succ (succ zero))))\nhave h1 := succ_inj (succ (succ (succ zero))) (succ (succ (succ (succ zero)))) h\nhave h2 := succ_inj (succ (succ zero)) (succ (succ (succ zero))) h1\nhave h3 := succ_inj (succ zero) (succ (succ zero)) h2\nhave h4 := succ_inj zero (succ zero) h3\nhave : False := zero_ne_succ zero h4\nexact this"}
{"draft": "We want to rearrange and reassociate additions. First, we use add_right_comm with a := a, b := b, c := add c d to swap the last two addends in add (add a b) (add c d), producing add (add a (add c d)) b. Next, we re-associate the inner add using associativity: add_assoc a c d gives add (add a c) d = add a (add c d), so rewriting in the reverse direction (← add_assoc a c d) turns add a (add c d) into add (add a c) d. This makes both sides identical, and we close with exact rfl.", "code": "rw [add_right_comm a b (add c d)]\nrw [← add_assoc a c d]\nexact rfl"}
{"draft": "We want to show succ a ≠ zero, i.e., that assuming succ a = zero leads to a contradiction. We already have zero_ne_succ a : zero ≠ succ a. After introducing h : succ a = zero, our goal is False. We can use apply zero_ne_succ a to change the goal to zero = succ a. From h, we can obtain zero = succ a by symmetry. Concretely, after applying zero_ne_succ a, we use symm to flip the goal to succ a = zero, and then close it with exact h.", "code": "intro h\napply zero_ne_succ a\nsymm\nexact h"}
{"draft": "Goal: Show that if m ≠ n, then succ m ≠ succ n. Strategy: Prove by contradiction. Assume succ m = succ n. Using the provided theorem succ_inj, from succ m = succ n we deduce m = n. This contradicts the hypothesis h : m ≠ n. In Lean: introduce the assumed equality, then apply h, reducing the goal to proving m = n, which we obtain by applying succ_inj to the assumed equality.", "code": "intro hsucc\napply h\napply succ_inj m n\nexact hsucc"}
{"draft": "Goal: prove mul m one = m. Plan:\n- Replace one by succ zero using the lemma one_eq_succ_zero.\n- Rewrite mul m (succ zero) using mul_succ to get add (mul m zero) m.\n- Simplify mul m zero to zero via mul_zero.\n- Simplify add zero m to m via zero_add.\n- The goal becomes m = m, which holds by reflexivity.", "code": "rw [one_eq_succ_zero]\nrw [mul_succ]\nrw [mul_zero]\nrw [zero_add]\nexact rfl"}
{"draft": "We prove zero_mul by induction on m.\n- Base case m = zero: We need mul zero zero = zero. This follows directly from the axiom mul_zero with a = zero, which states mul zero zero = zero.\n- Inductive step m = succ d, assuming IH: mul zero d = zero. We must show mul zero (succ d) = zero. Using the axiom mul_succ with a = zero and b = d, we rewrite the left-hand side to add (mul zero d) zero. By the induction hypothesis this becomes add zero zero, and then by zero_add we conclude it equals zero. This completes the induction.", "code": "induction m with\n| zero =>\n  rw [mul_zero]\n| succ d ih =>\n  rw [mul_succ]\n  rw [ih]\n  rw [zero_add]"}
{"draft": "We prove succ_mul by induction on the second argument b.\nBase case b = zero: LHS mul (succ a) zero reduces to zero by mul_zero. RHS add (mul a zero) zero simplifies via mul_zero and add_zero to zero, so both sides match.\nInductive step b = succ d with IH: mul (succ a) d = add (mul a d) d. Start by expanding both sides using mul_succ: LHS becomes add (mul (succ a) d) (succ a), RHS becomes add (add (mul a d) a) (succ d). Replace mul (succ a) d using the IH to get add (add (mul a d) d) (succ a) on LHS. Convert successors to additions with one via succ_eq_add_one on both sides, yielding add (add (mul a d) d) (add a one) = add (add (mul a d) a) (add d one). Reassociate both sides using add_assoc to expose add d (add a one) and add a (add d one). Finally, use add_left_comm with parameters (d, a, one) to rewrite add d (add a one) into add a (add d one), making both sides identical.", "code": "induction b with\n| zero =>\n  rw [mul_zero (succ a), mul_zero a, add_zero]\n| succ d ih =>\n  rw [mul_succ (succ a) d, mul_succ a d]\n  rw [ih]\n  rw [succ_eq_add_one a, succ_eq_add_one d]\n  rw [add_assoc (mul a d) d (add a one)]\n  rw [add_assoc (mul a d) a (add d one)]\n  rw [add_left_comm d a one]"}
{"draft": "Plan: Prove commutativity of multiplication by induction on the second argument b.\n- Base case b = zero: mul a zero = zero by mul_zero; mul zero a = zero by zero_mul; thus both sides are zero, so equal.\n- Inductive step b = succ d with IH: mul a d = mul d a. We rewrite the goal mul a (succ d) = mul (succ d) a using mul_succ on the left and succ_mul on the right to get add (mul a d) a = add (mul d a) a. Then apply the IH to replace mul a d with mul d a, yielding an identity.\nWe finish each case with exact rfl.", "code": "induction b with\n| zero =>\n  rw [mul_zero, zero_mul]\n  exact rfl\n| succ d ih =>\n  rw [mul_succ, succ_mul, ih]\n  exact rfl"}
{"draft": "Goal: Prove one_mul (m : MyNat) : mul one m = m. Strategy: Use the commutativity of multiplication to swap the factors, turning mul one m into mul m one. Then apply the theorem mul_one, which states mul m one = m. Steps: 1) rw [mul_comm] to rewrite mul one m as mul m one. 2) rw [mul_one] to conclude m.", "code": "rw [mul_comm]\nrw [mul_one]"}
{"draft": "Goal: Prove mul two m = add m m. Strategy: Recognize that two is succ one. Then use the multiplication-by-successor rule succ_mul: mul (succ a) b = add (mul a b) b. Substituting a = one and b = m gives mul (succ one) m = add (mul one m) m. Then use one_mul to rewrite mul one m to m. The result becomes add m m = add m m, which is reflexive.\n\nSteps:\n- Rewrite two as succ one using two_eq_succ_one.\n- Rewrite mul (succ one) m using succ_mul to get add (mul one m) m.\n- Rewrite mul one m to m using one_mul.\n- Conclude by reflexivity.", "code": "rw [two_eq_succ_one]\nrw [succ_mul]\nrw [one_mul]\nexact rfl"}
{"draft": "We prove right-distributivity of multiplication over addition by induction on c.\n\nBase case (c = zero):\n- LHS: mul a (add b zero) rewrites to mul a b using add_zero.\n- RHS: add (mul a b) (mul a zero) rewrites to add (mul a b) zero using mul_zero, and then to mul a b using add_zero.\nThus both sides are equal.\n\nInductive step: assume IH: mul a (add b d) = add (mul a b) (mul a d). We need to show the statement for succ d.\n- Rewrite add b (succ d) to succ (add b d) using add_succ.\n- Then LHS mul a (succ (add b d)) rewrites via mul_succ to add (mul a (add b d)) a.\n- Apply IH to mul a (add b d) to get add (add (mul a b) (mul a d)) a.\n- Associate using add_assoc to obtain add (mul a b) (add (mul a d) a).\n- On the RHS, rewrite mul a (succ d) using mul_succ to add (mul a d) a, matching the LHS after association.\nThus the equality holds for succ d, completing the induction.", "code": "induction c with\n| zero =>\n  rw [add_zero]\n  rw [mul_zero]\n  rw [add_zero]\n| succ d ih =>\n  rw [add_succ]\n  rw [mul_succ]\n  rw [ih]\n  rw [add_assoc]\n  rw [mul_succ]"}
{"draft": "Goal: Prove left distributivity of multiplication over addition: mul (add a b) c = add (mul a c) (mul b c).\nPlan:\n1. Use commutativity of multiplication to swap the factors on the left: rewrite mul (add a b) c as mul c (add a b).\n2. Apply the given right-distributivity lemma mul_add to expand mul c (add a b) into add (mul c a) (mul c b).\n3. Use commutativity of multiplication again to rewrite mul c a to mul a c and mul c b to mul b c.\n4. The goal then becomes an equality of identical expressions, closed by reflexivity.\nAll steps use only the allowed tactics (rw and exact).", "code": "rw [mul_comm (add a b) c]\nrw [mul_add c a b]\nrw [mul_comm c a]\nrw [mul_comm c b]\nexact rfl"}
{"draft": "We want to show associativity of multiplication: mul (mul a b) c = mul a (mul b c). The multiplication is defined recursively on the second argument via mul_zero and mul_succ. Therefore, a natural approach is induction on c.\n\nBase case (c = zero):\n- LHS: mul (mul a b) zero = zero by mul_zero.\n- RHS: mul a (mul b zero) = mul a zero = zero by two applications of mul_zero.\nThus both sides are zero.\n\nInductive step (c = succ d, with IH: mul (mul a b) d = mul a (mul b d)):\n- Expand the left: mul (mul a b) (succ d) = add (mul (mul a b) d) (mul a b) by mul_succ.\n- Expand the inner multiplication on the right: mul b (succ d) = add (mul b d) b by mul_succ, so\n  RHS: mul a (mul b (succ d)) = mul a (add (mul b d) b) = add (mul a (mul b d)) (mul a b) by mul_add.\n- Apply the induction hypothesis to replace mul (mul a b) d with mul a (mul b d) on the LHS.\n- Both sides are now add (mul a (mul b d)) (mul a b), so the equality holds.\n\nThis uses only rw (including repeat rw), the recursion axioms for mul (mul_zero, mul_succ), and distributivity mul_add. We finish each branch with reflexivity.", "code": "induction c with\n| zero =>\n  repeat rw [mul_zero]\n  exact rfl\n| succ d ih =>\n  rw [mul_succ (mul a b) d]\n  rw [mul_succ b d]\n  rw [mul_add]\n  rw [ih]\n  exact rfl"}
{"draft": "We want to show pow zero zero = one. The alien system includes the axiom pow_zero (m : MyNat) : pow m zero = one, which holds for any base m. Instantiating this axiom with m = zero directly yields pow zero zero = one, which is exactly our goal. Therefore, we can conclude the proof by directly applying or exacting this axiom.", "code": "exact pow_zero zero"}
{"draft": "We need to show that 0^(succ m) = 0. The power recursion axiom gives pow m (succ n) = mul (pow m n) m. Specializing to base m := zero and exponent n := m, we rewrite the goal pow zero (succ m) to mul (pow zero m) zero. Then we use the multiplication-by-zero axiom mul_zero (a) : mul a zero = zero to rewrite the left-hand side to zero, proving the goal.", "code": "rw [pow_succ (zero) m]\nrw [mul_zero (pow zero m)]"}
{"draft": "Goal: show pow a one = a. Use that one = succ zero to rewrite the exponent and then unfold pow at a successor via pow_succ. Specifically:\n1) Rewrite one as succ zero: pow a one = pow a (succ zero).\n2) Apply pow_succ with n = zero: pow a (succ zero) = mul (pow a zero) a.\n3) Use pow_zero to simplify pow a zero to one: mul (pow a zero) a = mul one a.\n4) Use one_mul to simplify mul one a to a.\nAfter these rewrites, the goal becomes a = a, which closes by reflexivity.", "code": "rw [one_eq_succ_zero]\nrw [pow_succ]\nrw [pow_zero]\nrw [one_mul]\nexact rfl"}
{"draft": "We prove by induction on the exponent m.\n- Base case m = zero: pow one zero = one by the axiom pow_zero.\n- Inductive step: suppose IH: pow one d = one. Then\n  pow one (succ d) = mul (pow one d) one by pow_succ. Using the IH, this becomes mul one one, which equals one by mul_one.\nThus, pow one m = one for all m.", "code": "induction m with\n| zero =>\n  rw [pow_zero]\n| succ d ih =>\n  rw [pow_succ, ih, mul_one]"}
{"draft": "Goal: Show pow a two = mul a a. Strategy: Use the definition of two as succ one and the axiom for powers with a successor exponent. Step 1: Rewrite two as succ one using two_eq_succ_one, turning the goal into pow a (succ one) = mul a a. Step 2: Apply pow_succ with n = one to rewrite pow a (succ one) to mul (pow a one) a. Step 3: Use pow_one to replace pow a one with a, yielding mul a a, which matches the right-hand side. No additional properties are needed.", "code": "rw [two_eq_succ_one]\nrw [pow_succ a one]\nrw [pow_one]"}
{"draft": "Goal: show pow a (m + n) = pow a m * pow a n. Strategy: induction on n.\nBase case n = zero:\n- Rewrite add m zero to m by add_zero.\n- Rewrite pow a zero to one by pow_zero.\n- Then RHS becomes mul (pow a m) one, which simplifies to pow a m by mul_one. Both sides are now identical; finish by reflexivity.\nInductive step n = succ d, with IH: pow a (add m d) = mul (pow a m) (pow a d):\n- Rewrite add m (succ d) to succ (add m d) using add_succ.\n- Apply pow_succ to both occurrences of pow a (succ ...), turning the goal into mul (pow a (add m d)) a = mul (pow a m) (mul (pow a d) a).\n- Use the induction hypothesis to replace pow a (add m d) with mul (pow a m) (pow a d) on the left.\n- Now the left side is mul (mul (pow a m) (pow a d)) a; use mul_assoc to reassociate to mul (pow a m) (mul (pow a d) a), matching the right-hand side. Conclude by reflexivity.", "code": "induction n with\n| zero =>\n  rw [add_zero]\n  rw [pow_zero]\n  rw [mul_one]\n  exact rfl\n| succ d ih =>\n  rw [add_succ]\n  rw [pow_succ]\n  rw [ih]\n  rw [mul_assoc]\n  exact rfl"}
{"draft": "We prove by induction on n. Base case n = zero: pow (mul a b) zero rewrites to one by pow_zero. On the right, both pow a zero and pow b zero are one, so the RHS is mul one one, which collapses to one by one_mul. Thus both sides are one. Inductive step: assume IH: pow (mul a b) n = mul (pow a n) (pow b n). For succ n, expand all three exponentials using pow_succ: LHS becomes mul (pow (mul a b) n) (mul a b) and RHS becomes mul (mul (pow a n) a) (mul (pow b n) b). Substitute IH into the LHS to get mul (mul (pow a n) (pow b n)) (mul a b). Then use associativity and commutativity of multiplication to reassociate and swap factors to reach mul (mul (pow a n) a) (mul (pow b n) b). Concretely: associate to mul (pow a n) (mul (pow b n) (mul a b)), then to mul (pow a n) (mul (mul (pow b n) a) b), then reassociate to mul (mul (pow a n) (mul (pow b n) a)) b, commute (pow b n) and a inside, reassociate to mul (mul (pow a n) a) (pow b n), and finally associate to mul (mul (pow a n) a) (mul (pow b n) b). This matches the RHS after pow_succ expansions, completing the proof.", "code": "induction n with\n| zero =>\n  rw [pow_zero (mul a b)]\n  rw [pow_zero a]\n  rw [pow_zero b]\n  rw [one_mul]\n  exact rfl\n| succ n ih =>\n  rw [pow_succ (mul a b) n]\n  rw [pow_succ a n]\n  rw [pow_succ b n]\n  rw [ih]\n  rw [mul_assoc (pow a n) (pow b n) (mul a b)]\n  rw [← mul_assoc (pow b n) a b]\n  rw [← mul_assoc (pow a n) (mul (pow b n) a) b]\n  rw [mul_comm (pow b n) a]\n  rw [← mul_assoc (pow a n) a (pow b n)]\n  rw [mul_assoc (mul (pow a n) a) (pow b n) b]"}
{"draft": "We aim to prove (a^m)^n = a^(m*n). Proceed by induction on n.\n- Base case n = 0: LHS is pow (pow a m) 0 = 1 by pow_zero. RHS is pow a (mul m 0). Using mul_zero, mul m 0 = 0, so RHS is pow a 0 = 1 by pow_zero. Thus both sides are 1.\n- Inductive step: assume IH: pow (pow a m) n = pow a (mul m n). We need to show pow (pow a m) (succ n) = pow a (mul m (succ n)). Rewrite LHS using pow_succ to mul (pow (pow a m) n) (pow a m). Rewrite the exponent on the RHS using mul_succ: mul m (succ n) = add (mul m n) m, then apply pow_add to get pow a (add (mul m n) m) = mul (pow a (mul m n)) (pow a m). Now apply the IH to replace pow (pow a m) n with pow a (mul m n) on the LHS. Both sides match, concluding the proof.", "code": "induction n with\n| zero =>\n  rw [pow_zero]\n  rw [mul_zero]\n  rw [pow_zero]\n| succ d ih =>\n  rw [pow_succ]\n  rw [mul_succ]\n  rw [pow_add]\n  rw [ih]"}
{"draft": "We want to prove the square expansion for MyNat: (a + b)^2 = a^2 + b^2 + 2ab. The plan is purely algebraic using the provided lemmas.\n\n1) Start by expanding the left-hand side using pow_two to get (a + b)*(a + b).\n2) Distribute using add_mul to expand (a + b)*X, then use mul_add twice to expand each factor, yielding four terms: a*a + a*b + b*a + b*b.\n3) Reassociate and commute additions to group as (a*a + b*b) + (a*b + b*a). This uses add_comm, add_assoc, and add_left_comm.\n4) Turn the cross terms a*b + b*a into 2*(a*b). First, use mul_comm to make b*a = a*b, then use two_mul to rewrite add (ab) (ab) as mul two (ab).\n5) Use mul_assoc to rewrite mul two (mul a b) as mul (mul two a) b.\n6) Finally, rewrite a*a and b*b back to pow a two and pow b two using the symmetric direction of pow_two.\n\nThe sequence of rw steps follows this plan, ending with the desired right-hand side.", "code": "rw [pow_two (add a b)]\nrw [add_mul a b (add a b)]\nrw [mul_add a a b]\nrw [mul_add b a b]\nrw [add_comm (mul b a) (mul b b)]\nrw [add_assoc (mul a a) (mul a b) (add (mul b b) (mul b a))]\nrw [add_left_comm (mul a b) (mul b b) (mul b a)]\nrw [← add_assoc (mul a a) (mul b b) (add (mul a b) (mul b a))]\nrw [mul_comm b a]\nrw [← two_mul (mul a b)]\nrw [← mul_assoc two a b]\nrw [← pow_two a, ← pow_two b]"}
{"draft": "We prove right-cancellation for addition by induction on the right addend n.\n\nBase case n = zero: Assume h : add a zero = add b zero. Using the axiom add_zero, we rewrite both sides to a and b respectively, obtaining h : a = b, which is exactly the goal.\n\nInductive step n = succ d: Assume the induction hypothesis ih: add a d = add b d → a = b. Given h : add a (succ d) = add b (succ d), use the axiom add_succ on both sides to rewrite h to succ (add a d) = succ (add b d). Apply succ_inj to this equality to deduce add a d = add b d. Finally, apply ih to conclude a = b.\n\nThe proof uses only the allowed tactics: induction on n, rewriting with add_zero and add_succ, applying succ_inj to strip succ on both sides, and applying the induction hypothesis.", "code": "induction n with\n| zero =>\n  intro h\n  rw [add_zero, add_zero] at h\n  exact h\n| succ d ih =>\n  intro h\n  rw [add_succ, add_succ] at h\n  apply ih\n  apply succ_inj (add a d) (add b d)\n  exact h"}
{"draft": "We want to cancel the common left addend n from the equation add n a = add n b. We can use commutativity of addition to swap arguments on both sides: rewrite add n a to add a n and add n b to add b n. This yields an equation of the form add a n = add b n, to which we can apply the provided theorem add_right_cancel to conclude a = b. The steps are: introduce the hypothesis h : add n a = add n b; rewrite both sides using add_comm; then apply add_right_cancel.", "code": "intro h\nrw [add_comm n a] at h\nrw [add_comm n b] at h\nexact add_right_cancel a b n h"}
{"draft": "Goal: If add x y = y, show x = zero.\nPlan:\n- Introduce the hypothesis h : add x y = y.\n- Rewrite the right-hand side y as add zero y using the lemma zero_add y.\n- After rewriting, we have add x y = add zero y.\n- Apply add_right_cancel to cancel the common right addend y and conclude x = zero.", "code": "intro h\nrw [← zero_add y] at h\nexact add_right_cancel x zero y h"}
{"draft": "Goal: From add x y = x, show y = zero. We have an existing lemma add_left_eq_self: if add a b = b, then a = zero. To use it, we want an equation of the form add y x = x. From the hypothesis h: add x y = x and commutativity add_comm, we can rewrite add y x to add x y, yielding the desired equation. Then apply add_left_eq_self with a := y and b := x to conclude y = zero.\n\nSteps:\n- Introduce h : add x y = x.\n- Apply add_left_eq_self y x to change the goal to add y x = x.\n- Rewrite the goal using add_comm y x so it becomes add x y = x.\n- Discharge the goal with the hypothesis h.", "code": "intro h\napply add_left_eq_self y x\nrw [add_comm y x]\nexact h"}
{"draft": "Goal: Prove add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero. Plan: Use contraposition to avoid dealing with the impossible successor-equals-zero case directly in the implication. Applying contrapose! turns the goal into a ≠ zero → add a b ≠ zero. Then do a case split on b.\n- Case b = zero: add a zero = a by add_zero, so the goal becomes a ≠ zero, which is exactly the assumption.\n- Case b = succ d: We must show add a (succ d) ≠ zero. Assume add a (succ d) = zero; by add_succ this becomes succ (add a d) = zero. Symmetrize to zero = succ (add a d), which contradicts zero_ne_succ. We formalize this by applying zero_ne_succ (add a d) to the symmetrized equality.\nThis uses only the allowed tactics: contrapose!, intro, cases, rw, symm, apply, exact.", "code": "contrapose!\nintro hne\ncases b with\n| zero =>\n  rw [add_zero]\n  exact hne\n| succ d =>\n  intro h\n  rw [add_succ] at h\n  symm at h\n  apply (zero_ne_succ (add a d))\n  exact h"}
{"draft": "Goal: From add a b = zero, deduce b = zero. Plan: Use commutativity of addition to rewrite the hypothesis into add b a = zero. Then apply the available theorem add_right_eq_zero (which states: add x y = zero → x = zero) with x := b and y := a to conclude b = zero. Steps: 1) Introduce the hypothesis h : add a b = zero. 2) Rewrite h using add_comm a b to get h : add b a = zero. 3) Apply add_right_eq_zero b a to the goal b = zero, which reduces it to proving add b a = zero. 4) Close by exact h.", "code": "intro h\nrw [add_comm a b] at h\napply add_right_eq_zero b a\nexact h"}
{"draft": "Goal: prove le x x, where le a b is defined as ∃ c, b = add a c. Strategy: use the equivalence lemma le_iff_exists_add to rewrite the goal into an existential statement. Specifically, apply (le_iff_exists_add x x).mpr, which changes the goal to ∃ c, x = add x c. Then choose the witness c := zero using 'use zero'. Now the remaining goal is x = add x zero. We know add x zero = x from the axiom add_zero. Apply symmetry to turn the goal into add x zero = x, and close the proof with add_zero x.", "code": "apply (le_iff_exists_add x x).mpr\nuse zero\nsymm\nexact add_zero x"}
{"draft": "Goal: show le zero x, which by definition means there exists c such that x = add zero c. We avoid unfolding 'le' directly (since the allowed tactics do not include 'unfold') and instead use the provided equivalence le_iff_exists_add. Applying the right-to-left direction (mpr/.2) of this equivalence reduces the goal to constructing a witness c with x = add zero c. Choose c := x. Then we need to show x = add zero x. This follows from the given theorem zero_add x : add zero x = x by symmetry.", "code": "apply (le_iff_exists_add zero x).2\nuse x\nsymm\nexact zero_add x"}
{"draft": "Goal: prove le x (succ x). By definition, le a b means there exists c such that b = add a c. So we need to produce a c with succ x = add x c. We know the theorem succ_eq_add_one: succ x = add x one. Therefore, take c = one. Using 'use one' provides the witness, and 'exact succ_eq_add_one x' supplies the required equality.", "code": "use one\nexact succ_eq_add_one x"}
{"draft": "We want to show transitivity of le, where le a b is defined as the existence of a c with b = add a c. From hxy : le x y, obtain c1 and h1 : y = add x c1. From hyz : le y z, obtain c2 and h2 : z = add y c2. To show le x z, we need a witness c with z = add x c. Choose c = add c1 c2. Starting from h2, rewrite y using h1 to get z = add (add x c1) c2, then use associativity add_assoc to reassociate as z = add x (add c1 c2). This matches the required form, so we can conclude le x z.", "code": "cases hxy with\n| intro c1 h1 =>\n  cases hyz with\n  | intro c2 h2 =>\n    use add c1 c2\n    rw [h1] at h2\n    rw [add_assoc] at h2\n    exact h2"}
{"draft": "We want to show that if x ≤ zero, then x = zero. By the definition of le, hx : le x zero means there exists a MyNat c such that zero = add x c. From this equation, we can use the provided theorem add_right_eq_zero, which states that if add a b = zero then a = zero. However, our equality is zero = add x c, so we first symmetrize it to obtain add x c = zero. Then applying add_right_eq_zero with a = x and b = c yields x = zero, which is exactly the goal. Concretely: perform cases on the existential hx to get c and hc : zero = add x c. Change the goal to the required format using symm, and finish by applying add_right_eq_zero.", "code": "cases hx with\n| intro c hc =>\n  apply add_right_eq_zero x c\n  symm\n  exact hc"}
{"draft": "We want to prove antisymmetry: if x ≤ y and y ≤ x, then x = y. By the definition of le, from hxy : le x y we obtain c1 with y = add x c1, and from hyx : le y x we obtain c2 with x = add y c2. Substitute the first into the second to get x = add (add x c1) c2, and then use associativity to rewrite this as x = add x (add c1 c2). Flip the equality to add x (add c1 c2) = x and apply the lemma add_right_eq_self to deduce add c1 c2 = zero. From add c1 c2 = zero, apply add_right_eq_zero to get c1 = zero. Substituting back into y = add x c1 gives y = add x zero = x. Finally, symmetrize to conclude x = y.", "code": "cases hxy with\n| intro c1 hc1 =>\n  cases hyx with\n  | intro c2 hc2 =>\n    have h1 : x = add x (add c1 c2) := by\n      have hx : x = add y c2 := by\n        exact hc2\n      rw [hc1] at hx\n      rw [add_assoc x c1 c2] at hx\n      exact hx\n    have hz : add c1 c2 = zero := by\n      symm at h1\n      apply add_right_eq_self (x := x) (y := add c1 c2)\n      exact h1\n    have hc1zero : c1 = zero := by\n      apply add_right_eq_zero (a := c1) (b := c2)\n      exact hz\n    symm\n    rw [hc1]\n    rw [hc1zero]\n    rw [add_zero]"}
{"draft": "We need to show commutativity of a simple disjunction for equalities. Given h : x = four ∨ y = three, we proceed by case analysis on h. If h is the left case (x = four), then the goal y = three ∨ x = four is satisfied by choosing the right disjunct with exact hx. If h is the right case (y = three), then the goal is satisfied by choosing the left disjunct with exact hy. This uses only basic tactics: cases to split the disjunction, and left/right to select the appropriate side, along with exact to supply the proof.", "code": "cases h with\n| inl hx =>\n  right\n  exact hx\n| inr hy =>\n  left\n  exact hy"}
{"draft": "We want to show that for any two MyNat numbers x and y, either x ≤ y or y ≤ x, where le is defined by existence of a c with the appropriate addition equation. We proceed by induction on x.\n\nBase case x = zero: The goal is le zero y ∨ le y zero. We have le zero y by zero_le, so choose the left disjunct.\n\nInductive step x = succ a: We do a case split on y.\n- If y = zero, then le zero (succ a) holds by zero_le, so we pick the right disjunct le y x.\n- If y = succ b, we apply the induction hypothesis at b: le a b ∨ le b a.\n  * If le a b, there exists c with b = add a c. Then succ b = succ (add a c) = add (succ a) c by the succ_add theorem. So le (succ a) (succ b) holds; pick the left disjunct and witness c.\n  * If le b a, there exists c with a = add b c. Then succ a = succ (add b c) = add (succ b) c, so le (succ b) (succ a) holds; pick the right disjunct and witness c.\n\nIn the equalities, we use rewriting with the existential equalities and the succ_add lemma, flipping the goal with symm when convenient to match the rewrite direction.", "code": "induction x with\n| zero =>\n  left\n  apply zero_le\n| succ a ih =>\n  cases y with\n  | zero =>\n    right\n    apply zero_le\n  | succ b =>\n    have h := ih b\n    cases h with\n    | inl h1 =>\n      cases h1 with\n      | intro c hc =>\n        left\n        use c\n        symm\n        rw [hc]\n        rw [succ_add]\n    | inr h2 =>\n      cases h2 with\n      | intro c hc =>\n        right\n        use c\n        symm\n        rw [hc]\n        rw [succ_add]"}
{"draft": "Goal: From hx : le (succ x) (succ y), prove le x y. By definition of le, hx gives an existential: there exists c such that succ y = add (succ x) c. Using the theorem succ_add, we can rewrite add (succ x) c as succ (add x c), turning the equation into succ y = succ (add x c). Then by succ_inj, we conclude y = add x c. This is exactly the witness needed to show le x y (choose the same c). Steps:\n1. Destructure hx to obtain c and hc : succ y = add (succ x) c.\n2. Rewrite hc using succ_add to get succ y = succ (add x c).\n3. Use succ_inj on this to deduce y = add x c.\n4. Provide the witness c to satisfy le x y.", "code": "cases hx with\n| intro c hc =>\n  rw [succ_add] at hc\n  use c\n  apply succ_inj\n  exact hc"}
{"draft": "We want to characterize all x such that x ≤ 1. Using the definition of le, and available theorems about le and successors, we proceed by cases on x.\n- Case x = zero: The goal x = zero ∨ x = one is immediate by choosing the left disjunct with reflexivity.\n- Case x = succ n: From hx : le (succ n) one, rewrite one as succ zero using one_eq_succ_zero to get le (succ n) (succ zero). Then apply succ_le_succ to deduce le n zero. By le_zero, we conclude n = zero. Hence x = succ n = succ zero = one. We finish by choosing the right disjunct and rewriting n to zero, and then using the fact one = succ zero (symmetry gives succ zero = one).", "code": "cases x with\n| zero =>\n  left\n  exact rfl\n| succ n =>\n  rw [one_eq_succ_zero] at hx\n  have h1 : le n zero := by\n    apply succ_le_succ\n    exact hx\n  have hn : n = zero := by\n    apply le_zero\n    exact h1\n  right\n  rw [hn]\n  symm\n  exact one_eq_succ_zero"}
{"draft": "We need to prove: if x ≤ two, then x is 0, 1, or 2. By the definition of le, hx : le x two means there exists c with two = add x c. We perform case analysis on this witness c.\n- If c = zero, then two = add x zero = x by add_zero. Hence x = two, giving the third disjunct.\n- If c = succ d, then two = add x (succ d) = succ (add x d) by add_succ. Also two = succ one, so succ (add x d) = succ one (by symmetry). By succ_inj, add x d = one. This exhibits le x one (take c = d with one = add x d). Applying le_one then yields x = zero or x = one. These are the first two disjuncts.\nThus in all cases we get x = 0 ∨ x = 1 ∨ x = 2.", "code": "intro x hx\ncases hx with\n| intro c hc =>\n  cases c with\n  | zero =>\n    rw [add_zero] at hc\n    symm at hc\n    right\n    right\n    exact hc\n  | succ d =>\n    rw [add_succ] at hc\n    rw [two_eq_succ_one] at hc\n    symm at hc\n    have h1 : add x d = one := by\n      exact succ_inj (add x d) one hc\n    have hx1 : le x one := by\n      use d\n      symm\n      exact h1\n    have hx1d : x = zero ∨ x = one := by\n      exact le_one x hx1\n    cases hx1d with\n    | inl hz =>\n      left\n      exact hz\n    | inr h1eq =>\n      right\n      left\n      exact h1eq"}
{"draft": "Goal: Show le x (add one x), i.e., there exists c such that add one x = add x c. Choose c = one. Then we need to show add one x = add x one, which follows directly from add_comm one x. Thus, by providing the witness c = one and using commutativity of addition, we conclude the proof.", "code": "use one\nexact add_comm one x"}
{"draft": "Goal: Prove le x x. We already have the theorem le_refl stating le x x for any x. So we can directly conclude by exact le_refl x. As an alternative constructive approach (not used in the final code), from the definition le a b := ∃ c, b = add a c, we could witness c = zero and use add_zero, flipping the equality with symm to match x = add x zero.", "code": "exact le_refl x"}
{"draft": "Goal: From le a b, prove le a (succ b). By definition, le a b means there exists c with b = add a c. We need to exhibit some d with succ b = add a d.\nPlan:\n1) Unpack the hypothesis h : le a b to obtain c and hc : b = add a c.\n2) We want succ b = add a d. Using succ_eq_add_one, rewrite succ b as add b one.\n3) Substitute hc to turn add b one into add (add a c) one.\n4) Use associativity (add_assoc) to rewrite add (add a c) one into add a (add c one). Thus d := add c one works.\n5) Conclude by providing this witness and the chain of equalities.\nThis uses only rewriting, existential introduction, and the provided lemmas.", "code": "intro h\ncases h with\n| intro c hc =>\n  use (add c one)\n  rw [succ_eq_add_one b]\n  rw [hc]\n  exact add_assoc a c one"}
{"draft": "Goal: Show le (mul a t) (mul b t) from h : le a b. By definition, le a b means there exists c with b = add a c. So destruct h to obtain c and the equality hc : b = add a c. We must produce a witness d such that mul b t = add (mul a t) d. Choose d = mul c t. Then, using hc, rewrite mul b t as mul (add a c) t. Apply the distributivity theorem add_mul to rewrite mul (add a c) t into add (mul a t) (mul c t). This matches exactly the required right-hand side with our chosen d, and the equality is reflexive. Thus, the existence is proven.", "code": "cases h with\n| intro c hc =>\n  use mul c t\n  rw [hc]\n  rw [add_mul a c t]\n  exact rfl"}
{"draft": "Goal: Show that if mul a b ≠ 0 then b ≠ 0.\nPlan:\n- Prove by direct contradiction: assume b = 0 and derive a contradiction with h.\n- Introduce the assumption hb : b = zero.\n- We need to derive mul a b = zero to contradict h. Using hb, rewrite mul a b to mul a zero, and then use the axiom mul_zero to rewrite it to zero, yielding the equality zero = zero.\n- Close that equality with reflexivity (provided via exact rfl), and then apply h to obtain a contradiction.\nThis uses only add/mul axioms and simple rewriting.", "code": "intro hb\napply h\nrw [hb, mul_zero a]\nexact rfl"}
{"draft": "Goal: Show that any nonzero natural number a is a successor. Plan: Do a case analysis on a.\n- Case a = zero: This contradicts the assumption ha : a ≠ zero. To close the goal from this contradiction, we can derive False using ha rfl and then eliminate False to derive the existential. Concretely, apply False.elim and prove False via exact ha rfl.\n- Case a = succ n: Provide the witness n and the equality a = succ n by reflexivity.\nThis uses only cases, apply, exact, and use.", "code": "cases a with\n| zero =>\n  apply False.elim\n  exact ha rfl\n| succ n =>\n  use n\n  exact rfl"}
{"draft": "Goal: prove le one a given ha : a ≠ zero. By definition, le one a means there exists c such that a = add one c. From the provided theorem eq_succ_of_ne_zero, since a ≠ zero, there exists n with a = succ n. Using succ_eq_add_one, we have succ n = add n one. Then, by add_comm, add n one = add one n. Chaining these equalities, we obtain a = add one n. Therefore, choosing c := n witnesses le one a. The proof proceeds by destructing the existential from eq_succ_of_ne_zero, then supplying the witness with use, and rewriting with the equalities.", "code": "cases eq_succ_of_ne_zero a ha with\n| intro n h =>\n  use n\n  rw [h]\n  rw [succ_eq_add_one n]\n  rw [add_comm n one]"}
{"draft": "Goal: show le a (mul a b), i.e., there exists c such that mul a b = add a c. From the hypothesis h : mul a b ≠ zero, we can deduce b ≠ zero using mul_left_ne_zero. Any nonzero MyNat is a successor, so by eq_succ_of_ne_zero we get a witness n with b = succ n. Substitute this into mul a b to get mul a (succ n). By mul_succ, mul a (succ n) = add (mul a n) a. Using commutativity of addition (add_comm), we rewrite this as add a (mul a n). Thus we have exhibited c := mul a n with mul a b = add a c, proving le a (mul a b).\n\nSteps:\n- From h, get hbne : b ≠ zero via mul_left_ne_zero.\n- Obtain n and hb : b = succ n via eq_succ_of_ne_zero.\n- Use c := mul a n as the witness for the existential.\n- Rewrite using hb, mul_succ, and add_comm to get the required equality.\n- Close the goal with reflexivity.", "code": "intro a b h\ncases eq_succ_of_ne_zero b (mul_left_ne_zero a b h) with\n| intro n hb =>\n  use mul a n\n  rw [hb]\n  rw [mul_succ]\n  rw [add_comm]\n  exact rfl"}
{"draft": "Goal: If mul x y = one then x = one. Plan: (1) Show mul x y ≠ zero: otherwise, rewriting mul x y to zero in the hypothesis mul x y = one yields zero = one, and rewriting one = succ zero contradicts zero ≠ succ zero. (2) From le_mul_right, obtain le x (mul x y); rewrite with mul x y = one to get le x one. (3) Show x ≠ zero: if x = zero, then mul x y = zero by zero_mul, contradicting mul x y = one as before. (4) From one_le_of_ne_zero and x ≠ zero, get le one x. (5) Apply le_antisymm with le x one and le one x to conclude x = one.", "code": "have hne0 : mul x y ≠ zero := by\n  intro hz\n  have h' := h\n  rw [hz] at h'\n  rw [one_eq_succ_zero] at h'\n  have : zero ≠ succ zero := zero_ne_succ zero\n  contradiction\n\nhave hxle1 : le x one := by\n  have hle := le_mul_right x y hne0\n  rw [h] at hle\n  exact hle\n\nhave hx_ne_zero : x ≠ zero := by\n  intro hxz\n  have : mul x y = zero := by\n    rw [hxz, zero_mul]\n  have h' := h\n  rw [this] at h'\n  rw [one_eq_succ_zero] at h'\n  have : zero ≠ succ zero := zero_ne_succ zero\n  contradiction\n\nhave h1le : le one x := by\n  exact one_le_of_ne_zero x hx_ne_zero\n\nexact le_antisymm x one hxle1 h1le"}
{"draft": "Goal: Show mul a b ≠ zero from a ≠ zero and b ≠ zero. Plan: Prove by contradiction. Assume mul a b = zero. Since a ≠ 0 and b ≠ 0, use eq_succ_of_ne_zero to write a = succ m and b = succ n. Rewrite the assumed equality by these, and then expand mul (succ m) (succ n) using succ_mul: mul (succ m) (succ n) = add (mul m (succ n)) (succ n). Thus we get add (mul m (succ n)) (succ n) = zero. Apply add_left_eq_zero to conclude succ n = zero, which contradicts zero_ne_succ n. Therefore the assumption mul a b = zero leads to a contradiction, proving mul a b ≠ zero.", "code": "intro h\ncases eq_succ_of_ne_zero a ha with\n| intro m ham =>\n  cases eq_succ_of_ne_zero b hb with\n  | intro n hbn =>\n    rw [ham] at h\n    rw [hbn] at h\n    rw [succ_mul] at h\n    have hsn : succ n = zero := by\n      apply add_left_eq_zero (mul m (succ n)) (succ n)\n      exact h\n    have hzsn : zero = succ n := by\n      symm\n      exact hsn\n    apply zero_ne_succ n\n    exact hzsn"}
{"draft": "Goal: From h : mul a b = zero, prove a = zero ∨ b = zero. The cleanest path is by contrapositive using the provided theorem mul_ne_zero, which states that if a ≠ 0 and b ≠ 0 then mul a b ≠ 0.\n\nPlan:\n1. Apply contraposition with respect to h using the tactic `contrapose! h`. This transforms the goal from `a = zero ∨ b = zero` into `mul a b ≠ zero`, while turning the hypothesis `h : mul a b = zero` into `h : ¬ (a = zero ∨ b = zero)`.\n2. From h : ¬ (a = zero ∨ b = zero), deduce ha : a ≠ zero and hb : b ≠ zero:\n   - For ha, assume a = zero; then by `left`, we produce a = zero ∨ b = zero, contradicting h.\n   - Similarly for hb, assume b = zero; then by `right`, we contradict h.\n3. Apply mul_ne_zero a b ha hb to conclude mul a b ≠ zero, which matches the goal after contraposition.\n4. Thus, by contrapositive, the original statement holds: if mul a b = zero, then a = zero ∨ b = zero.", "code": "contrapose! h\n-- Now: h : ¬ (a = zero ∨ b = zero), goal: mul a b ≠ zero\nhave ha : a ≠ zero := by\n  intro ha0\n  apply h\n  left\n  exact ha0\nhave hb : b ≠ zero := by\n  intro hb0\n  apply h\n  right\n  exact hb0\nexact mul_ne_zero a b ha hb"}
{"draft": "Goal: Prove left cancellation for multiplication when the left factor a is nonzero. Strategy: Induction on b, keeping c and the equality general via revert.\n\n1) Revert c and h to generalize them over the induction on b.\n\n2) Base case b = zero:\n- From h: mul a zero = mul a c. Rewrite mul a zero = zero to get 0 = mul a c.\n- Case split on c:\n  - If c = zero, then the goal zero = zero is trivial.\n  - If c = succ c', then rewrite mul a (succ c') = add (mul a c') a to get 0 = add (mul a c') a. Symmetrize to add (mul a c') a = 0. By add_left_eq_zero, we get a = 0, contradicting ha. Thus this branch is impossible and closes by contradiction.\n\n3) Inductive step b = succ b':\n- Rewrite mul a (succ b') = add (mul a b') a on the left, so h becomes add (mul a b') a = mul a c.\n- Case split on c:\n  - If c = zero, then the right side is 0, so add (mul a b') a = 0, which by add_left_eq_zero implies a = 0, again contradicting ha.\n  - If c = succ c', rewrite the right side using mul_succ to get add (mul a b') a = add (mul a c') a. By add_right_cancel, deduce mul a b' = mul a c'. Apply the induction hypothesis to obtain b' = c'. Then conclude succ b' = succ c' (i.e., b = c) by rewriting with b' = c'.\n\nThis uses only the provided axioms and theorems: mul_zero, mul_succ, add_left_eq_zero, add_right_cancel, and contradiction with ha.", "code": "intro a b c ha h\nrevert h\nrevert c\ninduction b with\n| zero =>\n  intro c\n  intro h\n  rw [mul_zero] at h\n  cases c with\n  | zero =>\n    exact rfl\n  | succ c' =>\n    rw [mul_succ] at h\n    symm at h\n    have hz : a = zero := by\n      apply add_left_eq_zero (mul a c') a\n      exact h\n    contradiction\n| succ b' ih =>\n  intro c\n  intro h\n  rw [mul_succ] at h\n  cases c with\n  | zero =>\n    rw [mul_zero] at h\n    have hz : a = zero := by\n      apply add_left_eq_zero (mul a b') a\n      exact h\n    contradiction\n  | succ c' =>\n    rw [mul_succ] at h\n    have h' : mul a b' = mul a c' := by\n      apply add_right_cancel (mul a b') (mul a c') a\n      exact h\n    have ihres : b' = c' := by\n      apply ih\n      exact h'\n    rw [ihres]\n    exact rfl"}
{"draft": "Goal: Show b = one from mul a b = a with a ≠ zero. Use the identity mul a one = a to rewrite the right-hand side of h into mul a one. Then both sides are mul a ... and we can cancel the common left factor a using mul_left_cancel (which requires a ≠ zero) to conclude b = one.\n\nSteps:\n- Rewrite h: use rw [← mul_one a] at h to turn h into mul a b = mul a one.\n- Apply mul_left_cancel with parameter a (nonzero) to get b = one.", "code": "rw [← mul_one a] at h\nexact mul_left_cancel a b one ha h"}
