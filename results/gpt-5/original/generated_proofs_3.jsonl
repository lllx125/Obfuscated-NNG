{"id": 1, "name": "zero_add", "statement": "theorem zero_add (n : MyNat) : add zero n = n := by", "proof": "induction n with\n| zero =>\n  rw [add_zero]\n| succ d ih =>\n  rw [add_succ, ih]", "known_theorems": []}
{"id": 2, "name": "succ_add", "statement": "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "proof": "induction b with\n| zero =>\n  rw [add_zero (succ a)]\n  rw [add_zero a]\n| succ d ih =>\n  rw [add_succ (succ a) d]\n  rw [ih]\n  rw [add_succ a d]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by"]}
{"id": 3, "name": "add_comm", "statement": "theorem add_comm (a b : MyNat) : add a b = add b a := by", "proof": "induction b with\n| zero =>\n  rw [add_zero]\n  symm\n  rw [zero_add]\n| succ d ih =>\n  rw [add_succ a d]\n  rw [succ_add d a]\n  rw [ih]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by"]}
{"id": 4, "name": "add_assoc", "statement": "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "proof": "induction c with\n  | zero =>\n    repeat rw [add_zero]\n    exact rfl\n  | succ d ih =>\n    rw [add_succ (add a b) d]\n    rw [add_succ b d]\n    rw [add_succ a (add b d)]\n    rw [ih]\n    exact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by"]}
{"id": 5, "name": "add_right_comm", "statement": "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "proof": "rw [add_assoc a b c]\nrw [add_comm b c]\nrw [← add_assoc a c b]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by"]}
{"id": 6, "name": "add_left_comm", "statement": "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "proof": "rw [← add_assoc a b c]\nrw [add_comm a b]\nrw [add_assoc b a c]\nexact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by"]}
{"id": 7, "name": "succ_eq_add_one", "statement": "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "proof": "symm\nrw [one_eq_succ_zero]\nrw [add_succ n zero]\nrw [add_zero n]\nexact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by"]}
{"id": 8, "name": "implication_one", "statement": "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "proof": "exact h1", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by"]}
{"id": 9, "name": "implication_two", "statement": "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "proof": "repeat rw [zero_add] at h\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by"]}
{"id": 10, "name": "implication_three", "statement": "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "proof": "exact h2 h1", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by"]}
{"id": 11, "name": "implication_four", "statement": "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "proof": "apply succ_inj x three\nrw [← succ_eq_add_one x]\nrw [← four_eq_succ_three]\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by"]}
{"id": 12, "name": "implication_five", "statement": "theorem implication_five (x : MyNat) : x = four → x = four := by", "proof": "intro h\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by"]}
{"id": 13, "name": "implication_six", "statement": "theorem implication_six (x y : MyNat) : add x one = add y one → x = y := by", "proof": "intro h\napply succ_inj x y\nrw [succ_eq_add_one x, succ_eq_add_one y]\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by"]}
{"id": 14, "name": "implication_seven", "statement": "theorem implication_seven (x y : MyNat) (h1 : x = y) (h2 : x ≠ y) : False := by", "proof": "exact h2 h1", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by", "theorem implication_six (x y : MyNat) : add x one = add y one → x = y := by"]}
{"id": 15, "name": "zero_ne_one", "statement": "theorem zero_ne_one : (zero : MyNat) ≠ one := by", "proof": "intro h\nrw [one_eq_succ_zero] at h\nexact (zero_ne_succ zero) h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by", "theorem implication_six (x y : MyNat) : add x one = add y one → x = y := by", "theorem implication_seven (x y : MyNat) (h1 : x = y) (h2 : x ≠ y) : False := by"]}
{"id": 16, "name": "one_ne_zero", "statement": "theorem one_ne_zero : (one : MyNat) ≠ zero := by", "proof": "intro h\napply zero_ne_one\nsymm\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by", "theorem implication_six (x y : MyNat) : add x one = add y one → x = y := by", "theorem implication_seven (x y : MyNat) (h1 : x = y) (h2 : x ≠ y) : False := by", "theorem zero_ne_one : (zero : MyNat) ≠ one := by"]}
{"id": 17, "name": "two_plus_two_ne_five", "statement": "theorem two_plus_two_ne_five : add (succ (succ zero)) (succ (succ zero)) ≠ succ (succ (succ (succ (succ zero)))) := by", "proof": "intro h\nrepeat rw [add_succ] at h\nrw [add_zero] at h\n-- Now h : succ (succ (succ (succ zero))) = succ (succ (succ (succ (succ zero))))\nhave h1 := succ_inj (succ (succ (succ zero))) (succ (succ (succ (succ zero)))) h\nhave h2 := succ_inj (succ (succ zero)) (succ (succ (succ zero))) h1\nhave h3 := succ_inj (succ zero) (succ (succ zero)) h2\nhave h4 := succ_inj zero (succ zero) h3\nhave : False := zero_ne_succ zero h4\nexact this", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by", "theorem implication_six (x y : MyNat) : add x one = add y one → x = y := by", "theorem implication_seven (x y : MyNat) (h1 : x = y) (h2 : x ≠ y) : False := by", "theorem zero_ne_one : (zero : MyNat) ≠ one := by", "theorem one_ne_zero : (one : MyNat) ≠ zero := by"]}
{"id": 18, "name": "add_algo_1", "statement": "theorem add_algo_1 (a b c d : MyNat) : add (add a b) (add c d) = add (add (add a c) d) b := by", "proof": "rw [add_right_comm a b (add c d)]\nrw [← add_assoc a c d]\nexact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by"]}
{"id": 19, "name": "succ_ne_zero", "statement": "theorem succ_ne_zero (a : MyNat) : succ a ≠ zero := by", "proof": "intro h\napply zero_ne_succ a\nsymm\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_algo_1 (a b c d : MyNat) : add (add a b) (add c d) = add (add (add a c) d) b := by"]}
{"id": 20, "name": "succ_ne_succ", "statement": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := by", "proof": "intro hsucc\napply h\napply succ_inj m n\nexact hsucc", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_algo_1 (a b c d : MyNat) : add (add a b) (add c d) = add (add (add a c) d) b := by", "theorem succ_ne_zero (a : MyNat) : succ a ≠ zero := by"]}
{"id": 21, "name": "mul_one", "statement": "theorem mul_one (m : MyNat) : mul m one = m := by", "proof": "rw [one_eq_succ_zero]\nrw [mul_succ]\nrw [mul_zero]\nrw [zero_add]\nexact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by"]}
{"id": 22, "name": "zero_mul", "statement": "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "proof": "induction m with\n| zero =>\n  rw [mul_zero]\n| succ d ih =>\n  rw [mul_succ]\n  rw [ih]\n  rw [zero_add]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by"]}
{"id": 23, "name": "succ_mul", "statement": "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "proof": "induction b with\n| zero =>\n  rw [mul_zero (succ a), mul_zero a, add_zero]\n| succ d ih =>\n  rw [mul_succ (succ a) d, mul_succ a d]\n  rw [ih]\n  rw [succ_eq_add_one a, succ_eq_add_one d]\n  rw [add_assoc (mul a d) d (add a one)]\n  rw [add_assoc (mul a d) a (add d one)]\n  rw [add_left_comm d a one]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by"]}
{"id": 24, "name": "mul_comm", "statement": "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "proof": "induction b with\n| zero =>\n  rw [mul_zero, zero_mul]\n  exact rfl\n| succ d ih =>\n  rw [mul_succ, succ_mul, ih]\n  exact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by"]}
{"id": 25, "name": "one_mul", "statement": "theorem one_mul (m : MyNat) : mul one m = m := by", "proof": "rw [mul_comm]\nrw [mul_one]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by"]}
{"id": 26, "name": "two_mul", "statement": "theorem two_mul (m : MyNat) : mul two m = add m m := by", "proof": "rw [two_eq_succ_one]\nrw [succ_mul]\nrw [one_mul]\nexact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by"]}
{"id": 27, "name": "mul_add", "statement": "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "proof": "induction c with\n| zero =>\n  rw [add_zero]\n  rw [mul_zero]\n  rw [add_zero]\n| succ d ih =>\n  rw [add_succ]\n  rw [mul_succ]\n  rw [ih]\n  rw [add_assoc]\n  rw [mul_succ]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by"]}
{"id": 28, "name": "add_mul", "statement": "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "proof": "rw [mul_comm (add a b) c]\nrw [mul_add c a b]\nrw [mul_comm c a]\nrw [mul_comm c b]\nexact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by"]}
{"id": 29, "name": "mul_assoc", "statement": "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "proof": "induction c with\n| zero =>\n  repeat rw [mul_zero]\n  exact rfl\n| succ d ih =>\n  rw [mul_succ (mul a b) d]\n  rw [mul_succ b d]\n  rw [mul_add]\n  rw [ih]\n  exact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by"]}
{"id": 30, "name": "zero_pow_zero", "statement": "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "proof": "exact pow_zero zero", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by"]}
{"id": 31, "name": "zero_pow_succ", "statement": "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "proof": "rw [pow_succ (zero) m]\nrw [mul_zero (pow zero m)]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by"]}
{"id": 32, "name": "pow_one", "statement": "theorem pow_one (a : MyNat) : pow a one = a  := by", "proof": "rw [one_eq_succ_zero]\nrw [pow_succ]\nrw [pow_zero]\nrw [one_mul]\nexact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by"]}
{"id": 33, "name": "one_pow", "statement": "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by", "proof": "induction m with\n| zero =>\n  rw [pow_zero]\n| succ d ih =>\n  rw [pow_succ, ih, mul_one]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by"]}
{"id": 34, "name": "pow_two", "statement": "theorem pow_two (a : MyNat) : pow a two = mul a a := by", "proof": "rw [two_eq_succ_one]\nrw [pow_succ a one]\nrw [pow_one]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by", "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by"]}
{"id": 35, "name": "pow_add", "statement": "theorem pow_add (a m n : MyNat) : pow a (add m n) = mul (pow a m) (pow a n) := by", "proof": "induction n with\n| zero =>\n  rw [add_zero]\n  rw [pow_zero]\n  rw [mul_one]\n  exact rfl\n| succ d ih =>\n  rw [add_succ]\n  rw [pow_succ]\n  rw [ih]\n  rw [mul_assoc]\n  exact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by", "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by", "theorem pow_two (a : MyNat) : pow a two = mul a a := by"]}
{"id": 36, "name": "mul_pow", "statement": "theorem mul_pow (a b n : MyNat) : pow (mul a b) n = mul (pow a n) (pow b n) := by", "proof": "induction n with\n| zero =>\n  rw [pow_zero (mul a b)]\n  rw [pow_zero a]\n  rw [pow_zero b]\n  rw [one_mul]\n  exact rfl\n| succ n ih =>\n  rw [pow_succ (mul a b) n]\n  rw [pow_succ a n]\n  rw [pow_succ b n]\n  rw [ih]\n  rw [mul_assoc (pow a n) (pow b n) (mul a b)]\n  rw [← mul_assoc (pow b n) a b]\n  rw [← mul_assoc (pow a n) (mul (pow b n) a) b]\n  rw [mul_comm (pow b n) a]\n  rw [← mul_assoc (pow a n) a (pow b n)]\n  rw [mul_assoc (mul (pow a n) a) (pow b n) b]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by", "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by", "theorem pow_two (a : MyNat) : pow a two = mul a a := by", "theorem pow_add (a m n : MyNat) : pow a (add m n) = mul (pow a m) (pow a n) := by"]}
{"id": 37, "name": "pow_pow", "statement": "theorem pow_pow (a m n : MyNat) : pow (pow a m) n = pow a (mul m n) := by", "proof": "induction n with\n| zero =>\n  rw [pow_zero]\n  rw [mul_zero]\n  rw [pow_zero]\n| succ d ih =>\n  rw [pow_succ]\n  rw [mul_succ]\n  rw [pow_add]\n  rw [ih]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by", "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by", "theorem pow_two (a : MyNat) : pow a two = mul a a := by", "theorem pow_add (a m n : MyNat) : pow a (add m n) = mul (pow a m) (pow a n) := by", "theorem mul_pow (a b n : MyNat) : pow (mul a b) n = mul (pow a n) (pow b n) := by"]}
{"id": 38, "name": "add_sq", "statement": "theorem add_sq (a b : MyNat) : pow (add a b) two = add (add (pow a two) (pow b two)) (mul (mul two a) b) := by", "proof": "rw [pow_two (add a b)]\nrw [add_mul a b (add a b)]\nrw [mul_add a a b]\nrw [mul_add b a b]\nrw [add_comm (mul b a) (mul b b)]\nrw [add_assoc (mul a a) (mul a b) (add (mul b b) (mul b a))]\nrw [add_left_comm (mul a b) (mul b b) (mul b a)]\nrw [← add_assoc (mul a a) (mul b b) (add (mul a b) (mul b a))]\nrw [mul_comm b a]\nrw [← two_mul (mul a b)]\nrw [← mul_assoc two a b]\nrw [← pow_two a, ← pow_two b]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by", "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by", "theorem pow_two (a : MyNat) : pow a two = mul a a := by", "theorem pow_add (a m n : MyNat) : pow a (add m n) = mul (pow a m) (pow a n) := by", "theorem mul_pow (a b n : MyNat) : pow (mul a b) n = mul (pow a n) (pow b n) := by", "theorem pow_pow (a m n : MyNat) : pow (pow a m) n = pow a (mul m n) := by"]}
{"id": 39, "name": "add_right_cancel", "statement": "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "proof": "induction n with\n| zero =>\n  intro h\n  rw [add_zero, add_zero] at h\n  exact h\n| succ d ih =>\n  intro h\n  rw [add_succ, add_succ] at h\n  apply ih\n  apply succ_inj (add a d) (add b d)\n  exact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by"]}
{"id": 40, "name": "add_left_cancel", "statement": "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "proof": "intro h\nrw [add_comm n a] at h\nrw [add_comm n b] at h\nexact add_right_cancel a b n h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by"]}
{"id": 41, "name": "add_left_eq_self", "statement": "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "proof": "intro h\nrw [← zero_add y] at h\nexact add_right_cancel x zero y h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by"]}
{"id": 42, "name": "add_right_eq_self", "statement": "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "proof": "intro h\napply add_left_eq_self y x\nrw [add_comm y x]\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by"]}
{"id": 43, "name": "add_right_eq_zero", "statement": "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "proof": "contrapose!\nintro hne\ncases b with\n| zero =>\n  rw [add_zero]\n  exact hne\n| succ d =>\n  intro h\n  rw [add_succ] at h\n  symm at h\n  apply (zero_ne_succ (add a d))\n  exact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by"]}
{"id": 44, "name": "add_left_eq_zero", "statement": "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "proof": "intro h\nrw [add_comm a b] at h\napply add_right_eq_zero b a\nexact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by"]}
{"id": 45, "name": "le_refl", "statement": "theorem le_refl (x : MyNat) : le x x := by", "proof": "apply (le_iff_exists_add x x).mpr\nuse zero\nsymm\nexact add_zero x", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by"]}
{"id": 46, "name": "zero_le", "statement": "theorem zero_le (x : MyNat) : le zero x := by", "proof": "apply (le_iff_exists_add zero x).2\nuse x\nsymm\nexact zero_add x", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by"]}
{"id": 47, "name": "le_succ_self", "statement": "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "proof": "use one\nexact succ_eq_add_one x", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by"]}
{"id": 48, "name": "le_trans", "statement": "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "proof": "cases hxy with\n| intro c1 h1 =>\n  cases hyz with\n  | intro c2 h2 =>\n    use add c1 c2\n    rw [h1] at h2\n    rw [add_assoc] at h2\n    exact h2", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by"]}
{"id": 49, "name": "le_zero", "statement": "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "proof": "cases hx with\n| intro c hc =>\n  apply add_right_eq_zero x c\n  symm\n  exact hc", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by"]}
{"id": 50, "name": "le_antisymm", "statement": "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "proof": "cases hxy with\n| intro c1 hc1 =>\n  cases hyx with\n  | intro c2 hc2 =>\n    have h1 : x = add x (add c1 c2) := by\n      have hx : x = add y c2 := by\n        exact hc2\n      rw [hc1] at hx\n      rw [add_assoc x c1 c2] at hx\n      exact hx\n    have hz : add c1 c2 = zero := by\n      symm at h1\n      apply add_right_eq_self (x := x) (y := add c1 c2)\n      exact h1\n    have hc1zero : c1 = zero := by\n      apply add_right_eq_zero (a := c1) (b := c2)\n      exact hz\n    symm\n    rw [hc1]\n    rw [hc1zero]\n    rw [add_zero]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by"]}
{"id": 51, "name": "or_symm", "statement": "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "proof": "cases h with\n| inl hx =>\n  right\n  exact hx\n| inr hy =>\n  left\n  exact hy", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by"]}
{"id": 52, "name": "le_total", "statement": "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "proof": "induction x with\n| zero =>\n  left\n  apply zero_le\n| succ a ih =>\n  cases y with\n  | zero =>\n    right\n    apply zero_le\n  | succ b =>\n    have h := ih b\n    cases h with\n    | inl h1 =>\n      cases h1 with\n      | intro c hc =>\n        left\n        use c\n        symm\n        rw [hc]\n        rw [succ_add]\n    | inr h2 =>\n      cases h2 with\n      | intro c hc =>\n        right\n        use c\n        symm\n        rw [hc]\n        rw [succ_add]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by"]}
{"id": 53, "name": "succ_le_succ", "statement": "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "proof": "cases hx with\n| intro c hc =>\n  rw [succ_add] at hc\n  use c\n  apply succ_inj\n  exact hc", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by"]}
{"id": 54, "name": "le_one", "statement": "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "proof": "cases x with\n| zero =>\n  left\n  exact rfl\n| succ n =>\n  rw [one_eq_succ_zero] at hx\n  have h1 : le n zero := by\n    apply succ_le_succ\n    exact hx\n  have hn : n = zero := by\n    apply le_zero\n    exact h1\n  right\n  rw [hn]\n  symm\n  exact one_eq_succ_zero", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by"]}
{"id": 55, "name": "le_two", "statement": "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "proof": "intro x hx\ncases hx with\n| intro c hc =>\n  cases c with\n  | zero =>\n    rw [add_zero] at hc\n    symm at hc\n    right\n    right\n    exact hc\n  | succ d =>\n    rw [add_succ] at hc\n    rw [two_eq_succ_one] at hc\n    symm at hc\n    have h1 : add x d = one := by\n      exact succ_inj (add x d) one hc\n    have hx1 : le x one := by\n      use d\n      symm\n      exact h1\n    have hx1d : x = zero ∨ x = one := by\n      exact le_one x hx1\n    cases hx1d with\n    | inl hz =>\n      left\n      exact hz\n    | inr h1eq =>\n      right\n      left\n      exact h1eq", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by"]}
{"id": 56, "name": "one_add_le_self", "statement": "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "proof": "use one\nexact add_comm one x", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by"]}
{"id": 57, "name": "reflexive", "statement": "theorem reflexive (x : MyNat) : le x  x := by", "proof": "exact le_refl x", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by"]}
{"id": 58, "name": "le_succ", "statement": "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "proof": "intro h\ncases h with\n| intro c hc =>\n  use (add c one)\n  rw [succ_eq_add_one b]\n  rw [hc]\n  exact add_assoc a c one", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by"]}
{"id": 59, "name": "mul_le_mul_right", "statement": "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "proof": "cases h with\n| intro c hc =>\n  use mul c t\n  rw [hc]\n  rw [add_mul a c t]\n  exact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by"]}
{"id": 60, "name": "mul_left_ne_zero", "statement": "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "proof": "intro hb\napply h\nrw [hb, mul_zero a]\nexact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by"]}
{"id": 61, "name": "eq_succ_of_ne_zero", "statement": "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "proof": "cases a with\n| zero =>\n  apply False.elim\n  exact ha rfl\n| succ n =>\n  use n\n  exact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by"]}
{"id": 62, "name": "one_le_of_ne_zero", "statement": "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "proof": "cases eq_succ_of_ne_zero a ha with\n| intro n h =>\n  use n\n  rw [h]\n  rw [succ_eq_add_one n]\n  rw [add_comm n one]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by"]}
{"id": 63, "name": "le_mul_right", "statement": "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by", "proof": "intro a b h\ncases eq_succ_of_ne_zero b (mul_left_ne_zero a b h) with\n| intro n hb =>\n  use mul a n\n  rw [hb]\n  rw [mul_succ]\n  rw [add_comm]\n  exact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by"]}
{"id": 64, "name": "mul_right_eq_one", "statement": "theorem mul_right_eq_one (x y : MyNat) (h : mul x y = one) : x = one := by", "proof": "have hne0 : mul x y ≠ zero := by\n  intro hz\n  have h' := h\n  rw [hz] at h'\n  rw [one_eq_succ_zero] at h'\n  have : zero ≠ succ zero := zero_ne_succ zero\n  contradiction\n\nhave hxle1 : le x one := by\n  have hle := le_mul_right x y hne0\n  rw [h] at hle\n  exact hle\n\nhave hx_ne_zero : x ≠ zero := by\n  intro hxz\n  have : mul x y = zero := by\n    rw [hxz, zero_mul]\n  have h' := h\n  rw [this] at h'\n  rw [one_eq_succ_zero] at h'\n  have : zero ≠ succ zero := zero_ne_succ zero\n  contradiction\n\nhave h1le : le one x := by\n  exact one_le_of_ne_zero x hx_ne_zero\n\nexact le_antisymm x one hxle1 h1le", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by"]}
{"id": 65, "name": "mul_ne_zero", "statement": "theorem mul_ne_zero (a b : MyNat) (ha : a ≠ zero) (hb : b ≠ zero) : mul a b ≠ zero := by", "proof": "intro h\ncases eq_succ_of_ne_zero a ha with\n| intro m ham =>\n  cases eq_succ_of_ne_zero b hb with\n  | intro n hbn =>\n    rw [ham] at h\n    rw [hbn] at h\n    rw [succ_mul] at h\n    have hsn : succ n = zero := by\n      apply add_left_eq_zero (mul m (succ n)) (succ n)\n      exact h\n    have hzsn : zero = succ n := by\n      symm\n      exact hsn\n    apply zero_ne_succ n\n    exact hzsn", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by", "theorem mul_right_eq_one (x y : MyNat) (h : mul x y = one) : x = one := by"]}
{"id": 66, "name": "mul_eq_zero", "statement": "theorem mul_eq_zero (a b : MyNat) (h : mul a b = zero) : a = zero ∨ b = zero := by", "proof": "contrapose! h\n-- Now: h : ¬ (a = zero ∨ b = zero), goal: mul a b ≠ zero\nhave ha : a ≠ zero := by\n  intro ha0\n  apply h\n  left\n  exact ha0\nhave hb : b ≠ zero := by\n  intro hb0\n  apply h\n  right\n  exact hb0\nexact mul_ne_zero a b ha hb", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by", "theorem mul_right_eq_one (x y : MyNat) (h : mul x y = one) : x = one := by", "theorem mul_ne_zero (a b : MyNat) (ha : a ≠ zero) (hb : b ≠ zero) : mul a b ≠ zero := by"]}
{"id": 67, "name": "mul_left_cancel", "statement": "theorem mul_left_cancel (a b c : MyNat) (ha : a ≠ zero) (h : mul a b = mul a c) : b = c := by", "proof": "intro a b c ha h\nrevert h\nrevert c\ninduction b with\n| zero =>\n  intro c\n  intro h\n  rw [mul_zero] at h\n  cases c with\n  | zero =>\n    exact rfl\n  | succ c' =>\n    rw [mul_succ] at h\n    symm at h\n    have hz : a = zero := by\n      apply add_left_eq_zero (mul a c') a\n      exact h\n    contradiction\n| succ b' ih =>\n  intro c\n  intro h\n  rw [mul_succ] at h\n  cases c with\n  | zero =>\n    rw [mul_zero] at h\n    have hz : a = zero := by\n      apply add_left_eq_zero (mul a b') a\n      exact h\n    contradiction\n  | succ c' =>\n    rw [mul_succ] at h\n    have h' : mul a b' = mul a c' := by\n      apply add_right_cancel (mul a b') (mul a c') a\n      exact h\n    have ihres : b' = c' := by\n      apply ih\n      exact h'\n    rw [ihres]\n    exact rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by", "theorem mul_right_eq_one (x y : MyNat) (h : mul x y = one) : x = one := by", "theorem mul_ne_zero (a b : MyNat) (ha : a ≠ zero) (hb : b ≠ zero) : mul a b ≠ zero := by", "theorem mul_eq_zero (a b : MyNat) (h : mul a b = zero) : a = zero ∨ b = zero := by"]}
{"id": 68, "name": "mul_right_eq_self", "statement": "theorem mul_right_eq_self (a b : MyNat) (ha : a ≠ zero) (h : mul a b = a) : b = one := by", "proof": "rw [← mul_one a] at h\nexact mul_left_cancel a b one ha h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by", "theorem mul_right_eq_one (x y : MyNat) (h : mul x y = one) : x = one := by", "theorem mul_ne_zero (a b : MyNat) (ha : a ≠ zero) (hb : b ≠ zero) : mul a b ≠ zero := by", "theorem mul_eq_zero (a b : MyNat) (h : mul a b = zero) : a = zero ∨ b = zero := by", "theorem mul_left_cancel (a b c : MyNat) (ha : a ≠ zero) (h : mul a b = mul a c) : b = c := by"]}
