{"draft": "We need to prove that \u03a5dd \u0399M\u03c4r n = n for all n : dBNa\u03a4. We proceed by induction on n.\n\nBase case: n = \u0399M\u03c4r\nWe need to show \u03a5dd \u0399M\u03c4r \u0399M\u03c4r = \u0399M\u03c4r. By axiom a\u211a\u0397S\u03c9r\u03ba\u03a9, we have \u03a5dd \u0399M\u03c4r \u0399M\u03c4r = \u0399M\u03c4r, which completes the base case.\n\nInductive case: n = lBut d for some d : dBNa\u03a4\nAssume the inductive hypothesis: \u03a5dd \u0399M\u03c4r d = d.\nWe need to show \u03a5dd \u0399M\u03c4r (lBut d) = lBut d.\nBy axiom \u03c9\u0399du\u039fs\u0397\u0395, we have \u03a5dd \u0399M\u03c4r (lBut d) = lBut (\u03a5dd \u0399M\u03c4r d).\nBy the inductive hypothesis, \u03a5dd \u0399M\u03c4r d = d.\nTherefore, lBut (\u03a5dd \u0399M\u03c4r d) = lBut d.\nThis completes the inductive case and the proof.", "code": "induction n with\n  | \u0399M\u03c4r =>\n    rw [a\u211a\u0397S\u03c9r\u03ba\u03a9]\n  | lBut d ih =>\n    rw [\u03c9\u0399du\u039fs\u0397\u0395, ih]"}
{"draft": "We need to prove that \u03a5dd (lBut a) b = lBut (\u03a5dd a b) for all a, b : dBNa\u03a4. This is a statement about the addition operation \u03a5dd and the successor function lBut. We'll proceed by induction on b.\n\nBase case (b = \u0399M\u03c4r): We need to show \u03a5dd (lBut a) \u0399M\u03c4r = lBut (\u03a5dd a \u0399M\u03c4r).\n- By axiom a\u211a\u0397S\u03c9r\u03ba\u03a9, \u03a5dd (lBut a) \u0399M\u03c4r = lBut a\n- By axiom a\u211a\u0397S\u03c9r\u03ba\u03a9, \u03a5dd a \u0399M\u03c4r = a\n- So the right side becomes lBut a\n- Both sides are equal to lBut a\n\nInductive case (b = lBut d): Assume the inductive hypothesis that \u03a5dd (lBut a) d = lBut (\u03a5dd a d). We need to show \u03a5dd (lBut a) (lBut d) = lBut (\u03a5dd a (lBut d)).\n- By axiom \u03c9\u0399du\u039fs\u0397\u0395, \u03a5dd (lBut a) (lBut d) = lBut (\u03a5dd (lBut a) d)\n- By the inductive hypothesis, \u03a5dd (lBut a) d = lBut (\u03a5dd a d)\n- So we get lBut (lBut (\u03a5dd a d))\n- By axiom \u03c9\u0399du\u039fs\u0397\u0395, \u03a5dd a (lBut d) = lBut (\u03a5dd a d)\n- So the right side becomes lBut (lBut (\u03a5dd a d))\n- Both sides are equal", "code": "induction b with\n| \u0399M\u03c4r =>\n  rw [a\u211a\u0397S\u03c9r\u03ba\u03a9, a\u211a\u0397S\u03c9r\u03ba\u03a9]\n| lBut d ih =>\n  rw [\u03c9\u0399du\u039fs\u0397\u0395, ih, \u03c9\u0399du\u039fs\u0397\u0395]"}
{"draft": "We need to prove that addition is commutative: \u03a5dd a b = \u03a5dd b a for all a, b : dBNa\u03a4. We'll use induction on b.\n\nBase case (b = \u0399M\u03c4r):\nWe need to show \u03a5dd a \u0399M\u03c4r = \u03a5dd \u0399M\u03c4r a.\n- LHS: \u03a5dd a \u0399M\u03c4r = a by axiom a\u211a\u0397S\u03c9r\u03ba\u03a9\n- RHS: \u03a5dd \u0399M\u03c4r a = a by theorem \u2102Cs_\u211d\u03a5\u03c8d\n- Therefore they are equal.\n\nInductive case (b = lBut d):\nAssume IH: \u03a5dd a d = \u03a5dd d a.\nWe need to show \u03a5dd a (lBut d) = \u03a5dd (lBut d) a.\n- LHS: \u03a5dd a (lBut d) = lBut (\u03a5dd a d) by axiom \u03c9\u0399du\u039fs\u0397\u0395\n- RHS: \u03a5dd (lBut d) a = lBut (\u03a5dd d a) by theorem sokc\u03a9\u0391d\u03b9\n- By IH, \u03a5dd a d = \u03a5dd d a, so we can rewrite the LHS to match the RHS.\n\nThe proof proceeds by induction on b, using the available axioms and theorems about \u03a5dd.", "code": "induction b with\n| \u0399M\u03c4r =>\n  rw [a\u211a\u0397S\u03c9r\u03ba\u03a9, \u2102Cs_\u211d\u03a5\u03c8d]\n| lBut d ih =>\n  rw [\u03c9\u0399du\u039fs\u0397\u0395, sokc\u03a9\u0391d\u03b9, ih]"}
{"draft": "We need to prove the associativity of \u03a5dd: \u03a5dd (\u03a5dd a b) c = \u03a5dd a (\u03a5dd b c). We'll proceed by induction on c.\n\nBase case (c = \u0399M\u03c4r):\n- LHS: \u03a5dd (\u03a5dd a b) \u0399M\u03c4r = \u03a5dd a b (by axiom a\u211a\u0397S\u03c9r\u03ba\u03a9)\n- RHS: \u03a5dd a (\u03a5dd b \u0399M\u03c4r) = \u03a5dd a b (by axiom a\u211a\u0397S\u03c9r\u03ba\u03a9 applied to the inner term)\n- These are equal.\n\nInductive case (c = lBut d):\n- Assume IH: \u03a5dd (\u03a5dd a b) d = \u03a5dd a (\u03a5dd b d)\n- LHS: \u03a5dd (\u03a5dd a b) (lBut d)\n  = lBut (\u03a5dd (\u03a5dd a b) d) (by axiom \u03c9\u0399du\u039fs\u0397\u0395)\n  = lBut (\u03a5dd a (\u03a5dd b d)) (by IH)\n- RHS: \u03a5dd a (\u03a5dd b (lBut d))\n  = \u03a5dd a (lBut (\u03a5dd b d)) (by axiom \u03c9\u0399du\u039fs\u0397\u0395)\n  = lBut (\u03a5dd a (\u03a5dd b d)) (by axiom \u03c9\u0399du\u039fs\u0397\u0395 again)\n- These are equal.\n\nThe proof uses induction on c, applying the axioms a\u211a\u0397S\u03c9r\u03ba\u03a9 and \u03c9\u0399du\u039fs\u0397\u0395 appropriately in each case.", "code": "induction c with\n| \u0399M\u03c4r =>\n  rw [a\u211a\u0397S\u03c9r\u03ba\u03a9, a\u211a\u0397S\u03c9r\u03ba\u03a9]\n| lBut d ih =>\n  rw [\u03c9\u0399du\u039fs\u0397\u0395, ih, \u03c9\u0399du\u039fs\u0397\u0395, \u03c9\u0399du\u039fs\u0397\u0395]"}
{"draft": "We need to prove that \u03a5dd (\u03a5dd a b) c = \u03a5dd (\u03a5dd a c) b. This is essentially showing that addition is commutative when we rearrange the parentheses. We can use the associativity theorem ap\u03c6Q\u039ewLdc and commutativity theorem \u03bc4dA_c2o. First, we apply associativity to the left side: \u03a5dd (\u03a5dd a b) c = \u03a5dd a (\u03a5dd b c). Then we use commutativity on the inner term: \u03a5dd b c = \u03a5dd c b. This gives us \u03a5dd a (\u03a5dd c b). Finally, we apply associativity in reverse to get \u03a5dd (\u03a5dd a c) b.", "code": "rw [ap\u03c6Q\u039ewLdc]\n  rw [\u03bc4dA_c2o b c]\n  rw [\u2190 ap\u03c6Q\u039ewLdc]"}
{"draft": "We need to prove that \u03a5dd a (\u03a5dd b c) = \u03a5dd b (\u03a5dd a c). This is a commutativity property within nested additions. We can use the available theorems about associativity and commutativity of \u03a5dd. Specifically, we have: 1) ap\u03c6Q\u039ewLdc: \u03a5dd (\u03a5dd a b) c = \u03a5dd a (\u03a5dd b c) (associativity), 2) \u03bc4dA_c2o: \u03a5dd a b = \u03a5dd b a (commutativity), and 3) a\u03a8_r\u03bdykn8\u03a8c\u03c1\u03a5T: \u03a5dd (\u03a5dd a b) c = \u03a5dd (\u03a5dd a c) b. The strategy is to use associativity to regroup terms, apply commutativity where needed, and then use associativity again to reach the desired form. Starting with \u03a5dd a (\u03a5dd b c), we can use the symmetry of associativity to write this as \u03a5dd (\u03a5dd a b) c. Then we can use a\u03a8_r\u03bdykn8\u03a8c\u03c1\u03a5T to rearrange this to \u03a5dd (\u03a5dd a c) b. Finally, we apply associativity again to get \u03a5dd a (\u03a5dd c b), and then use commutativity on the inner term to get \u03a5dd a (\u03a5dd b c). Wait, that's circular. Let me reconsider. Actually, we can use: \u03a5dd a (\u03a5dd b c) = \u03a5dd (\u03a5dd a b) c (by symmetry of ap\u03c6Q\u039ewLdc) = \u03a5dd (\u03a5dd a c) b (by a\u03a8_r\u03bdykn8\u03a8c\u03c1\u03a5T) = \u03a5dd a (\u03a5dd c b) (by ap\u03c6Q\u039ewLdc) = \u03a5dd a (\u03a5dd b c). That's still circular. Let me think differently. We want to swap a and b in the nested structure. Using a\u03a8_r\u03bdykn8\u03a8c\u03c1\u03a5T with appropriate arguments: \u03a5dd (\u03a5dd b a) c = \u03a5dd (\u03a5dd b c) a. By commutativity, \u03a5dd b a = \u03a5dd a b, so \u03a5dd (\u03a5dd a b) c = \u03a5dd (\u03a5dd b c) a. By associativity, \u03a5dd a (\u03a5dd b c) = \u03a5dd (\u03a5dd a b) c = \u03a5dd (\u03a5dd b c) a. By associativity again, \u03a5dd (\u03a5dd b c) a = \u03a5dd b (\u03a5dd c a). By commutativity on the inner term, \u03a5dd c a = \u03a5dd a c, so we get \u03a5dd b (\u03a5dd a c).", "code": "rw [\u2190 ap\u03c6Q\u039ewLdc]\n  rw [a\u03a8_r\u03bdykn8\u03a8c\u03c1\u03a5T]\n  rw [ap\u03c6Q\u039ewLdc]\n  rw [\u03bc4dA_c2o c a]"}
{"draft": "We need to prove that lBut n = \u03a5dd n o\u039c\u2115e. By the definition o\u03c8e\u211a_4r\u03b5ut\u039eHze9\u0397, we know that o\u039c\u2115e = lBut \u0399M\u03c4r. So we need to show lBut n = \u03a5dd n (lBut \u0399M\u03c4r). Using the axiom \u03c9\u0399du\u039fs\u0397\u0395, we have \u03a5dd n (lBut \u0399M\u03c4r) = lBut (\u03a5dd n \u0399M\u03c4r). Then by axiom a\u211a\u0397S\u03c9r\u03ba\u03a9, \u03a5dd n \u0399M\u03c4r = n. Therefore, lBut (\u03a5dd n \u0399M\u03c4r) = lBut n, which completes the proof.", "code": "rw [o\u03c8e\u211a_4r\u03b5ut\u039eHze9\u0397, \u03c9\u0399du\u039fs\u0397\u0395, a\u211a\u0397S\u03c9r\u03ba\u03a9]"}
{"draft": "This theorem asks us to prove that \u03a5dd x y = \u03bc\u03b6\u03c1r, given that h1 already states \u03a5dd x y = \u03bc\u03b6\u03c1r. This is a trivial proof - we simply need to use the hypothesis h1 directly. The second hypothesis h2 is not needed for this proof. We can complete this proof by using 'exact h1' to directly provide the required equality.", "code": "exact h1"}
{"draft": "We need to prove that x = \u03a5dd y \u03baw' given the hypothesis h : \u03a5dd \u0399M\u03c4r x = \u03a5dd (\u03a5dd \u0399M\u03c4r y) \u03baw'. Let me work through this step by step.\n\n1. Start with the hypothesis: \u03a5dd \u0399M\u03c4r x = \u03a5dd (\u03a5dd \u0399M\u03c4r y) \u03baw'\n\n2. Apply theorem \u2102Cs_\u211d\u03a5\u03c8d to simplify \u03a5dd \u0399M\u03c4r x to x on the left side.\n\n3. On the right side, we have \u03a5dd (\u03a5dd \u0399M\u03c4r y) \u03baw'. Apply \u2102Cs_\u211d\u03a5\u03c8d to simplify \u03a5dd \u0399M\u03c4r y to y.\n\n4. This gives us x = \u03a5dd y \u03baw', which is exactly what we need to prove.\n\nThe key insight is that \u03a5dd \u0399M\u03c4r acts as a left identity, so we can simplify both sides of the equation in the hypothesis to get our goal directly.", "code": "rw [\u2102Cs_\u211d\u03a5\u03c8d] at h\n  rw [\u2102Cs_\u211d\u03a5\u03c8d] at h\n  exact h"}
{"draft": "This is a straightforward application of modus ponens. We are given two hypotheses: h1 states that x = Shxde, and h2 states that if x = Shxde then y = \u03bc\u03b6\u03c1r. Since we have the antecedent of the implication (h1), we can apply h2 to h1 to directly obtain y = \u03bc\u03b6\u03c1r. This is exactly what the 'exact' tactic does when we provide h2 with the argument h1.", "code": "exact h2 h1"}
{"draft": "We need to prove that if \u03a5dd x o\u039c\u2115e = \u03bc\u03b6\u03c1r, then x = Shxde. Let me work through this step by step.\n\nFirst, let me understand what we have:\n- o\u039c\u2115e = lBut \u0399M\u03c4r (by definition)\n- \u03baw' = lBut o\u039c\u2115e (by definition)\n- Shxde = lBut \u03baw' (by definition)\n- \u03bc\u03b6\u03c1r = lBut Shxde (by definition)\n\nSo \u03bc\u03b6\u03c1r = lBut (lBut (lBut (lBut \u0399M\u03c4r))).\n\nOur hypothesis is: \u03a5dd x o\u039c\u2115e = \u03bc\u03b6\u03c1r\n\nUsing the theorem \u03c6MhX_vsqasVYnae, we know that lBut n = \u03a5dd n o\u039c\u2115e for any n.\nSo if \u03a5dd x o\u039c\u2115e = \u03bc\u03b6\u03c1r, and \u03bc\u03b6\u03c1r = lBut Shxde, then \u03a5dd x o\u039c\u2115e = lBut Shxde.\n\nBy \u03c6MhX_vsqasVYnae applied to Shxde, we get lBut Shxde = \u03a5dd Shxde o\u039c\u2115e.\n\nSo we have:\n\u03a5dd x o\u039c\u2115e = \u03a5dd Shxde o\u039c\u2115e\n\nNow I need to show that this implies x = Shxde.\n\nLet me use the commutativity of \u03a5dd: \u03a5dd x o\u039c\u2115e = \u03a5dd o\u039c\u2115e x (by \u03bc4dA_c2o).\nSimilarly, \u03a5dd Shxde o\u039c\u2115e = \u03a5dd o\u039c\u2115e Shxde.\n\nSo \u03a5dd o\u039c\u2115e x = \u03a5dd o\u039c\u2115e Shxde.\n\nNow, since o\u039c\u2115e = lBut \u0399M\u03c4r, we have:\n\u03a5dd (lBut \u0399M\u03c4r) x = \u03a5dd (lBut \u0399M\u03c4r) Shxde\n\nUsing sokc\u03a9\u0391d\u03b9: \u03a5dd (lBut a) b = lBut (\u03a5dd a b)\nSo: lBut (\u03a5dd \u0399M\u03c4r x) = lBut (\u03a5dd \u0399M\u03c4r Shxde)\n\nUsing \u2102Cs_\u211d\u03a5\u03c8d: \u03a5dd \u0399M\u03c4r n = n\nSo: lBut x = lBut Shxde\n\nBy ycqbigHj (injectivity of lBut), we get x = Shxde.", "code": "rw [f\u03c1LXVqY\u211a\u03c7vc_m\u03c5hr\u211aVe] at h\nrw [\u2190 \u03c6MhX_vsqasVYnae] at h\nrw [\u03bc4dA_c2o] at h\nrw [o\u03c8e\u211a_4r\u03b5ut\u039eHze9\u0397] at h\nrw [sokc\u03a9\u0391d\u03b9] at h\nrw [\u2102Cs_\u211d\u03a5\u03c8d] at h\nrw [\u03bc4dA_c2o] at h\nrw [o\u03c8e\u211a_4r\u03b5ut\u039eHze9\u0397] at h\nrw [sokc\u03a9\u0391d\u03b9] at h\nrw [\u2102Cs_\u211d\u03a5\u03c8d] at h\napply ycqbigHj\nexact h"}
{"draft": "This theorem states that if x = \u03bc\u03b6\u03c1r, then x = \u03bc\u03b6\u03c1r. This is a direct application of the identity function on propositions. The hypothesis directly gives us what we need to prove. We simply introduce the hypothesis and then use it exactly as our goal.", "code": "intro h\nexact h"}
{"draft": "We need to prove that if \u03a5dd x o\u039c\u2115e = \u03a5dd y o\u039c\u2115e, then x = y. This is essentially showing that adding o\u039c\u2115e (which is lBut \u0399M\u03c4r, i.e., the successor of zero) to both sides preserves equality, or equivalently, that we can cancel o\u039c\u2115e from both sides.\n\nProof strategy:\n1. Introduce the hypothesis h : \u03a5dd x o\u039c\u2115e = \u03a5dd y o\u039c\u2115e\n2. Recall that o\u039c\u2115e = lBut \u0399M\u03c4r by definition (o\u03c8e\u211a_4r\u03b5ut\u039eHze9\u0397)\n3. Rewrite both sides using this definition: \u03a5dd x (lBut \u0399M\u03c4r) = \u03a5dd y (lBut \u0399M\u03c4r)\n4. Apply the axiom \u03c9\u0399du\u039fs\u0397\u0395 which states \u03a5dd a (lBut d) = lBut (\u03a5dd a d)\n5. This gives us: lBut (\u03a5dd x \u0399M\u03c4r) = lBut (\u03a5dd y \u0399M\u03c4r)\n6. Apply the axiom a\u211a\u0397S\u03c9r\u03ba\u03a9 which states \u03a5dd a \u0399M\u03c4r = a\n7. This simplifies to: lBut x = lBut y\n8. Apply the injectivity theorem ycqbigHj which states that lBut is injective\n9. This gives us x = y as required", "code": "intro h\n  rw [o\u03c8e\u211a_4r\u03b5ut\u039eHze9\u0397] at h\n  rw [\u03c9\u0399du\u039fs\u0397\u0395, \u03c9\u0399du\u039fs\u0397\u0395] at h\n  rw [a\u211a\u0397S\u03c9r\u03ba\u03a9, a\u211a\u0397S\u03c9r\u03ba\u03a9] at h\n  exact ycqbigHj x y h"}
{"draft": "This theorem asks us to prove False given two contradictory hypotheses: h1 states that x = y, while h2 states that x \u2260 y. This is a direct logical contradiction. In Lean, when we have both a proposition P and its negation \u00acP as hypotheses, we can derive False. Here, h1 gives us x = y (which is P), and h2 gives us x \u2260 y (which is \u00acP, i.e., \u00ac(x = y)). We can apply h2 to h1 to get False, or we can use the contradiction tactic which automatically detects such contradictory hypotheses and closes the goal.", "code": "contradiction"}
{"draft": "We need to prove that \u0399M\u03c4r \u2260 o\u039c\u2115e. By definition, o\u039c\u2115e = lBut \u0399M\u03c4r (from o\u03c8e\u211a_4r\u03b5ut\u039eHze9\u0397). So we need to show \u0399M\u03c4r \u2260 lBut \u0399M\u03c4r. We have the theorem MQ\u03a7Boe\u03c9n\u03c1\u03a5cc which states that for any a : dBNa\u03a4, \u0399M\u03c4r \u2260 lBut a. We can directly apply this theorem with a = \u0399M\u03c4r to get \u0399M\u03c4r \u2260 lBut \u0399M\u03c4r. Then we rewrite o\u039c\u2115e as lBut \u0399M\u03c4r using o\u03c8e\u211a_4r\u03b5ut\u039eHze9\u0397 to complete the proof.", "code": "rw [o\u03c8e\u211a_4r\u03b5ut\u039eHze9\u0397]\nexact MQ\u03a7Boe\u03c9n\u03c1\u03a5cc \u0399M\u03c4r"}
{"draft": "We need to prove that o\u039c\u2115e \u2260 \u0399M\u03c4r. By definition, o\u039c\u2115e = lBut \u0399M\u03c4r (from o\u03c8e\u211a_4r\u03b5ut\u039eHze9\u0397). We have the theorem MQ\u03a7Boe\u03c9n\u03c1\u03a5cc which states that \u0399M\u03c4r \u2260 lBut a for any a. In particular, taking a = \u0399M\u03c4r, we get \u0399M\u03c4r \u2260 lBut \u0399M\u03c4r, which is \u0399M\u03c4r \u2260 o\u039c\u2115e. To prove o\u039c\u2115e \u2260 \u0399M\u03c4r, we introduce the hypothesis h : o\u039c\u2115e = \u0399M\u03c4r, then use symmetry to get \u0399M\u03c4r = o\u039c\u2115e. Rewriting with the definition of o\u039c\u2115e gives us \u0399M\u03c4r = lBut \u0399M\u03c4r. This contradicts MQ\u03a7Boe\u03c9n\u03c1\u03a5cc applied to \u0399M\u03c4r.", "code": "intro h\nsymm at h\nrw [o\u03c8e\u211a_4r\u03b5ut\u039eHze9\u0397] at h\nexact MQ\u03a7Boe\u03c9n\u03c1\u03a5cc \u0399M\u03c4r h"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
{"draft": "API Error", "code": "sorry"}
