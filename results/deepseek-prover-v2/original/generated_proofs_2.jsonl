{"id": 1, "name": "zero_add", "statement": "theorem zero_add (n : MyNat) : add zero n = n := by", "proof": "theorem zero_add (n : MyNat) : add zero n = n := by\n  induction n with\n  | zero =>\n    rw [add_zero]\n  | succ d ih =>\n    rw [add_succ, ih]", "known_theorems": []}
{"id": 2, "name": "succ_add", "statement": "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "proof": "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b) := by\n  induction b with\n  | zero =>\n    rw [add_zero, add_zero]\n  | succ d ih =>\n    rw [add_succ, ih, add_succ]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by"]}
{"id": 3, "name": "add_comm", "statement": "theorem add_comm (a b : MyNat) : add a b = add b a := by", "proof": "theorem add_comm (a b : MyNat) : add a b = add b a := by\n  induction a with\n  | zero => rw [zero_add, add_zero]\n  | succ a' ih =>\n    induction b with\n    | zero => rw [add_zero, zero_add]\n    | succ b' ih2 =>\n      rw [add_succ, succ_add, ih, ih2]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by"]}
{"id": 4, "name": "add_assoc", "statement": "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "proof": "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by\n  induction c with\n  | zero =>\n    -- Base case\n    rw [add_zero, add_zero]\n  | succ d ih =>\n    -- Inductive step\n    rw [add_succ, add_succ, add_succ, ih]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by"]}
{"id": 5, "name": "add_right_comm", "statement": "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "proof": "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by\n  rw [add_assoc]\n  rw [add_comm b c]\n  rw [← add_assoc]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by"]}
{"id": 6, "name": "add_left_comm", "statement": "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "proof": "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by\n  rw [add_comm b c]\n  rw [add_assoc a c b]\n  rw [add_comm (add a c) b]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by"]}
{"id": 7, "name": "succ_eq_add_one", "statement": "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "proof": "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by\n  induction n with\n  | zero =>\n    rw [one_eq_succ_zero]\n    rw [add_succ]\n    rw [add_zero]\n  | succ d ih =>\n    rw [add_succ]\n    rw [add_zero]\n    rw [ih]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by"]}
{"id": 8, "name": "implication_one", "statement": "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "proof": "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by\n  exact h1", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by"]}
{"id": 9, "name": "implication_two", "statement": "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "proof": "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by\n  rw [zero_add] at h\n  rw [zero_add] at h\n  exact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by"]}
{"id": 10, "name": "implication_three", "statement": "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "proof": "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by\n  exact h2 h1", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by"]}
{"id": 11, "name": "implication_four", "statement": "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "proof": "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by\n  rw [one_eq_succ_zero] at h\n  rw [add_succ] at h\n  rw [add_zero] at h\n  rw [four_eq_succ_three] at h\n  apply succ_inj\n  exact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by"]}
{"id": 12, "name": "implication_five", "statement": "theorem implication_five (x : MyNat) : x = four → x = four := by", "proof": "theorem implication_five (x : MyNat) : x = four → x = four := by\n  intro h\n  exact h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by"]}
{"id": 13, "name": "implication_six", "statement": "theorem implication_six (x y : MyNat) : add x one = add y one → x = y := by", "proof": "theorem implication_six (x y : MyNat) : add x one = add y one → x = y := by\n  intro h\n  rw [one_eq_succ_zero] at h\n  rw [add_succ, add_succ] at h\n  rw [add_zero, add_zero] at h\n  apply succ_inj x y h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by"]}
{"id": 14, "name": "implication_seven", "statement": "theorem implication_seven (x y : MyNat) (h1 : x = y) (h2 : x ≠ y) : False := by", "proof": "theorem implication_seven (x y : MyNat) (h1 : x = y) (h2 : x ≠ y) : False := by\n  exact h2 h1", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by", "theorem implication_six (x y : MyNat) : add x one = add y one → x = y := by"]}
{"id": 15, "name": "zero_ne_one", "statement": "theorem zero_ne_one : (zero : MyNat) ≠ one := by", "proof": "theorem zero_ne_one : (zero : MyNat) ≠ one := by\n  rw [one_eq_succ_zero]\n  apply zero_ne_succ", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by", "theorem implication_six (x y : MyNat) : add x one = add y one → x = y := by", "theorem implication_seven (x y : MyNat) (h1 : x = y) (h2 : x ≠ y) : False := by"]}
{"id": 16, "name": "one_ne_zero", "statement": "theorem one_ne_zero : (one : MyNat) ≠ zero := by", "proof": "theorem one_ne_zero : (one : MyNat) ≠ zero := by\n  rw [one_eq_succ_zero]\n  exact zero_ne_succ zero", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by", "theorem implication_six (x y : MyNat) : add x one = add y one → x = y := by", "theorem implication_seven (x y : MyNat) (h1 : x = y) (h2 : x ≠ y) : False := by", "theorem zero_ne_one : (zero : MyNat) ≠ one := by"]}
{"id": 17, "name": "two_plus_two_ne_five", "statement": "theorem two_plus_two_ne_five : add (succ (succ zero)) (succ (succ zero)) ≠ succ (succ (succ (succ (succ zero)))) := by", "proof": "theorem two_plus_two_ne_five : add (succ (succ zero)) (succ (succ zero)) ≠ succ (succ (succ (succ (succ zero)))) := by\n  -- Simplify add two two to four\n  rw [add_succ, add_succ, add_zero]\n  -- Now we have succ (succ (succ (succ zero))) ≠ succ (succ (succ (succ (succ zero))))\n  -- Which is four ≠ five\n  -- Use injectivity of succ to reduce to three ≠ four\n  apply succ_inj\n  apply succ_inj\n  apply succ_inj\n  apply succ_inj\n  -- Now we have zero ≠ one\n  exact zero_ne_one", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem implication_one (x y z : MyNat) (h1 : add x y = four) (h2 : add (mul three x) z = two) : add x y = four := by", "theorem implication_two (x y : MyNat) (h : add zero x = add (add zero y) two) : x = add y two := by", "theorem implication_three (x y : MyNat) (h1 : x = three) (h2 : x = three → y = four) : y = four := by", "theorem implication_four (x : MyNat) (h : add x one = four) : x = three := by", "theorem implication_five (x : MyNat) : x = four → x = four := by", "theorem implication_six (x y : MyNat) : add x one = add y one → x = y := by", "theorem implication_seven (x y : MyNat) (h1 : x = y) (h2 : x ≠ y) : False := by", "theorem zero_ne_one : (zero : MyNat) ≠ one := by", "theorem one_ne_zero : (one : MyNat) ≠ zero := by"]}
{"id": 18, "name": "add_algo_1", "statement": "theorem add_algo_1 (a b c d : MyNat) : add (add a b) (add c d) = add (add (add a c) d) b := by", "proof": "theorem add_algo_1 (a b c d : MyNat) : add (add a b) (add c d) = add (add (add a c) d) b := by\n  rw [add_assoc]          -- LHS becomes add a (add b (add c d))\n  rw [add_left_comm b c d] -- swaps b and c inside the nested add\n  rw [← add_assoc]        -- reassociates to match RHS structure\n  rw [add_comm d b]       -- swaps d and b\n  rw [add_assoc]          -- final reassociation to match RHS", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by"]}
{"id": 19, "name": "succ_ne_zero", "statement": "theorem succ_ne_zero (a : MyNat) : succ a ≠ zero := by", "proof": "theorem succ_ne_zero (a : MyNat) : succ a ≠ zero := by\n  intro h\n  exact zero_ne_succ a h.symm", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_algo_1 (a b c d : MyNat) : add (add a b) (add c d) = add (add (add a c) d) b := by"]}
{"id": 20, "name": "succ_ne_succ", "statement": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := by", "proof": "theorem succ_ne_succ (m n : MyNat) (h : m ≠ n) : succ m ≠ succ n := by\n  intro h_eq\n  apply succ_inj at h_eq\n  contradiction", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_algo_1 (a b c d : MyNat) : add (add a b) (add c d) = add (add (add a c) d) b := by", "theorem succ_ne_zero (a : MyNat) : succ a ≠ zero := by"]}
{"id": 21, "name": "mul_one", "statement": "theorem mul_one (m : MyNat) : mul m one = m := by", "proof": "theorem mul_one (m : MyNat) : mul m one = m := by\n  rw [one_eq_succ_zero]  -- Rewrite one as succ zero\n  rw [mul_succ]          -- Apply mul_succ to get add (mul m zero) m\n  rw [mul_zero]          -- Simplify mul m zero to zero\n  rw [zero_add]          -- Apply zero_add to get m", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by"]}
{"id": 22, "name": "zero_mul", "statement": "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "proof": "theorem zero_mul (m : MyNat) : mul zero m = zero := by\n  induction m with\n  | zero =>\n    rw [mul_zero]\n  | succ n ih =>\n    rw [mul_succ, ih, zero_add]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by"]}
{"id": 23, "name": "succ_mul", "statement": "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "proof": "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by\n  induction b with\n  | zero =>\n    rw [mul_zero, mul_zero, add_zero]\n  | succ d ih =>\n    rw [mul_succ, mul_succ, ih]\n    rw [add_assoc, add_comm d (succ a), ← add_assoc]\n    rw [add_comm a d, add_assoc]\n    rw [add_comm a (succ d)]\n    rw [← succ_eq_add_one d, ← succ_eq_add_one a]\n    rw [add_assoc, add_comm one a, ← add_assoc]\n    rw [add_comm d a, add_assoc]\n    rw [succ_eq_add_one]\n    rw [add_comm a d]\n    rw [add_assoc]\n    rw [succ_eq_add_one]\n    rw [add_comm d one]\n    rw [add_assoc]\n    rw [add_comm a (succ d)]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by"]}
{"id": 24, "name": "mul_comm", "statement": "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "proof": "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by\n  induction b with\n  | zero =>\n    rw [mul_zero]\n    rw [zero_mul]\n  | succ d ih =>\n    rw [mul_succ]\n    rw [succ_mul]\n    rw [ih]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by"]}
{"id": 25, "name": "one_mul", "statement": "theorem one_mul (m : MyNat) : mul one m = m := by", "proof": "theorem one_mul (m : MyNat) : mul one m = m := by\n  induction m with\n  | zero =>\n    rw [mul_zero]\n  | succ d ih =>\n    rw [mul_succ, ih, succ_eq_add_one]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by"]}
{"id": 26, "name": "two_mul", "statement": "theorem two_mul (m : MyNat) : mul two m = add m m := by", "proof": "theorem two_mul (m : MyNat) : mul two m = add m m := by\n  induction m with\n  | zero =>\n    rw [mul_zero, add_zero]\n  | succ d ih =>\n    rw [mul_succ, ih, succ_add, add_assoc, add_comm d one, ← add_assoc, add_comm d (succ d)]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by"]}
{"id": 27, "name": "mul_add", "statement": "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "proof": "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by\n  induction c with\n  | zero =>\n    rw [add_zero]\n    rw [mul_zero]\n    rw [add_zero]\n  | succ d ih =>\n    rw [add_succ]\n    rw [mul_succ]\n    rw [ih]\n    rw [mul_succ]\n    rw [add_assoc]\n    rw [add_comm (mul a d) a]\n    rw [← add_assoc]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by"]}
{"id": 28, "name": "add_mul", "statement": "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "proof": "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by\n  induction c with\n  | zero =>\n    rw [mul_zero, mul_zero, mul_zero, add_zero]\n  | succ d ih =>\n    rw [mul_succ, mul_succ, mul_succ, ih]\n    rw [add_assoc, add_right_comm (mul a d), ← add_assoc, add_comm b a, add_assoc]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by"]}
{"id": 29, "name": "mul_assoc", "statement": "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "proof": "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c) := by\n  induction c with\n  | zero =>\n    rw [mul_zero, mul_zero, mul_zero]\n  | succ d ih =>\n    rw [mul_succ, mul_succ, mul_add, ih]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by"]}
{"id": 30, "name": "zero_pow_zero", "statement": "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "proof": "theorem zero_pow_zero : pow zero zero = one := by\n  rw [pow_zero]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by"]}
{"id": 31, "name": "zero_pow_succ", "statement": "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "proof": "theorem zero_pow_succ (m : MyNat) : pow zero (succ m) = zero := by\n  induction m with\n  | zero =>\n    rw [pow_succ]\n    rw [pow_zero]\n    rw [mul_zero]\n  | succ d ih =>\n    rw [pow_succ]\n    rw [ih]\n    rw [mul_zero]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by"]}
{"id": 32, "name": "pow_one", "statement": "theorem pow_one (a : MyNat) : pow a one = a  := by", "proof": "theorem pow_one (a : MyNat) : pow a one = a := by\n  rw [one_eq_succ_zero]\n  rw [pow_succ]\n  rw [pow_zero]\n  rw [one_mul]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by"]}
{"id": 33, "name": "one_pow", "statement": "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by", "proof": "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by\n  induction m with\n  | zero =>\n    rw [pow_zero]\n  | succ d ih =>\n    rw [pow_succ, ih, mul_one]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by"]}
{"id": 34, "name": "pow_two", "statement": "theorem pow_two (a : MyNat) : pow a two = mul a a := by", "proof": "theorem pow_two (a : MyNat) : pow a two = mul a a := by\n  rw [two_eq_succ_one]\n  rw [pow_succ]\n  rw [pow_one]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by", "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by"]}
{"id": 35, "name": "pow_add", "statement": "theorem pow_add (a m n : MyNat) : pow a (add m n) = mul (pow a m) (pow a n) := by", "proof": "theorem pow_add (a m n : MyNat) : pow a (add m n) = mul (pow a m) (pow a n) := by\n  induction n with\n  | zero =>\n    rw [add_zero]\n    rw [pow_zero]\n    rw [mul_one]\n  | succ d ih =>\n    rw [add_succ]\n    rw [pow_succ]\n    rw [ih]\n    rw [mul_assoc]\n    rw [pow_succ]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by", "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by", "theorem pow_two (a : MyNat) : pow a two = mul a a := by"]}
{"id": 36, "name": "mul_pow", "statement": "theorem mul_pow (a b n : MyNat) : pow (mul a b) n = mul (pow a n) (pow b n) := by", "proof": "theorem mul_pow (a b n : MyNat) : pow (mul a b) n = mul (pow a n) (pow b n) := by\n  induction n with\n  | zero =>\n    rw [pow_zero, pow_zero, pow_zero]\n    rw [mul_one]\n  | succ d ih =>\n    rw [pow_succ, pow_succ, pow_succ]\n    rw [ih]\n    rw [mul_assoc]\n    nth_rewrite 2 [mul_comm b a]\n    rw [← mul_assoc (pow a d)]\n    rw [mul_assoc a]\n    rw [mul_comm a (mul (pow b d) b)]\n    rw [← mul_assoc]\n    rw [mul_assoc]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by", "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by", "theorem pow_two (a : MyNat) : pow a two = mul a a := by", "theorem pow_add (a m n : MyNat) : pow a (add m n) = mul (pow a m) (pow a n) := by"]}
{"id": 37, "name": "pow_pow", "statement": "theorem pow_pow (a m n : MyNat) : pow (pow a m) n = pow a (mul m n) := by", "proof": "theorem pow_pow (a m n : MyNat) : pow (pow a m) n = pow a (mul m n) := by\n  induction n with\n  | zero =>\n    rw [pow_zero, mul_zero, pow_zero]\n  | succ d ih =>\n    rw [pow_succ, ih, mul_succ, pow_add]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by", "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by", "theorem pow_two (a : MyNat) : pow a two = mul a a := by", "theorem pow_add (a m n : MyNat) : pow a (add m n) = mul (pow a m) (pow a n) := by", "theorem mul_pow (a b n : MyNat) : pow (mul a b) n = mul (pow a n) (pow b n) := by"]}
{"id": 38, "name": "add_sq", "statement": "theorem add_sq (a b : MyNat) : pow (add a b) two = add (add (pow a two) (pow b two)) (mul (mul two a) b) := by", "proof": "sorry", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem zero_pow_zero : pow (zero : MyNat)  zero = one := by", "theorem zero_pow_succ (m : MyNat) : pow (zero : MyNat) (succ m) = zero := by", "theorem pow_one (a : MyNat) : pow a one = a  := by", "theorem one_pow (m : MyNat) : pow (one : MyNat) m = one := by", "theorem pow_two (a : MyNat) : pow a two = mul a a := by", "theorem pow_add (a m n : MyNat) : pow a (add m n) = mul (pow a m) (pow a n) := by", "theorem mul_pow (a b n : MyNat) : pow (mul a b) n = mul (pow a n) (pow b n) := by", "theorem pow_pow (a m n : MyNat) : pow (pow a m) n = pow a (mul m n) := by"]}
{"id": 39, "name": "add_right_cancel", "statement": "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "proof": "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by\n  induction n with\n  | zero =>\n    intro h\n    rw [add_zero, add_zero] at h\n    exact h\n  | succ d ih =>\n    intro h\n    rw [add_succ, add_succ] at h\n    apply succ_inj at h\n    exact ih h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by"]}
{"id": 40, "name": "add_left_cancel", "statement": "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "proof": "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by\n  induction n with\n  | zero =>\n    intro h\n    rw [zero_add, zero_add] at h\n    exact h\n  | succ d ih =>\n    intro h\n    rw [succ_add, succ_add] at h\n    apply succ_inj at h\n    exact ih h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by"]}
{"id": 41, "name": "add_left_eq_self", "statement": "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "proof": "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by\n  induction y with\n  | zero =>\n    intro h\n    rw [add_zero] at h\n    exact h\n  | succ d ih =>\n    intro h\n    rw [add_succ] at h\n    apply succ_inj at h\n    apply ih h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by"]}
{"id": 42, "name": "add_right_eq_self", "statement": "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "proof": "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by\n  induction x with\n  | zero =>\n    intro h\n    rw [add_zero] at h\n    exact h\n  | succ d ih =>\n    intro h\n    rw [add_succ] at h\n    apply succ_inj at h\n    exact ih h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by"]}
{"id": 43, "name": "add_right_eq_zero", "statement": "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "proof": "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by\n  intro h\n  cases b with\n  | zero =>\n    rw [add_zero] at h\n    exact h\n  | succ d =>\n    rw [add_succ] at h\n    have := zero_ne_succ (add a d)\n    contradiction", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by"]}
{"id": 44, "name": "add_left_eq_zero", "statement": "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "proof": "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by\n  intro h\n  induction b with\n  | zero => \n    trivial\n  | succ d ih =>\n    rw [add_succ] at h\n    apply zero_ne_succ (add a d) h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by"]}
{"id": 45, "name": "le_refl", "statement": "theorem le_refl (x : MyNat) : le x x := by", "proof": "theorem le_refl (x : MyNat) : le x x := by\n  use zero\n  rw [add_zero]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by"]}
{"id": 46, "name": "zero_le", "statement": "theorem zero_le (x : MyNat) : le zero x := by", "proof": "theorem zero_le (x : MyNat) : le zero x := by\n  use x\n  rw [zero_add]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by"]}
{"id": 47, "name": "le_succ_self", "statement": "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "proof": "theorem le_succ_self (x : MyNat) : le x (succ x) := by\n  use one\n  rw [succ_eq_add_one]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by"]}
{"id": 48, "name": "le_trans", "statement": "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "proof": "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by\n  cases hxy with | intro c₁ h₁ =>\n  cases hyz with | intro c₂ h₂ =>\n  rw [h₂, h₁]\n  rw [add_assoc]\n  use (add c₁ c₂)", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by"]}
{"id": 49, "name": "le_zero", "statement": "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "proof": "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by\n  cases hx with | intro c hc =>\n  rw [← hc] at *\n  apply add_right_eq_zero\n  exact hc", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by"]}
{"id": 50, "name": "le_antisymm", "statement": "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "proof": "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by\n  cases hxy with | intro c hc =>\n  cases hyx with | intro d hd =>\n  rw [hc] at hd\n  rw [add_assoc] at hd\n  have h := add_right_eq_self x (add c d) hd\n  have hc_zero : c = zero := by\n    apply add_right_eq_zero c d\n    exact h\n  have hd_zero : d = zero := by\n    apply add_left_eq_zero c d\n    exact h\n  rw [hc_zero, add_zero] at hc\n  exact hc.symm", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by"]}
{"id": 51, "name": "or_symm", "statement": "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "proof": "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by\n  cases h with\n  | inl hx => right; exact hx\n  | inr hy => left; exact hy", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by"]}
{"id": 52, "name": "le_total", "statement": "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "proof": "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by\n  induction x with\n  | zero =>\n    left\n    use y\n    rw [zero_add]\n  | succ x ih =>\n    cases ih with\n    | inl hxy =>\n      cases hxy with\n      | intro c hc =>\n        cases c with\n        | zero =>\n          right\n          rw [hc, add_zero]\n          use one\n          rw [succ_eq_add_one]\n        | succ d =>\n          left\n          use d\n          rw [hc, add_succ, succ_add]\n    | inr hyx =>\n      cases hyx with\n      | intro c hc =>\n        right\n        use succ c\n        rw [hc, add_succ]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by"]}
{"id": 53, "name": "succ_le_succ", "statement": "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "proof": "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by\n  cases hx with | intro d hd =>\n  rw [succ_add] at hd\n  apply succ_inj at hd\n  use d\n  exact hd", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by"]}
{"id": 54, "name": "le_one", "statement": "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "proof": "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by\n  rw [le_iff_exists_add] at hx\n  cases hx with | intro c hc => \n    cases x with\n    | zero => \n      left\n      rfl\n    | succ d => \n      right\n      rw [succ_add] at hc\n      apply succ_inj at hc\n      have hdz := add_right_eq_zero d c hc\n      rw [hdz]\n      rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by"]}
{"id": 55, "name": "le_two", "statement": "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "proof": "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by\n  rw [le_iff_exists_add] at hx\n  cases hx with\n  | intro c hc =>\n    induction x with\n    | zero =>\n      left\n      rfl\n    | succ d ih =>\n      cases d with\n      | zero =>\n        right\n        left\n        rw [one_eq_succ_zero]\n        rfl\n      | succ e =>\n        right\n        right\n        rw [two_eq_succ_one, one_eq_succ_zero] at hc\n        rw [add_succ, add_succ, add_zero] at hc\n        apply succ_inj at hc\n        apply succ_inj at hc\n        rw [hc]\n        rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by"]}
{"id": 56, "name": "one_add_le_self", "statement": "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "proof": "theorem one_add_le_self (x : MyNat) : le x (add one x) := by\n  rw [add_comm]\n  use one\n  rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by"]}
{"id": 57, "name": "reflexive", "statement": "theorem reflexive (x : MyNat) : le x  x := by", "proof": "theorem reflexive (x : MyNat) : le x x := by\n  use zero\n  rw [add_zero]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by"]}
{"id": 58, "name": "le_succ", "statement": "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "proof": "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by\n  intro h\n  cases h with | intro c hc =>\n  use succ c\n  rw [hc]\n  rw [add_succ]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by"]}
{"id": 59, "name": "mul_le_mul_right", "statement": "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "proof": "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by\n  rw [le_iff_exists_add] at h\n  cases h with | intro c hc =>\n  rw [hc, add_mul]\n  use (mul c t)\n  rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by"]}
{"id": 60, "name": "mul_left_ne_zero", "statement": "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "proof": "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by\n  contrapose! h\n  rw [h, mul_zero]", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by"]}
{"id": 61, "name": "eq_succ_of_ne_zero", "statement": "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "proof": "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by\n  induction a with\n  | zero =>\n    contradiction\n  | succ d =>\n    use d\n    rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by"]}
{"id": 62, "name": "one_le_of_ne_zero", "statement": "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "proof": "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by\n  cases (eq_succ_of_ne_zero a ha) with\n  | intro n hn =>\n    rw [hn]\n    rw [succ_eq_add_one]\n    rw [add_comm]\n    use n\n    rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by"]}
{"id": 63, "name": "le_mul_right", "statement": "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by", "proof": "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by\n  -- Since mul a b ≠ zero, b ≠ zero by mul_left_ne_zero\n  have hb : b ≠ zero := mul_left_ne_zero a b h\n  -- Express b as succ k for some k\n  cases eq_succ_of_ne_zero b hb with\n  | intro k hk =>\n    -- Rewrite b as succ k\n    rw [hk]\n    -- Apply mul_succ to rewrite mul a (succ k)\n    rw [mul_succ]\n    -- Now we need to show le a (add (mul a k) a)\n    -- Rewrite add (mul a k) a as add a (mul a k) using add_comm\n    rw [add_comm (mul a k) a]\n    -- Now mul a (succ k) = add a (mul a k), so le holds with c = mul a k\n    use (mul a k)\n    rfl", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by"]}
{"id": 64, "name": "mul_right_eq_one", "statement": "theorem mul_right_eq_one (x y : MyNat) (h : mul x y = one) : x = one := by", "proof": "theorem mul_right_eq_one (x y : MyNat) (h : mul x y = one) : x = one := by\n  cases x with\n  | zero =>\n    rw [mul_zero] at h\n    contradiction\n  | succ n =>\n    cases n with\n    | zero =>\n      rfl\n    | succ k =>\n      rw [mul_succ] at h\n      have h_add := h\n      rw [add] at h_add\n      have : succ (add (mul (succ k) y) (succ k)) = succ zero := by\n        rw [← h_add]\n      apply succ_inj at this\n      have : succ k = zero := by\n        apply add_left_eq_zero at this\n        exact this\n      contradiction", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by"]}
{"id": 65, "name": "mul_ne_zero", "statement": "theorem mul_ne_zero (a b : MyNat) (ha : a ≠ zero) (hb : b ≠ zero) : mul a b ≠ zero := by", "proof": "theorem mul_ne_zero (a b : MyNat) (ha : a ≠ zero) (hb : b ≠ zero) : mul a b ≠ zero := by\n  -- Express a and b as successors since they are non-zero\n  cases (eq_succ_of_ne_zero a ha) with\n  | intro a' ha' => rw [ha']\n  cases (eq_succ_of_ne_zero b hb) with\n  | intro b' hb' => rw [hb']\n  -- Now a = succ a' and b = succ b'\n  rw [mul_succ]\n  -- Goal: add (mul (succ a') b') (succ a') ≠ zero\n  intro h\n  -- If add (mul (succ a') b') (succ a') = zero, then succ a' = zero by add_right_eq_zero\n  have h1 := add_right_eq_zero (mul (succ a') b') (succ a') h\n  -- But succ a' ≠ zero by zero_ne_succ\n  exact zero_ne_succ a' h1", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by", "theorem mul_right_eq_one (x y : MyNat) (h : mul x y = one) : x = one := by"]}
{"id": 66, "name": "mul_eq_zero", "statement": "theorem mul_eq_zero (a b : MyNat) (h : mul a b = zero) : a = zero ∨ b = zero := by", "proof": "theorem mul_eq_zero (a b : MyNat) (h : mul a b = zero) : a = zero ∨ b = zero := by\n  -- Prove the contrapositive: a ≠ zero ∧ b ≠ zero → mul a b ≠ zero\n  contrapose! h\n  -- Now h is a ≠ zero ∧ b ≠ zero, and we need to prove mul a b ≠ zero\n  cases h with\n  | intro ha hb =>\n    -- Since a ≠ zero, we can write a as succ n for some n\n    have ⟨n, hn⟩ := eq_succ_of_ne_zero a ha\n    -- Since b ≠ zero, we can write b as succ m for some m\n    have ⟨m, hm⟩ := eq_succ_of_ne_zero b hb\n    -- Rewrite a and b in terms of successors\n    rw [hn, hm]\n    -- Now we need to show mul (succ n) (succ m) ≠ zero\n    rw [mul_succ]\n    -- mul (succ n) (succ m) = add (mul (succ n) m) (succ n)\n    -- To show add (mul (succ n) m) (succ n) ≠ zero\n    -- Since succ n ≠ zero, the sum cannot be zero\n    apply fun h => zero_ne_succ n (add_left_eq_zero (mul (succ n) m) (succ n) h)", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by", "theorem mul_right_eq_one (x y : MyNat) (h : mul x y = one) : x = one := by", "theorem mul_ne_zero (a b : MyNat) (ha : a ≠ zero) (hb : b ≠ zero) : mul a b ≠ zero := by"]}
{"id": 67, "name": "mul_left_cancel", "statement": "theorem mul_left_cancel (a b c : MyNat) (ha : a ≠ zero) (h : mul a b = mul a c) : b = c := by", "proof": "theorem mul_left_cancel (a b c : MyNat) (ha : a ≠ zero) (h : mul a b = mul a c) : b = c := by\n  induction b with\n  | zero =>\n    -- Base case: b = zero\n    rw [mul_zero] at h\n    cases (mul_eq_zero a c h) with\n    | inl h1 => contradiction\n    | inr h2 => exact h2\n  | succ d ih =>\n    -- Inductive step: b = succ d\n    cases c with\n    | zero =>\n      -- Case c = zero leads to contradiction\n      rw [mul_zero] at h\n      rw [mul_succ] at h\n      have h1 := add_right_eq_zero (mul a d) a h\n      cases h1 with\n      | inl h2 => contradiction\n      | inr h2 => exact h2\n    | succ e =>\n      -- Case c = succ e\n      rw [mul_succ, mul_succ] at h\n      apply succ_inj\n      apply ih\n      apply add_right_cancel _ _ a h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by", "theorem mul_right_eq_one (x y : MyNat) (h : mul x y = one) : x = one := by", "theorem mul_ne_zero (a b : MyNat) (ha : a ≠ zero) (hb : b ≠ zero) : mul a b ≠ zero := by", "theorem mul_eq_zero (a b : MyNat) (h : mul a b = zero) : a = zero ∨ b = zero := by"]}
{"id": 68, "name": "mul_right_eq_self", "statement": "theorem mul_right_eq_self (a b : MyNat) (ha : a ≠ zero) (h : mul a b = a) : b = one := by", "proof": "theorem mul_right_eq_self (a b : MyNat) (ha : a ≠ zero) (h : mul a b = a) : b = one := by\n  rw [← mul_one a] at h\n  exact mul_left_cancel a b one ha h", "known_theorems": ["theorem zero_add (n : MyNat) : add zero n = n := by", "theorem succ_add (a b : MyNat) : add (succ a) b = succ (add a b)  := by", "theorem add_comm (a b : MyNat) : add a b = add b a := by", "theorem add_assoc (a b c : MyNat) : add (add a b) c = add a (add b c) := by", "theorem add_right_comm (a b c : MyNat) : add (add a b) c = add (add a c) b := by", "theorem add_left_comm (a b c : MyNat) : add a (add b c) = add b (add a c) := by", "theorem succ_eq_add_one (n : MyNat) : succ n = add n one := by", "theorem add_right_cancel (a b n : MyNat) : add a n = add b n → a = b := by", "theorem add_left_cancel (a b n : MyNat) : add n a = add n b → a = b := by", "theorem add_left_eq_self (x y : MyNat) : add x y = y → x = zero := by", "theorem add_right_eq_self (x y : MyNat) : add x y = x → y = zero := by", "theorem add_right_eq_zero (a b : MyNat) : add a b = zero → a = zero := by", "theorem add_left_eq_zero (a b : MyNat) : add a b = zero → b = zero := by", "theorem le_refl (x : MyNat) : le x x := by", "theorem zero_le (x : MyNat) : le zero x := by", "theorem le_succ_self (x : MyNat) : le x (succ x) := by", "theorem le_trans (x y z : MyNat) (hxy : le x y) (hyz : le y z) : le x z := by", "theorem le_zero (x : MyNat) (hx : le x zero) : x = zero := by", "theorem le_antisymm (x y : MyNat) (hxy : le x y) (hyx : le y x) : x = y := by", "theorem or_symm (x y : MyNat) (h : x = four ∨ y = three) : y = three ∨ x = four := by", "theorem le_total (x y : MyNat) : (le x y) ∨ (le y x) := by", "theorem succ_le_succ (x y : MyNat) (hx : le (succ x) (succ y)) : le x y := by", "theorem le_one (x : MyNat) (hx : le x one) : x = zero ∨ x = one := by", "theorem le_two (x : MyNat) (hx : le x two) : x = zero ∨ x = one ∨ x = two := by", "theorem one_add_le_self (x : MyNat) : le x (add one x) := by", "theorem reflexive (x : MyNat) : le x  x := by", "theorem le_succ (a b : MyNat) : le a b → le a (succ b) := by", "theorem mul_one (m : MyNat) : mul m one = m := by", "theorem zero_mul (m : MyNat) : mul zero m = zero := by", "theorem succ_mul (a b : MyNat) : mul (succ a) b = add (mul a b) b := by", "theorem mul_comm (a b : MyNat) : mul a b = mul b a := by", "theorem one_mul (m : MyNat) : mul one m = m := by", "theorem two_mul (m : MyNat) : mul two m = add m m := by", "theorem mul_add (a b c : MyNat) : mul a (add b c) = add (mul a b) (mul a c) := by", "theorem add_mul (a b c : MyNat) : mul (add a b) c = add (mul a c) (mul b c) := by", "theorem mul_assoc (a b c : MyNat) : mul (mul a b) c = mul a (mul b c)  := by", "theorem mul_le_mul_right (a b t : MyNat) (h : le a b) : le (mul a t) (mul b t) := by", "theorem mul_left_ne_zero (a b : MyNat) (h : mul a b ≠ zero) : b ≠ zero := by", "theorem eq_succ_of_ne_zero (a : MyNat) (ha : a ≠ zero) : ∃ n, a = succ n := by", "theorem one_le_of_ne_zero (a : MyNat) (ha : a ≠ zero) : le one a := by", "theorem le_mul_right (a b : MyNat) (h : mul a b ≠ zero) : le a (mul a b) := by", "theorem mul_right_eq_one (x y : MyNat) (h : mul x y = one) : x = one := by", "theorem mul_ne_zero (a b : MyNat) (ha : a ≠ zero) (hb : b ≠ zero) : mul a b ≠ zero := by", "theorem mul_eq_zero (a b : MyNat) (h : mul a b = zero) : a = zero ∨ b = zero := by", "theorem mul_left_cancel (a b c : MyNat) (ha : a ≠ zero) (h : mul a b = mul a c) : b = c := by"]}
